<!DOCTYPE html>

<html lang="en" data-content_root="../../">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>pycvxset.Polytope &#8212; pycvxset 1.2.0 documentation</title>
    <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=03e43079" />
    <link rel="stylesheet" type="text/css" href="../../_static/basic.css?v=b08954a9" />
    <link rel="stylesheet" type="text/css" href="../../_static/alabaster.css?v=f6a572b4" />
    <script src="../../_static/documentation_options.js?v=6efca38a"></script>
    <script src="../../_static/doctools.js?v=fd6eb6e6"></script>
    <script src="../../_static/sphinx_highlight.js?v=6ffebe34"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
   
  <link rel="stylesheet" href="../../_static/custom.css" type="text/css" />
  

  
  

  </head><body>
  <div class="document">
    
      <div class="sphinxsidebar" role="navigation" aria-label="Main">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="../../index.html">
              <img class="logo" src="../../_static/pycvxset_logo.png" alt="Logo of pycvxset"/>
            </a></p>
<h1 class="logo"><a href="../../index.html">pycvxset</a></h1>



<p class="blurb">A Python package for manipulation and visualization of convex sets.</p>




<p>
<iframe src="https://ghbtns.com/github-btn.html?user=merlresearch&repo=pycvxset&type=star&count=true&size=large&v=2"
  allowtransparency="true" frameborder="0" scrolling="0" width="200px" height="35px"></iframe>
</p>






<search id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</search>
<script>document.getElementById('searchbox').style.display = "block"</script><!-- Copyright (C) 2020-2026 Mitsubishi Electric Research Laboratories (MERL)

SPDX-License-Identifier: AGPL-3.0-or-later

Code purpose: Custom navigation side bar for documentation website -->

</br>
<h3>Navigation</h3>
<ul>
    <li class="toctree-l1">
        <a class="reference internal" href="../../tutorials/tutorials.html">Tutorials</a>
    </li>
    <li class="toctree-l1" style="color: #444;font-size:120%">Set Representations</li>
    <ul>
        <li class="toctree-l2">
            <a class="reference internal" href="../../api_summary/pycvxset.Polytope.html">Polytope</a>
        </li>
        <li class="toctree-l2">
            <a class="reference internal" href="../../api_summary/pycvxset.Ellipsoid.html">Ellipsoid</a>
        </li>
        <li class="toctree-l2">
            <a class="reference internal"
                href="../../api_summary/pycvxset.ConstrainedZonotope.html">ConstrainedZonotope
            </a>
        </li>
    </ul>
    <li class="toctree-l1"><a class="reference internal" href="../../pycvxset.common.html">Other useful
            methods</a></li>
    <li class="toctree-l1"><a class="reference internal"
            href="../../pycvxset.common.constants.html">Constants</a></li>
    <li class="toctree-l1"><a class="reference external"
            href="https://raw.githubusercontent.com/merlresearch/pycvxset/main/MANUAL.pdf" target="_blank">Manual
            (PDF)</a></li>
    <li class="toctree-l1"><a class="reference external" href="https://www.merl.com/publications/docs/TR2025-086.pdf" target="_blank">Paper (ACC '25)
            </a></li>
    <li class="toctree-l1"><a class="reference internal" href="../../references.html">References</a></li>
</ul>
        </div>
      </div>
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <h1>Source code for pycvxset.Polytope</h1><div class="highlight"><pre>
<span></span><span class="c1"># Copyright (C) 2020-2026 Mitsubishi Electric Research Laboratories (MERL)</span>
<span class="c1"># Copyright (c) 2019 Tor Aksel N. Heirung</span>
<span class="c1">#</span>
<span class="c1"># SPDX-License-Identifier: AGPL-3.0-or-later</span>
<span class="c1"># SPDX-License-Identifier: MIT</span>

<span class="c1"># Code purpose:  Define the Polytope class</span>
<span class="c1"># Coverage: This file has 2 missing statements + 46 excluded statements + 0 partial branches.</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">__future__</span><span class="w"> </span><span class="kn">import</span> <span class="n">annotations</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">warnings</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">typing</span><span class="w"> </span><span class="kn">import</span> <span class="n">TYPE_CHECKING</span><span class="p">,</span> <span class="n">Any</span><span class="p">,</span> <span class="n">Literal</span><span class="p">,</span> <span class="n">Optional</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">,</span> <span class="n">cast</span><span class="p">,</span> <span class="n">overload</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">pycvxset</span><span class="w"> </span><span class="kn">import</span> <span class="n">ConstrainedZonotope</span>

<span class="k">if</span> <span class="n">TYPE_CHECKING</span><span class="p">:</span>
    <span class="kn">import</span><span class="w"> </span><span class="nn">cvxpy</span>
    <span class="kn">from</span><span class="w"> </span><span class="nn">pycvxset.Ellipsoid</span><span class="w"> </span><span class="kn">import</span> <span class="n">Ellipsoid</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">pycvxset.common</span><span class="w"> </span><span class="kn">import</span> <span class="p">(</span>
    <span class="n">_compute_project_multiple_points</span><span class="p">,</span>
    <span class="n">_compute_support_function_multiple_eta</span><span class="p">,</span>
    <span class="n">convex_set_closest_point</span><span class="p">,</span>
    <span class="n">convex_set_distance</span><span class="p">,</span>
    <span class="n">convex_set_extreme</span><span class="p">,</span>
    <span class="n">convex_set_project</span><span class="p">,</span>
    <span class="n">convex_set_projection</span><span class="p">,</span>
    <span class="n">convex_set_slice</span><span class="p">,</span>
    <span class="n">convex_set_slice_then_projection</span><span class="p">,</span>
    <span class="n">convex_set_support</span><span class="p">,</span>
    <span class="n">is_constrained_zonotope</span><span class="p">,</span>
    <span class="n">is_ellipsoid</span><span class="p">,</span>
    <span class="n">is_polytope</span><span class="p">,</span>
    <span class="n">minimize</span><span class="p">,</span>
    <span class="n">sanitize_Ab</span><span class="p">,</span>
    <span class="n">sanitize_and_identify_Aebe</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">pycvxset.common.constants</span><span class="w"> </span><span class="kn">import</span> <span class="p">(</span>
    <span class="n">DEFAULT_CVXPY_ARGS_LP</span><span class="p">,</span>
    <span class="n">DEFAULT_CVXPY_ARGS_SDP</span><span class="p">,</span>
    <span class="n">DEFAULT_CVXPY_ARGS_SOCP</span><span class="p">,</span>
    <span class="n">PYCVXSET_ZERO</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">pycvxset.Polytope.operations_binary</span><span class="w"> </span><span class="kn">import</span> <span class="p">(</span>
    <span class="n">DOCSTRING_FOR_PROJECT</span><span class="p">,</span>
    <span class="n">DOCSTRING_FOR_PROJECTION</span><span class="p">,</span>
    <span class="n">DOCSTRING_FOR_SLICE</span><span class="p">,</span>
    <span class="n">DOCSTRING_FOR_SLICE_THEN_PROJECTION</span><span class="p">,</span>
    <span class="n">DOCSTRING_FOR_SUPPORT</span><span class="p">,</span>
    <span class="n">affine_map</span><span class="p">,</span>
    <span class="n">contains</span><span class="p">,</span>
    <span class="n">intersection</span><span class="p">,</span>
    <span class="n">intersection_under_inverse_affine_map</span><span class="p">,</span>
    <span class="n">intersection_with_affine_set</span><span class="p">,</span>
    <span class="n">intersection_with_halfspaces</span><span class="p">,</span>
    <span class="n">inverse_affine_map_under_invertible_matrix</span><span class="p">,</span>
    <span class="n">minus</span><span class="p">,</span>
    <span class="n">plus</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">pycvxset.Polytope.operations_unary</span><span class="w"> </span><span class="kn">import</span> <span class="p">(</span>
    <span class="n">chebyshev_centering</span><span class="p">,</span>
    <span class="n">decompose_as_affine_transform_of_polytope_without_equalities</span><span class="p">,</span>
    <span class="n">deflate_rectangle</span><span class="p">,</span>
    <span class="n">interior_point</span><span class="p">,</span>
    <span class="n">maximum_volume_inscribing_ellipsoid</span><span class="p">,</span>
    <span class="n">minimum_volume_circumscribing_ellipsoid</span><span class="p">,</span>
    <span class="n">minimum_volume_circumscribing_rectangle</span><span class="p">,</span>
    <span class="n">normalize</span><span class="p">,</span>
    <span class="n">volume</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">pycvxset.Polytope.plotting_scripts</span><span class="w"> </span><span class="kn">import</span> <span class="n">plot</span><span class="p">,</span> <span class="n">plot2d</span><span class="p">,</span> <span class="n">plot3d</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">pycvxset.Polytope.vertex_halfspace_enumeration</span><span class="w"> </span><span class="kn">import</span> <span class="p">(</span>
    <span class="n">determine_H_rep</span><span class="p">,</span>
    <span class="n">determine_V_rep</span><span class="p">,</span>
    <span class="n">minimize_H_rep</span><span class="p">,</span>
    <span class="n">minimize_V_rep</span><span class="p">,</span>
    <span class="n">valid_rows_with_not_all_zeros_in_A_and_no_inf_in_b</span><span class="p">,</span>
<span class="p">)</span>


<div class="viewcode-block" id="Polytope">
<a class="viewcode-back" href="../../pycvxset.Polytope.html#pycvxset.Polytope">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">Polytope</span><span class="p">:</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Polytope class.</span>

<span class="sd">    Polytope object construction admits **one** of the following combinations (as keyword arguments):</span>

<span class="sd">    #. (A, b) for a polytope in **halfspace representation (H-rep)**  :math:`\{x\ |\ Ax \leq b\}`,</span>
<span class="sd">    #. (A, b, Ae, be) for a polytope in **halfspace representation (H-rep) with equality constraints** :math:`\{x\ |\</span>
<span class="sd">       Ax \leq b, A_e x = b_e\}`,</span>
<span class="sd">    #. V for a polytope in **vertex representation (V-rep)** --- :math:`\text{ConvexHull}(v_i)` where :math:`v_i` are</span>
<span class="sd">       rows of matrix V,</span>
<span class="sd">    #. (lb, ub) for an **axis-aligned cuboid** with appropriate bounds :math:`\{x\ |\ lb\leq x \leq ub\}`, and</span>
<span class="sd">    #. (c, h) for an **axis-aligned cuboid** centered at c with specified scalar/vector half-sides :math:`h`,</span>
<span class="sd">       :math:`\{x\ |\ \forall i\in\{1,\cdots,n\}, |x_i - c_i| \leq h_i\}.`</span>
<span class="sd">    #. dim for an **empty** Polytope of dimension dim (no argument generates a zero-dimensional **empty** Polytope),</span>

<span class="sd">    Args:</span>
<span class="sd">        dim (int, optional): Dimension of the empty polytope. If NOTHING is provided, dim=0 is assumed.</span>
<span class="sd">        V (Sequence[Sequence[float]] | np.ndarray, optional): List of vertices of the polytope (V-Rep). The list must be</span>
<span class="sd">            2-dimensional with vertices arranged row-wise and the polytope dimension determined by the column count.</span>
<span class="sd">        A (Sequence[Sequence[float]] | np.ndarray, optional): Inequality coefficient vectors (H-Rep). The vectors are</span>
<span class="sd">            stacked vertically with the polytope dimension determined by the column count. When A is provided, b must</span>
<span class="sd">            also be provided.</span>
<span class="sd">        b (Sequence[float] | np.ndarray, optional): Inequality constants (H-Rep). The constants are expected to be in a</span>
<span class="sd">            1D numpy array.  When b is provided, A must also be provided.</span>
<span class="sd">        Ae (Sequence[Sequence[float]] | np.ndarray): Equality coefficient vectors (H-Rep). The vectors are stacked</span>
<span class="sd">            vertically with matching number of columns as A. When Ae is provided, A, b, and be must also be provided.</span>
<span class="sd">        be (Sequence[float] | np.ndarray): Equality coefficient constants (H-Rep). The constants are expected to be in a</span>
<span class="sd">            1D numpy array.  When be is provided, A, b, and Ae must also be provided.</span>
<span class="sd">        lb (Sequence[float] | np.ndarray, optional): Lower bounds of the axis-aligned cuboid. Must be 1D array, and the</span>
<span class="sd">            polytope dimension is determined by number of elements in lb. When lb is provided, ub must also be provided.</span>
<span class="sd">        ub (Sequence[float] | np.ndarray, optional): Upper bounds of the axis-aligned cuboid. Must be 1D array of length</span>
<span class="sd">            as same as lb.  When ub is provided, lb must also be provided.</span>
<span class="sd">        c (Sequence[float] | np.ndarray, optional): Center of the axis-aligned cuboid. Must be 1D array, and the</span>
<span class="sd">            polytope dimension is determined by number of elements in c. When c is provided, h must also be provided.</span>
<span class="sd">        h (float | Sequence[float] | np.ndarray, optional): Half-side length of the axis-aligned cuboid. Can be a scalar</span>
<span class="sd">            or a vector of length as same as c. When h is provided, c must also be provided.</span>

<span class="sd">    Raises:</span>
<span class="sd">        ValueError: When arguments provided is not one of [(A, b), (A, b, Ae, be), (lb, ub), (c, h), V, dim,</span>
<span class="sd">            NOTHING]</span>
<span class="sd">        ValueError: Errors raised by issues with (A, b) and (Ae, be) --- mismatch in dimensions, not convertible to</span>
<span class="sd">            appropriately-dimensioned numpy arrays, incompatible systems (A, b) and (Ae, be) etc.</span>
<span class="sd">        ValueError: Errors raised by issues with V --- not convertible to a 2-D numpy array, etc.</span>
<span class="sd">        ValueError: Errors raised by issues with lb, ub --- mismatch in dimensions, not convertible to</span>
<span class="sd">            1D numpy arrays, etc.</span>
<span class="sd">        ValueError: Errors raised by issues with c, h --- mismatch in dimensions, not convertible to</span>
<span class="sd">            1D numpy arrays, etc.</span>
<span class="sd">        ValueError: Polytope is not bounded in any direction. We use a sufficient condition for speed, and therefore the</span>
<span class="sd">            detection may not be exhaustive.</span>
<span class="sd">        ValueError: Polytope is not bounded in some directions. We use a sufficient condition for speed, and therefore</span>
<span class="sd">            the detection may not be exhaustive.</span>
<span class="sd">        UserWarning: If some rows are removed from (A, b) due to all zeros in A or np.inf in b | (Ae, be) when all</span>
<span class="sd">            zeros in Ae and be.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="n">TYPE_CHECKING</span><span class="p">:</span>

        <span class="nd">@overload</span>
        <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span> <span class="o">...</span>

        <span class="nd">@overload</span>
        <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">dim</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span> <span class="o">...</span>

        <span class="nd">@overload</span>
        <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="o">*</span><span class="p">,</span>
            <span class="n">V</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">Sequence</span><span class="p">[</span><span class="nb">float</span><span class="p">]]</span> <span class="o">|</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
        <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span> <span class="o">...</span>

        <span class="nd">@overload</span>
        <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="o">*</span><span class="p">,</span>
            <span class="n">A</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">Sequence</span><span class="p">[</span><span class="nb">float</span><span class="p">]]</span> <span class="o">|</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
            <span class="n">b</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">|</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
        <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span> <span class="o">...</span>

        <span class="nd">@overload</span>
        <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="o">*</span><span class="p">,</span>
            <span class="n">A</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">Sequence</span><span class="p">[</span><span class="nb">float</span><span class="p">]]</span> <span class="o">|</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
            <span class="n">b</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">|</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
            <span class="n">Ae</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">Sequence</span><span class="p">[</span><span class="nb">float</span><span class="p">]]</span> <span class="o">|</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
            <span class="n">be</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">|</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
        <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span> <span class="o">...</span>

        <span class="nd">@overload</span>
        <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="o">*</span><span class="p">,</span>
            <span class="n">lb</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">|</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
            <span class="n">ub</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">|</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
        <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span> <span class="o">...</span>

        <span class="nd">@overload</span>
        <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="o">*</span><span class="p">,</span>
            <span class="n">c</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">|</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
            <span class="n">h</span><span class="p">:</span> <span class="nb">float</span> <span class="o">|</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">|</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
        <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span> <span class="o">...</span>

<div class="viewcode-block" id="Polytope.__init__">
<a class="viewcode-back" href="../../pycvxset.Polytope.html#pycvxset.Polytope.__init__">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">:</span> <span class="n">Any</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Constructor for Polytope class.&quot;&quot;&quot;</span>
        <span class="c1"># The following attributes are accessible to the user via a getter to avoid end-user interactions</span>
        <span class="c1">##########################################</span>
        <span class="c1"># Attributes set by _set_attributes_from_X</span>
        <span class="c1">##########################################</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_type_of_set</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;Polytope&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_dim</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_A</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)),</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="mi">0</span><span class="p">,))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_Ae</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_be</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)),</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="mi">0</span><span class="p">,))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_V</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_in_H_rep</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_in_V_rep</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="c1"># These attributes are computed if necessary within _set_attributes_from_X</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_is_full_dimensional</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_is_empty</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_is_bounded</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_is_singleton</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="c1"># These attributes are used by CVXPY to solve problems</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_cvxpy_args_lp</span> <span class="o">=</span> <span class="n">DEFAULT_CVXPY_ARGS_LP</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_cvxpy_args_socp</span> <span class="o">=</span> <span class="n">DEFAULT_CVXPY_ARGS_SOCP</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_cvxpy_args_sdp</span> <span class="o">=</span> <span class="n">DEFAULT_CVXPY_ARGS_SDP</span>
        <span class="c1"># Check how the constructor was called.</span>
        <span class="n">empty_polytope_via_n</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;dim&quot;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">)</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">kwargs</span>
        <span class="n">V_passed</span> <span class="o">=</span> <span class="nb">any</span><span class="p">(</span><span class="n">kw</span> <span class="ow">in</span> <span class="n">kwargs</span> <span class="k">for</span> <span class="n">kw</span> <span class="ow">in</span> <span class="p">(</span><span class="s2">&quot;V&quot;</span><span class="p">))</span>
        <span class="n">A_and_b_passed</span> <span class="o">=</span> <span class="nb">all</span><span class="p">(</span><span class="n">k</span> <span class="ow">in</span> <span class="n">kwargs</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="p">(</span><span class="s2">&quot;A&quot;</span><span class="p">,</span> <span class="s2">&quot;b&quot;</span><span class="p">))</span>
        <span class="n">Ae_and_be_passed</span> <span class="o">=</span> <span class="nb">all</span><span class="p">(</span><span class="n">k</span> <span class="ow">in</span> <span class="n">kwargs</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="p">(</span><span class="s2">&quot;Ae&quot;</span><span class="p">,</span> <span class="s2">&quot;be&quot;</span><span class="p">))</span>
        <span class="n">lb_and_ub_passed</span> <span class="o">=</span> <span class="nb">all</span><span class="p">(</span><span class="n">kw</span> <span class="ow">in</span> <span class="n">kwargs</span> <span class="k">for</span> <span class="n">kw</span> <span class="ow">in</span> <span class="p">(</span><span class="s2">&quot;lb&quot;</span><span class="p">,</span> <span class="s2">&quot;ub&quot;</span><span class="p">))</span>
        <span class="n">c_and_h_passed</span> <span class="o">=</span> <span class="nb">all</span><span class="p">(</span><span class="n">kw</span> <span class="ow">in</span> <span class="n">kwargs</span> <span class="k">for</span> <span class="n">kw</span> <span class="ow">in</span> <span class="p">(</span><span class="s2">&quot;c&quot;</span><span class="p">,</span> <span class="s2">&quot;h&quot;</span><span class="p">))</span>

        <span class="c1"># Check valid combination of inputs</span>
        <span class="k">if</span> <span class="n">empty_polytope_via_n</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">:</span>
                <span class="c1"># Calling Polytope() or without n as a kwarg:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_set_polytope_to_empty</span><span class="p">(</span><span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;dim&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Cannot set dimension dim with other arguments&quot;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">V_passed</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="c1"># Calling Polytope(V=?)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_set_attributes_from_V</span><span class="p">(</span><span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;V&quot;</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Cannot set vertices V with other arguments&quot;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">lb_and_ub_passed</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                <span class="c1"># Parse lower and upper bounds.</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_set_attributes_from_bounds</span><span class="p">(</span><span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;lb&quot;</span><span class="p">),</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;ub&quot;</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Cannot set bounds (lb, ub) with other arguments&quot;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">c_and_h_passed</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Cannot set up Polytope from (c, h) with other arguments&quot;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">c</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;c&quot;</span><span class="p">)))</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span>
                    <span class="n">h</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;h&quot;</span><span class="p">))</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span>
                <span class="k">except</span> <span class="p">(</span><span class="ne">TypeError</span><span class="p">,</span> <span class="ne">ValueError</span><span class="p">)</span> <span class="k">as</span> <span class="n">err</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                        <span class="s2">&quot;Expected c and h to be convertible into a numpy 1D array and scalar/1D array of &quot;</span>
                        <span class="sa">f</span><span class="s2">&quot;float respectively! Got c: </span><span class="si">{</span><span class="n">np</span><span class="o">.</span><span class="n">array2string</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;c&#39;</span><span class="p">)))</span><span class="si">}</span><span class="s2"> and &quot;</span>
                        <span class="sa">f</span><span class="s2">&quot;h: </span><span class="si">{</span><span class="n">np</span><span class="o">.</span><span class="n">array2string</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;h&#39;</span><span class="p">)))</span><span class="si">}</span><span class="s2">&quot;</span>
                    <span class="p">)</span> <span class="kn">from</span><span class="w"> </span><span class="nn">err</span>
                <span class="k">if</span> <span class="n">c</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&gt;=</span> <span class="mi">2</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                        <span class="sa">f</span><span class="s2">&quot;Expected c to be a 1-dimensional array-like object! Got c: </span><span class="si">{</span><span class="n">np</span><span class="o">.</span><span class="n">array2string</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">c</span><span class="p">))</span><span class="si">}</span><span class="s2">.&quot;</span>
                    <span class="p">)</span>
                <span class="k">if</span> <span class="n">h</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&gt;=</span> <span class="mi">2</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                        <span class="s2">&quot;Expected h to be a 0-dimensional or 1-dimensional array-like object &quot;</span>
                        <span class="sa">f</span><span class="s2">&quot;Got </span><span class="si">{</span><span class="n">np</span><span class="o">.</span><span class="n">array2string</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">h</span><span class="p">))</span><span class="si">}</span><span class="s2">.&quot;</span>
                    <span class="p">)</span>
                <span class="k">elif</span> <span class="n">h</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">h</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="n">c</span><span class="o">.</span><span class="n">shape</span><span class="p">:</span>
                        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                            <span class="s2">&quot;Expected c and 1-dimensional h to match in dimensions. Got </span><span class="si">{c.shape}</span><span class="s2"> and </span><span class="si">{h.shape}</span><span class="s2">&quot;</span>
                        <span class="p">)</span>
                    <span class="n">lb</span> <span class="o">=</span> <span class="n">c</span> <span class="o">-</span> <span class="n">h</span>
                    <span class="n">ub</span> <span class="o">=</span> <span class="n">c</span> <span class="o">+</span> <span class="n">h</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">lb</span> <span class="o">=</span> <span class="n">c</span> <span class="o">-</span> <span class="n">h</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">ones_like</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
                    <span class="n">ub</span> <span class="o">=</span> <span class="n">c</span> <span class="o">+</span> <span class="n">h</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">ones_like</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_set_attributes_from_bounds</span><span class="p">(</span><span class="n">lb</span><span class="p">,</span> <span class="n">ub</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">A_and_b_passed</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                <span class="c1"># Calling Polytope(A=?, b=?)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_set_attributes_from_Ab_Aebe</span><span class="p">(</span><span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;A&quot;</span><span class="p">),</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;b&quot;</span><span class="p">))</span>
            <span class="k">elif</span> <span class="n">Ae_and_be_passed</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">==</span> <span class="mi">4</span><span class="p">:</span>
                <span class="c1"># Calling Polytope(A=?, b=?, Ae=?, be=?)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_set_attributes_from_Ab_Aebe</span><span class="p">(</span><span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;A&quot;</span><span class="p">),</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;b&quot;</span><span class="p">),</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;Ae&quot;</span><span class="p">),</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;be&quot;</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Cannot set H-Rep (A, b) or (A, b, Ae, be) with other arguments&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Got invalid arguments while defining a polytope. Please specify either (A, b) or (A, b, Ae, be) or &quot;</span>
                <span class="s2">&quot;(lb, ub) or (c, h) or V or dim or NOTHING.&quot;</span>
            <span class="p">)</span></div>


    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">type_of_set</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return the type of set</span>

<span class="sd">        Returns:</span>
<span class="sd">            str: Type of the set</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_type_of_set</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_set_attributes_from_Ab_Aebe</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">A</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Sequence</span><span class="p">[</span><span class="n">Sequence</span><span class="p">[</span><span class="nb">float</span><span class="p">]]</span> <span class="o">|</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">|</span> <span class="kc">None</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">b</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Sequence</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">|</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">|</span> <span class="kc">None</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">Ae</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Sequence</span><span class="p">[</span><span class="n">Sequence</span><span class="p">[</span><span class="nb">float</span><span class="p">]]</span> <span class="o">|</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">|</span> <span class="kc">None</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">be</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Sequence</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">|</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">|</span> <span class="kc">None</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">erase_V_rep</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">enable_warning</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Protected method to set various attributes given (A, b, Ae, be) --- _dim,  _A, _b, _Ae, _be, _in_H_rep,</span>
<span class="sd">        _V, _in_V_rep, _is_empty, _is_full_dimensional, _is_bounded.</span>

<span class="sd">        Args:</span>
<span class="sd">            A (Sequence[Sequence[float]] | np.ndarray | None, optional): Inequality coefficient vectors (H-Rep). The</span>
<span class="sd">                vectors are stacked vertically.</span>
<span class="sd">            b (Sequence[float] | np.ndarray | None, optional): Inequality constants (H-Rep). The constants are expected</span>
<span class="sd">                to be in a 1D numpy array.</span>
<span class="sd">            Ae (Sequence[Sequence[float]] | np.ndarray | None, optional): Equality coefficient vectors (H-Rep). The</span>
<span class="sd">                vectors are stacked vertically.  Defaults to None.</span>
<span class="sd">            be (Sequence[float] | np.ndarray | None, optional): Equality constants (H-Rep). The constants are expected</span>
<span class="sd">                to be in a 1D numpy array. Defaults to None.</span>
<span class="sd">            erase_V_rep (bool, optional): When set to True, we erase V-rep. Defaults to True.</span>
<span class="sd">            enable_warning (bool, optional): Enables the UserWarning. May be turned off if expected. Defaults to True.</span>

<span class="sd">        Raises:</span>
<span class="sd">            ValueError: When (A, b) and (Ae, be) are not a valid system of linear inequalities and equations</span>
<span class="sd">            ValueError: Polytope is not bounded in any direction</span>
<span class="sd">            ValueError: Polytope is not bounded in some directions</span>
<span class="sd">            UserWarning: If some rows are removed</span>

<span class="sd">        Notes:</span>
<span class="sd">            We first check if (Ae, be) is a valid system of linear equations. The set :math:`\{A_e x = b_e\}` can be</span>
<span class="sd">            empty, a single point, or an affine set of dimension :math:`\leq \mathcal{P}.\text{dim}`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_in_H_rep</span> <span class="o">=</span> <span class="kc">True</span>  <span class="c1"># To allow for querying self.n_equalities</span>
        <span class="n">sanitized_A</span><span class="p">,</span> <span class="n">sanitized_b</span> <span class="o">=</span> <span class="n">sanitize_Ab</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
        <span class="n">sanitized_Ae</span><span class="p">,</span> <span class="n">sanitized_be</span><span class="p">,</span> <span class="n">Aebe_status</span><span class="p">,</span> <span class="n">solution_to_Ae_x_eq_be</span> <span class="o">=</span> <span class="n">sanitize_and_identify_Aebe</span><span class="p">(</span><span class="n">Ae</span><span class="p">,</span> <span class="n">be</span><span class="p">)</span>

        <span class="c1"># Set polytope dimension and check for compatibility of (A, b) and (Ae, be)</span>
        <span class="n">inequalities_present</span> <span class="o">=</span> <span class="n">sanitized_A</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="n">inequalities_present</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_dim</span> <span class="o">=</span> <span class="n">sanitized_A</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">elif</span> <span class="n">sanitized_Ae</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_dim</span> <span class="o">=</span> <span class="n">sanitized_Ae</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Polytope is unbounded in all directions!&quot;</span><span class="p">)</span>

        <span class="c1"># Check for compatibility of (A, b) and (Ae, be) if both are present.</span>
        <span class="k">if</span> <span class="n">inequalities_present</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_A</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_b</span> <span class="o">=</span> <span class="n">sanitized_A</span><span class="p">,</span> <span class="n">sanitized_b</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_A</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dim</span><span class="p">)),</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="mi">0</span><span class="p">,))</span>
        <span class="k">if</span> <span class="n">Aebe_status</span> <span class="o">==</span> <span class="s2">&quot;no_Ae_be&quot;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_Ae</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_be</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dim</span><span class="p">)),</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="mi">0</span><span class="p">,))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_Ae</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_be</span> <span class="o">=</span> <span class="n">cast</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">sanitized_Ae</span><span class="p">),</span> <span class="n">cast</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">sanitized_be</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_Ae</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dim</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;Expected A and Ae to have same number of columns. A: </span><span class="si">{self._A.shape}</span><span class="s2">, Ae: </span><span class="si">{self._Ae.shape}</span><span class="s2">&quot;</span>
                <span class="p">)</span>

        <span class="c1"># Process equalities and inequalities together to check if the polytope is empty, single point, affine set, or</span>
        <span class="c1"># not full-dimensional, and to set up attributes accordingly.</span>
        <span class="k">if</span> <span class="n">Aebe_status</span> <span class="o">==</span> <span class="s2">&quot;infeasible&quot;</span> <span class="ow">or</span> <span class="p">(</span>
            <span class="n">Aebe_status</span> <span class="o">==</span> <span class="s2">&quot;single_point&quot;</span>
            <span class="ow">and</span> <span class="n">inequalities_present</span>
            <span class="ow">and</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_A</span> <span class="o">@</span> <span class="n">solution_to_Ae_x_eq_be</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">_b</span> <span class="o">&gt;</span> <span class="n">PYCVXSET_ZERO</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">()</span>
        <span class="p">):</span>
            <span class="c1"># Infeasible or empty with single point only if (A, b) exists and excludes the point.</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_set_polytope_to_empty</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dim</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">Aebe_status</span> <span class="o">==</span> <span class="s2">&quot;single_point&quot;</span><span class="p">:</span>
            <span class="c1"># Single point case (either inequalities are not present or they are present but do not exclude the point)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_is_empty</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_full_dimensional</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_bounded</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_singleton</span> <span class="o">=</span> <span class="p">(</span>
                <span class="kc">False</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">dim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">,</span>
                <span class="kc">True</span><span class="p">,</span>
                <span class="kc">True</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="c1"># Omit assignment of inequalities! They are redundant.</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_A</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dim</span><span class="p">)),</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="mi">0</span><span class="p">,))</span>
            <span class="c1"># Also update V-Rep</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_V</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">solution_to_Ae_x_eq_be</span><span class="p">])</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_in_V_rep</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="n">erase_V_rep</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">elif</span> <span class="ow">not</span> <span class="n">inequalities_present</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">Aebe_status</span> <span class="o">==</span> <span class="s2">&quot;affine_set&quot;</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Polytope is not bounded in some directions!&quot;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>  <span class="c1"># pragma: no cover</span>
                <span class="c1"># no_Ae_be will error out, infeasible and single_point are handled above.</span>
                <span class="k">pass</span>  <span class="c1"># Already handled above. This is just for code clarity.</span>
        <span class="k">else</span><span class="p">:</span>  <span class="c1"># inequalities_present is True and Aebe_status \in [&#39;affine_set&#39;, &#39;no_Ae_be&#39;].</span>
            <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_b</span> <span class="o">==</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_set_polytope_to_empty</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dim</span><span class="p">)</span>
            <span class="k">elif</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_b</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">():</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Polytope is not bounded in any direction!&quot;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">valid_rows_Ab</span> <span class="o">=</span> <span class="n">valid_rows_with_not_all_zeros_in_A_and_no_inf_in_b</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_A</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_b</span><span class="p">)</span>
                <span class="k">if</span> <span class="nb">sum</span><span class="p">(</span><span class="n">valid_rows_Ab</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
                    <span class="c1"># Expected non-singleton H-Rep polytope to have at least 2 inequalities!&quot;)</span>
                    <span class="k">if</span> <span class="n">Aebe_status</span> <span class="o">==</span> <span class="s2">&quot;no_Ae_be&quot;</span><span class="p">:</span>
                        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Polytope is not bounded in any direction!&quot;</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Polytope is not bounded in some directions!&quot;</span><span class="p">)</span>
                <span class="k">elif</span> <span class="n">enable_warning</span> <span class="ow">and</span> <span class="nb">sum</span><span class="p">(</span><span class="n">valid_rows_Ab</span><span class="p">)</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_A</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
                    <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;Removed some rows in A that had all zeros | b that had np.inf!&quot;</span><span class="p">,</span> <span class="ne">UserWarning</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_A</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_b</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">A</span><span class="p">[</span><span class="n">valid_rows_Ab</span><span class="p">,</span> <span class="p">:],</span> <span class="bp">self</span><span class="o">.</span><span class="n">b</span><span class="p">[</span><span class="n">valid_rows_Ab</span><span class="p">]</span>
                <span class="c1"># We have not assigned self._is_empty, self._is_full_dimensional, self._is_bounded OR</span>
                <span class="c1"># Keep the previous assignments</span>

        <span class="k">if</span> <span class="n">erase_V_rep</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_V</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dim</span><span class="p">))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_in_V_rep</span> <span class="o">=</span> <span class="kc">False</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_set_attributes_from_bounds</span><span class="p">(</span><span class="bp">self</span><span class="p">:</span> <span class="n">Polytope</span><span class="p">,</span> <span class="n">lb</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">ub</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Protected method to set various attributes given (lb, ub) --- _dim,  _A, _b, _Ae, _be, _in_H_rep, _V,</span>
<span class="sd">        _in_V_rep, _is_empty, _is_full_dimensional, _is_bounded.</span>

<span class="sd">        Args:</span>
<span class="sd">            lb (np.ndarray): Lower bounds of the axis-aligned box</span>
<span class="sd">            ub (np.ndarray): Upper bounds of the axis-aligned box</span>

<span class="sd">        Raises:</span>
<span class="sd">            ValueError: When lb, ub is not 1D array</span>
<span class="sd">            ValueError: Mismatched dimensions</span>

<span class="sd">        Notes:</span>
<span class="sd">            When lb = ub, this function generates a polytope in V-Rep. Otherwise, it generates a polytope in H-Rep.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">lb</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">lb</span><span class="p">))</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span>
            <span class="n">ub</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">ub</span><span class="p">))</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span>
        <span class="k">except</span> <span class="p">(</span><span class="ne">TypeError</span><span class="p">,</span> <span class="ne">ValueError</span><span class="p">)</span> <span class="k">as</span> <span class="n">err</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Expected lb, ub to convertible into 1D float numpy arrays&quot;</span><span class="p">)</span> <span class="kn">from</span><span class="w"> </span><span class="nn">err</span>
        <span class="k">if</span> <span class="n">lb</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="n">ub</span><span class="o">.</span><span class="n">shape</span> <span class="ow">or</span> <span class="n">lb</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Expected lb, ub to 1D numpy arrays of same shape. Got lb: </span><span class="si">{</span><span class="n">np</span><span class="o">.</span><span class="n">array2string</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">lb</span><span class="p">))</span><span class="si">:</span><span class="s2">s</span><span class="si">}</span><span class="s2"> &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;and ub: </span><span class="si">{</span><span class="n">np</span><span class="o">.</span><span class="n">array2string</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">ub</span><span class="p">))</span><span class="si">:</span><span class="s2">s</span><span class="si">}</span><span class="s2">!&quot;</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">n</span> <span class="o">=</span> <span class="n">lb</span><span class="o">.</span><span class="n">size</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">lb</span> <span class="o">&gt;</span> <span class="n">ub</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_set_polytope_to_empty</span><span class="p">(</span><span class="n">dim</span><span class="o">=</span><span class="n">n</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">np</span><span class="o">.</span><span class="n">isinf</span><span class="p">(</span><span class="n">lb</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">()</span> <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">isinf</span><span class="p">(</span><span class="n">ub</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Polytope is not bounded in some directions!&quot;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>  <span class="c1"># lb &lt;= ub</span>
                <span class="n">lb_ub_indices_for_equality</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">ub</span> <span class="o">-</span> <span class="n">lb</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">PYCVXSET_ZERO</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">lb_ub_indices_for_equality</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="n">n</span><span class="p">:</span>  <span class="c1"># lb = ub. So a single vertex!</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_set_attributes_from_V</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([(</span><span class="n">lb</span> <span class="o">+</span> <span class="n">ub</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">]),</span> <span class="n">erase_H_rep</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                <span class="k">elif</span> <span class="n">lb_ub_indices_for_equality</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="c1"># No equality constraints: lb &lt;= x &lt;= ub with lb &lt; ub &lt;===&gt; x &lt;= ub, -x &lt;= -lb</span>
                    <span class="n">A_bound</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="n">n</span><span class="p">),</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="n">n</span><span class="p">)))</span>
                    <span class="n">b_bound</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">ub</span><span class="p">,</span> <span class="o">-</span><span class="n">lb</span><span class="p">))</span>
                    <span class="c1"># Help _set_attributes_from_Ab_Aebe by setting discernable attributes</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_is_full_dimensional</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_empty</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_bounded</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_singleton</span> <span class="o">=</span> <span class="p">(</span>
                        <span class="kc">True</span><span class="p">,</span>
                        <span class="kc">False</span><span class="p">,</span>
                        <span class="kc">True</span><span class="p">,</span>
                        <span class="kc">False</span><span class="p">,</span>
                    <span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_set_attributes_from_Ab_Aebe</span><span class="p">(</span><span class="n">A_bound</span><span class="p">,</span> <span class="n">b_bound</span><span class="p">,</span> <span class="n">erase_V_rep</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># Some equality and some inequality constraints</span>
                    <span class="n">n_equalities</span> <span class="o">=</span> <span class="n">lb_ub_indices_for_equality</span><span class="o">.</span><span class="n">size</span>
                    <span class="n">n_inequalities</span> <span class="o">=</span> <span class="n">n</span> <span class="o">-</span> <span class="n">n_equalities</span>
                    <span class="c1"># Populate Ae, be</span>
                    <span class="n">Ae</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n_equalities</span><span class="p">,</span> <span class="n">n</span><span class="p">))</span>
                    <span class="n">be</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n_equalities</span><span class="p">,))</span>
                    <span class="k">for</span> <span class="n">Ae_index</span><span class="p">,</span> <span class="n">dim</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">lb_ub_indices_for_equality</span><span class="p">):</span>
                        <span class="n">Ae</span><span class="p">[</span><span class="n">Ae_index</span><span class="p">,</span> <span class="n">dim</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
                        <span class="n">be</span><span class="p">[</span><span class="n">Ae_index</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">lb</span><span class="p">[</span><span class="n">dim</span><span class="p">]</span> <span class="o">+</span> <span class="n">ub</span><span class="p">[</span><span class="n">dim</span><span class="p">])</span> <span class="o">/</span> <span class="mi">2</span>
                    <span class="c1"># Populate A, b</span>
                    <span class="n">lb_ub_indices_for_inequality</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">ub</span> <span class="o">-</span> <span class="n">lb</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">PYCVXSET_ZERO</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
                    <span class="n">A</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">2</span> <span class="o">*</span> <span class="n">n_inequalities</span><span class="p">,</span> <span class="n">n</span><span class="p">))</span>
                    <span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">2</span> <span class="o">*</span> <span class="n">n_inequalities</span><span class="p">,))</span>
                    <span class="k">for</span> <span class="n">A_index</span><span class="p">,</span> <span class="n">dim</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">lb_ub_indices_for_inequality</span><span class="p">):</span>
                        <span class="n">A</span><span class="p">[</span><span class="n">A_index</span><span class="p">,</span> <span class="n">dim</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
                        <span class="n">A</span><span class="p">[</span><span class="n">n_inequalities</span> <span class="o">+</span> <span class="n">A_index</span><span class="p">,</span> <span class="n">dim</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
                        <span class="n">b</span><span class="p">[</span><span class="n">A_index</span><span class="p">]</span> <span class="o">=</span> <span class="n">ub</span><span class="p">[</span><span class="n">dim</span><span class="p">]</span>
                        <span class="n">b</span><span class="p">[</span><span class="n">n_inequalities</span> <span class="o">+</span> <span class="n">A_index</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="n">lb</span><span class="p">[</span><span class="n">dim</span><span class="p">]</span>
                    <span class="c1"># Help _set_attributes_from_Ab_Aebe by setting discernable attributes</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_is_full_dimensional</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_empty</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_bounded</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_singleton</span> <span class="o">=</span> <span class="p">(</span>
                        <span class="kc">False</span><span class="p">,</span>
                        <span class="kc">False</span><span class="p">,</span>
                        <span class="kc">True</span><span class="p">,</span>
                        <span class="kc">False</span><span class="p">,</span>
                    <span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_set_attributes_from_Ab_Aebe</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">Ae</span><span class="o">=</span><span class="n">Ae</span><span class="p">,</span> <span class="n">be</span><span class="o">=</span><span class="n">be</span><span class="p">,</span> <span class="n">erase_V_rep</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_set_attributes_from_V</span><span class="p">(</span><span class="bp">self</span><span class="p">:</span> <span class="n">Polytope</span><span class="p">,</span> <span class="n">V</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">erase_H_rep</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Protected method to set various attributes given (V) --- _dim,  _A, _b, _Ae, _be, _in_H_rep, _V,</span>
<span class="sd">        _in_V_rep, _is_empty, _is_full_dimensional, _is_bounded.</span>

<span class="sd">        Args:</span>
<span class="sd">            V (np.ndarray): List of vertices of the polytope. The list must be 2-dimensional, to avoid the risk of</span>
<span class="sd">                mistaking 1D polytopes as a self.n_vertices-dimensional polytope with 1 vertex. The vertices are</span>
<span class="sd">                arranged row-wise.</span>
<span class="sd">            erase_H_rep (bool): When set to True, we erase H-rep. Defaults to True.</span>

<span class="sd">        Raises:</span>
<span class="sd">            ValueError: When V is not a 2-D numpy array.</span>

<span class="sd">        Notes:</span>
<span class="sd">            This function automatically sets the polytope to be nonempty and bounded.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">V</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">V</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">V</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Expected V to be a 2-D numpy array.&quot;</span><span class="p">)</span>
        <span class="n">n</span> <span class="o">=</span> <span class="n">V</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_set_polytope_to_empty</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>  <span class="c1"># in_V_rep if V is not an empty array</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_in_V_rep</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_V</span> <span class="o">=</span> <span class="n">V</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_dim</span> <span class="o">=</span> <span class="n">n</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_is_empty</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_bounded</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="kc">True</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_is_singleton</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_vertices</span> <span class="o">==</span> <span class="mi">1</span>
            <span class="c1"># We have not assigned self._is_full_dimensional</span>
        <span class="k">if</span> <span class="n">erase_H_rep</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_A</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dim</span><span class="p">)),</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="mi">0</span><span class="p">,))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_Ae</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_be</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dim</span><span class="p">)),</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="mi">0</span><span class="p">,))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_in_H_rep</span> <span class="o">=</span> <span class="kc">False</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_set_polytope_to_empty</span><span class="p">(</span><span class="bp">self</span><span class="p">:</span> <span class="n">Polytope</span><span class="p">,</span> <span class="n">dim</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Protected method to set A, b, dim, no_AbV, V members for an empty polytope&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_dim</span> <span class="o">=</span> <span class="n">dim</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_A</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dim</span><span class="p">)),</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="mi">0</span><span class="p">,))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_Ae</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_be</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dim</span><span class="p">)),</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="mi">0</span><span class="p">,))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_V</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dim</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_in_H_rep</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_in_V_rep</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="kc">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_is_full_dimensional</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_empty</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_bounded</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_singleton</span> <span class="o">=</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">dim</span> <span class="o">==</span> <span class="mi">0</span><span class="p">,</span>
            <span class="kc">True</span><span class="p">,</span>
            <span class="kc">True</span><span class="p">,</span>
            <span class="kc">False</span><span class="p">,</span>
        <span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_update_emptiness_full_dimensionality_for_h_rep_polytope</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Update self._is_empty and self._is_full_dimensional using Chebyshev centering results.</span>

<span class="sd">        Raises:</span>
<span class="sd">            NotImplementedError: Unable to solve chebyshev centering problem using CVXPY</span>

<span class="sd">        Notes:</span>
<span class="sd">            - When in H-Rep, we use Chebyshev_centering to determine if the polytope is nonempty and full-dimensional.</span>
<span class="sd">              Specifically,</span>
<span class="sd">              #. Chebyshev radius == - :math:`infty`, the polytope is empty. In this case, it is full-dimensional, only</span>
<span class="sd">                 if dim=0.</span>
<span class="sd">              #. 0 &lt;= Chebyshev radius &lt;= :math:`\infty`, the polytope is always nonempty. It is full-dimensional when</span>
<span class="sd">                 `self.n_equalities` is 0 or `self.dim` is 1.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">_</span><span class="p">,</span> <span class="n">chebyshev_radius</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">chebyshev_centering</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">chebyshev_radius</span> <span class="o">==</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">:</span>
            <span class="c1"># Set is empty chebyshev_radius &lt; 0 when infeasible</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_is_empty</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_full_dimensional</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dim</span> <span class="o">==</span> <span class="mi">0</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Set is non-empty since chebyshev_radius &gt;= 0</span>
            <span class="c1"># Set is full-dimensional if self.n_equalities == 0 or dim == 1</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_is_empty</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_full_dimensional</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="p">(</span><span class="n">chebyshev_radius</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">dim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_update_boundedness_singleton_for_h_rep_polytope</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Update self._is_empty and self._is_full_dimensional using minimum_volume_circumscribing_rectangle.</span>

<span class="sd">        Raises:</span>
<span class="sd">            ValueError: Unable to solve minimum_volume_circumscribing_rectangle using CVXPY</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">lb</span><span class="p">,</span> <span class="n">ub</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">minimum_volume_circumscribing_rectangle</span><span class="p">()</span>
        <span class="k">except</span> <span class="ne">ValueError</span> <span class="k">as</span> <span class="n">err</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Check for is_bounded and/or is_singleton using minimum_volume_circumscribing_rectangle failed!&quot;</span>
                <span class="s2">&quot;If the set is_bounded and/or is_singleton, try using a different solver.&quot;</span>
            <span class="p">)</span> <span class="kn">from</span><span class="w"> </span><span class="nn">err</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_is_singleton</span> <span class="o">=</span> <span class="nb">bool</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isclose</span><span class="p">(</span><span class="n">lb</span><span class="p">,</span> <span class="n">ub</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">())</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_is_bounded</span> <span class="o">=</span> <span class="nb">bool</span><span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">ub</span><span class="p">,</span> <span class="n">lb</span><span class="p">)))</span> <span class="o">&lt;</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">())</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">dim</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Dimension of the polytope. In H-Rep polytope (A, b), this is the number of columns of A, while in V-Rep,</span>
<span class="sd">        this is the number of components of the vertices.</span>

<span class="sd">        Returns:</span>
<span class="sd">            int: Dimension of the polytope</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dim</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">A</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Inequality coefficient vectors `A` for the polytope :math:`\{Ax \leq b, A_e x = b_e\}`.</span>

<span class="sd">        Returns:</span>
<span class="sd">            numpy.ndarray: Inequality coefficient vector (H-Rep). A is np.empty((0, self.dim)) for empty polytope.</span>

<span class="sd">        Notes:</span>
<span class="sd">            This function requires the polytope to be in H-Rep, and performs a halfspace enumeration if required.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">in_H_rep</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">determine_H_rep</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_A</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">b</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Inequality constants `b` for the polytope :math:`\{Ax \leq b, A_e x = b_e\}`.</span>

<span class="sd">        Returns:</span>
<span class="sd">            numpy.ndarray: Inequality constants (H-Rep). b is np.empty((0,)) for empty polytope.</span>

<span class="sd">        Notes:</span>
<span class="sd">            This function requires the polytope to be in H-Rep, and performs a halfspace enumeration if required.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">in_H_rep</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">determine_H_rep</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">cast</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_b</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">H</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Inequality constraints in halfspace representation `H=[A, b]` for the polytope</span>
<span class="sd">        :math:`\{Ax \leq b, A_e x = b_e\}`.</span>

<span class="sd">        Returns:</span>
<span class="sd">            numpy.ndarray: H-Rep in [A, b]. H is np.empty((0, self.dim + 1)) for empty polytope.</span>

<span class="sd">        Notes:</span>
<span class="sd">            This function requires the polytope to be in H-Rep, and performs a halfspace enumeration if required.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">A</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">b</span><span class="p">])</span><span class="o">.</span><span class="n">T</span><span class="p">))</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">n_halfspaces</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Number of halfspaces used to define the polytope :math:`\{Ax \leq b, A_e x = b_e\}`</span>

<span class="sd">        Returns:</span>
<span class="sd">            int: Number of halfspaces</span>

<span class="sd">        Notes:</span>
<span class="sd">            A call to this property performs a halfspace enumeration if the polytope is in V-Rep.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">A</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>  <span class="c1"># determines H-rep if not determined</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">Ae</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Equality coefficient vectors `Ae` for the polytope :math:`\{Ax \leq b, A_e x = b_e\}`.</span>

<span class="sd">        Returns:</span>
<span class="sd">            numpy.ndarray: Equality coefficient vector (H-Rep). Ae is np.empty((0, self.dim)) for empty or</span>
<span class="sd">                full-dimensional polytope.</span>

<span class="sd">        Notes:</span>
<span class="sd">            This function requires the polytope to be in H-Rep, and performs a halfspace enumeration if required.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">in_H_rep</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">determine_H_rep</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_Ae</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">be</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Equality constants `be` for the polytope :math:`\{Ax \leq b, A_e x = b_e\}`.</span>

<span class="sd">        Returns:</span>
<span class="sd">            numpy.ndarray: Equality constants (H-Rep). be is np.empty((0,)) for empty or full-dimensional polytope.</span>

<span class="sd">        Notes:</span>
<span class="sd">            This function requires the polytope to be in H-Rep, and performs a halfspace enumeration if required.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">in_H_rep</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">determine_H_rep</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_be</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">He</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Equality constraints in halfspace representation `He=[Ae, be]` for the polytope</span>
<span class="sd">        :math:`\{Ax \leq b, A_e x = b_e\}`.</span>

<span class="sd">        Returns:</span>
<span class="sd">            numpy.ndarray: H-Rep in [Ae, be]. He is np.empty((0, self.dim + 1)) for empty or full-dimensional polytope.</span>

<span class="sd">        Notes:</span>
<span class="sd">            This function requires the polytope to be in H-Rep, and performs a halfspace enumeration if required.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">Ae</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">be</span><span class="p">])</span><span class="o">.</span><span class="n">T</span><span class="p">))</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">n_equalities</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Number of linear equality constraints used to define the polytope :math:`\{Ax \leq b, A_e x = b_e\}`</span>

<span class="sd">        Returns:</span>
<span class="sd">            int: Number of linear equality constraints</span>

<span class="sd">        Notes:</span>
<span class="sd">            A call to this property performs a halfspace enumeration if the polytope is in V-Rep.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Ae</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>  <span class="c1"># determines H-rep if not determined</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">V</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Vertex representation (`V`) where the polytope is given by :math:`\text{ConvexHull}(v_i)` with</span>
<span class="sd">        :math:`v_i` as the rows of :math:`V=[v_1;v_2;\ldots;v_{n_vertices}]`.</span>

<span class="sd">        Returns:</span>
<span class="sd">            numpy.ndarray: Vertices of the polytope, arranged row-wise. V is np.empty((0, self.dim)) if polytope is</span>
<span class="sd">            empty.</span>

<span class="sd">        Notes:</span>
<span class="sd">            This function requires the polytope to be in V-Rep, and performs a vertex enumeration if required.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">in_V_rep</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">in_H_rep</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">determine_V_rep</span><span class="p">()</span>  <span class="c1"># Call only if no V-rep and available H-rep</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_V</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">n_vertices</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Number of vertices</span>

<span class="sd">        Returns:</span>
<span class="sd">            int: Number of vertices</span>

<span class="sd">        Notes:</span>
<span class="sd">            A call to this property performs a vertex enumeration if the polytope is in H-Rep.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">V</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>  <span class="c1"># determines V-rep if not determined</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">is_full_dimensional</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Check if the affine dimension of the polytope is the same as the polytope dimension</span>

<span class="sd">        Returns:</span>
<span class="sd">            bool: True when the affine hull containing the polytope has the dimension `self.dim`</span>

<span class="sd">        Notes:</span>
<span class="sd">            This function can have self to be in V-Rep or H-Rep. See Sec. 2.1.3 of [BV04] for discussion on affine</span>
<span class="sd">            dimension.</span>

<span class="sd">            An empty polytope is full dimensional if dim=0, otherwise it is not full-dimensional.</span>

<span class="sd">            When the n-dimensional polytope is in V-rep, it is full-dimensional when its affine dimension is n. Recall</span>
<span class="sd">            that, the affine dimension is the dimension of the affine hull of the polytope is the linear subspace</span>
<span class="sd">            spanned by the vectors formed by subtracting the vertices with one of the vertices. Consequently, its</span>
<span class="sd">            dimension is given by the rank of the matrix P.V[1:] - P.V[0]. When there are fewer than self.dim + 1</span>
<span class="sd">            vertices, we know it is coplanar without checking for matrix rank (simplex needs at least self.dim + 1</span>
<span class="sd">            vertices and that is the polytope with the fewest vertices). For numerical stability, we zero-out all delta</span>
<span class="sd">            vertices below PYCVXSET_ZERO.</span>

<span class="sd">            When the n-dimensional polytope is in H-Rep, it is full-dimensional if it can fit a n-dimensional ball of</span>
<span class="sd">            appropriate center and radius inside it (Chebyshev radius).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_full_dimensional</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">in_V_rep</span><span class="p">:</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">dim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_is_full_dimensional</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_vertices</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dim</span><span class="p">:</span>
                    <span class="c1"># Simplex of n-dim with n &gt; 1 needs at least self.dim + 1 vertices</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_is_full_dimensional</span> <span class="o">=</span> <span class="kc">False</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">delta_vertices</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">V</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">V</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                    <span class="n">delta_vertices</span><span class="p">[</span><span class="nb">abs</span><span class="p">(</span><span class="n">delta_vertices</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">PYCVXSET_ZERO</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_is_full_dimensional</span> <span class="o">=</span> <span class="nb">bool</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">matrix_rank</span><span class="p">(</span><span class="n">delta_vertices</span><span class="p">)</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">dim</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_update_emptiness_full_dimensionality_for_h_rep_polytope</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">cast</span><span class="p">(</span><span class="nb">bool</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_full_dimensional</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">is_empty</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Check if the polytope is empty.</span>

<span class="sd">        Returns:</span>
<span class="sd">            bool: When True, the polytope is empty</span>

<span class="sd">        Notes:</span>
<span class="sd">            This property is well-defined (`self.n_vertices == 0`) when the polytope is in V-Rep and initialized in the</span>
<span class="sd">            constructor. For H-Rep, it solves a Chebyshev centering problem.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_empty</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_update_emptiness_full_dimensionality_for_h_rep_polytope</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">cast</span><span class="p">(</span><span class="nb">bool</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_empty</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">is_singleton</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Check if the polytope is singleton.</span>

<span class="sd">        Returns:</span>
<span class="sd">            bool: When True, the polytope is singleton.</span>

<span class="sd">        Notes:</span>
<span class="sd">            This property is well-defined (`self.n_vertices == 1`) when the polytope is in V-Rep and initialized in the</span>
<span class="sd">            constructor. For H-Rep, it solves a minimum_volume_circumscribing_rectangle problem.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_singleton</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_update_boundedness_singleton_for_h_rep_polytope</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">cast</span><span class="p">(</span><span class="nb">bool</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_singleton</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">is_bounded</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Check if the polytope is bounded.</span>

<span class="sd">        Returns:</span>
<span class="sd">            bool: True if the polytope is bounded, and False otherwise.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_bounded</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_update_boundedness_singleton_for_h_rep_polytope</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">cast</span><span class="p">(</span><span class="nb">bool</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_bounded</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">in_H_rep</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Check if the polytope have a halfspace representation (H-Rep).</span>

<span class="sd">        Returns:</span>
<span class="sd">            bool: When True, the polytope has halfspace representation (H-Rep). Otherwise, False.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_in_H_rep</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">in_V_rep</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Check if the polytope have a vertex representation (V-Rep).</span>

<span class="sd">        Returns:</span>
<span class="sd">           bool: When True, the polytope has vertex representation (V-Rep). Otherwise, False.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_in_V_rep</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">cvxpy_args_lp</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;CVXPY arguments in use when solving a linear program</span>

<span class="sd">        Returns:</span>
<span class="sd">            dict: CVXPY arguments in use when solving a linear program. Defaults to dictionary in</span>
<span class="sd">            `pycvxset.common.DEFAULT_CVXPY_ARGS_LP`.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cvxpy_args_lp</span>

    <span class="nd">@cvxpy_args_lp</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">cvxpy_args_lp</span><span class="p">(</span><span class="bp">self</span><span class="p">:</span> <span class="n">Polytope</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Update CVXPY arguments in use when solving a linear program</span>

<span class="sd">        Args:</span>
<span class="sd">            value: Dictionary with new CVXPY arguments in use when solving a linear program.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_cvxpy_args_lp</span> <span class="o">=</span> <span class="n">value</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">cvxpy_args_socp</span><span class="p">(</span><span class="bp">self</span><span class="p">:</span> <span class="n">Polytope</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;CVXPY arguments in use when solving a second-order cone program</span>

<span class="sd">        Returns:</span>
<span class="sd">            dict: CVXPY arguments in use when solving a second-order cone program. Defaults to dictionary in</span>
<span class="sd">            `pycvxset.common.DEFAULT_CVXPY_ARGS_SOCP`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cvxpy_args_socp</span>

    <span class="nd">@cvxpy_args_socp</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">cvxpy_args_socp</span><span class="p">(</span><span class="bp">self</span><span class="p">:</span> <span class="n">Polytope</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Update CVXPY arguments in use when solving a second-order cone program</span>

<span class="sd">        Args:</span>
<span class="sd">            value: Dictionary with new CVXPY arguments in use when solving a second-order cone program.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_cvxpy_args_socp</span> <span class="o">=</span> <span class="n">value</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">cvxpy_args_sdp</span><span class="p">(</span><span class="bp">self</span><span class="p">:</span> <span class="n">Polytope</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;CVXPY arguments in use when solving a semi-definite program</span>

<span class="sd">        Returns:</span>
<span class="sd">            dict: CVXPY arguments in use when solving a semi-definite program. Defaults to dictionary in</span>
<span class="sd">            `pycvxset.common.DEFAULT_CVXPY_ARGS_SDP`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cvxpy_args_sdp</span>

    <span class="nd">@cvxpy_args_sdp</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">cvxpy_args_sdp</span><span class="p">(</span><span class="bp">self</span><span class="p">:</span> <span class="n">Polytope</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Update CVXPY arguments in use when solving a semi-definite program</span>

<span class="sd">        Args:</span>
<span class="sd">            value: Dictionary with new CVXPY arguments in use when solving a semi-definite program.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_cvxpy_args_sdp</span> <span class="o">=</span> <span class="n">value</span>

    <span class="c1">###########</span>
    <span class="c1"># Plotting</span>
    <span class="c1">###########</span>
    <span class="n">plot</span> <span class="o">=</span> <span class="n">plot</span>
    <span class="n">plot2d</span> <span class="o">=</span> <span class="n">plot2d</span>
    <span class="n">plot3d</span> <span class="o">=</span> <span class="n">plot3d</span>

    <span class="c1">################</span>
    <span class="c1"># CVXPY-focussed</span>
    <span class="c1">################</span>
<div class="viewcode-block" id="Polytope.containment_constraints">
<a class="viewcode-back" href="../../pycvxset.Polytope.html#pycvxset.Polytope.containment_constraints">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">containment_constraints</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="n">cvxpy</span><span class="o">.</span><span class="n">Variable</span><span class="p">,</span> <span class="n">flatten_order</span><span class="p">:</span> <span class="n">Literal</span><span class="p">[</span><span class="s2">&quot;F&quot;</span><span class="p">,</span> <span class="s2">&quot;C&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;F&quot;</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">list</span><span class="p">[</span><span class="n">cvxpy</span><span class="o">.</span><span class="n">Constraint</span><span class="p">],</span> <span class="n">Optional</span><span class="p">[</span><span class="n">cvxpy</span><span class="o">.</span><span class="n">Variable</span><span class="p">]]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get CVXPY constraints for containment of x (a cvxpy.Variable) in a polytope.</span>

<span class="sd">        Args:</span>
<span class="sd">            x (cvxpy.Variable): CVXPY variable to be optimized</span>
<span class="sd">            flatten_order (Literal[&quot;F&quot;, &quot;C&quot;]): Order to use for flatten (choose between &quot;F&quot;, &quot;C&quot;). Defaults to &quot;F&quot;,</span>
<span class="sd">                which implements column-major flatten. In 2D, column-major flatten results in stacking rows horizontally</span>
<span class="sd">                to achieve a single horizontal row.</span>

<span class="sd">        Raises:</span>
<span class="sd">            ValueError: When polytope is empty</span>

<span class="sd">        Returns:</span>
<span class="sd">            tuple: A tuple with two items:</span>

<span class="sd">            #. constraint_list (list): CVXPY constraints for the containment of x in the polytope.</span>
<span class="sd">            #. theta (cvxpy.Variable | None): CVXPY variable representing the convex combination coefficient when</span>
<span class="sd">               polytope is in V-Rep. It is None when the polytope is in H-Rep or empty.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">import</span><span class="w"> </span><span class="nn">cvxpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">cp</span>

        <span class="n">x_reshaped</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">size</span><span class="p">,),</span> <span class="n">order</span><span class="o">=</span><span class="n">flatten_order</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">in_V_rep</span><span class="p">:</span>
            <span class="n">theta</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">Variable</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">n_vertices</span><span class="p">,),</span> <span class="n">nonneg</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">constraints</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">cp</span><span class="o">.</span><span class="n">Constraint</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">x_reshaped</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">V</span><span class="o">.</span><span class="n">T</span> <span class="o">@</span> <span class="n">theta</span><span class="p">,</span> <span class="n">cast</span><span class="p">(</span><span class="n">cp</span><span class="o">.</span><span class="n">Constraint</span><span class="p">,</span> <span class="n">cp</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)]</span>
            <span class="k">return</span> <span class="n">constraints</span><span class="p">,</span> <span class="n">theta</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">in_H_rep</span><span class="p">:</span>
            <span class="n">polytope_containment_constraints</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">cp</span><span class="o">.</span><span class="n">Constraint</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">A</span> <span class="o">@</span> <span class="n">x_reshaped</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">b</span><span class="p">]</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_equalities</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">polytope_containment_constraints</span> <span class="o">+=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">Ae</span> <span class="o">@</span> <span class="n">x_reshaped</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">be</span><span class="p">]</span>
            <span class="k">return</span> <span class="n">polytope_containment_constraints</span><span class="p">,</span> <span class="kc">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Containment constraints can not be generated for an empty polytope!&quot;</span><span class="p">)</span></div>


    <span class="n">minimize</span> <span class="o">=</span> <span class="n">minimize</span>

    <span class="c1">##################</span>
    <span class="c1"># Unary operations</span>
    <span class="c1">##################</span>
<div class="viewcode-block" id="Polytope.copy">
<a class="viewcode-back" href="../../pycvxset.Polytope.html#pycvxset.Polytope.copy">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">copy</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Polytope</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Create a copy of the polytope&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">in_H_rep</span><span class="p">:</span>
            <span class="n">copy_polytope</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="n">A</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">A</span><span class="p">,</span> <span class="n">b</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">b</span><span class="p">,</span> <span class="n">Ae</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">Ae</span><span class="p">,</span> <span class="n">be</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">be</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">in_V_rep</span><span class="p">:</span>
                <span class="n">copy_polytope</span><span class="o">.</span><span class="n">_set_attributes_from_V</span><span class="p">(</span><span class="n">V</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">V</span><span class="p">,</span> <span class="n">erase_H_rep</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">copy_polytope</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">in_V_rep</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="n">V</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">V</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="n">dim</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">dim</span><span class="p">)</span></div>


    <span class="n">chebyshev_centering</span> <span class="o">=</span> <span class="n">chebyshev_centering</span>
    <span class="n">decompose_as_affine_transform_of_polytope_without_equalities</span> <span class="o">=</span> <span class="p">(</span>
        <span class="n">decompose_as_affine_transform_of_polytope_without_equalities</span>
    <span class="p">)</span>
    <span class="n">interior_point</span> <span class="o">=</span> <span class="n">interior_point</span>
    <span class="n">maximum_volume_inscribing_ellipsoid</span> <span class="o">=</span> <span class="n">maximum_volume_inscribing_ellipsoid</span>
    <span class="n">minimum_volume_circumscribing_ellipsoid</span> <span class="o">=</span> <span class="n">minimum_volume_circumscribing_ellipsoid</span>
    <span class="n">minimum_volume_circumscribing_rectangle</span> <span class="o">=</span> <span class="n">minimum_volume_circumscribing_rectangle</span>
    <span class="n">normalize</span> <span class="o">=</span> <span class="n">normalize</span>
    <span class="n">deflate_rectangle</span> <span class="o">=</span> <span class="nb">classmethod</span><span class="p">(</span><span class="n">deflate_rectangle</span><span class="p">)</span>
    <span class="n">volume</span> <span class="o">=</span> <span class="n">volume</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__pow__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">power</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Any</span><span class="p">:</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Compute the Cartesian product with itself.</span>

<span class="sd">        Args:</span>
<span class="sd">            power (int): Number of times the polytope is multiplied with itself</span>

<span class="sd">        Returns:</span>
<span class="sd">            Polytope: The polytope :math:`\mathcal{R}` corresponding to P`^N`.</span>

<span class="sd">        Notes:</span>
<span class="sd">            This function requires the polytope to be in H-Rep, and performs a halfspace enumeration if polytope is in</span>
<span class="sd">            V-Rep.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">concatenated_polytope_A</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">kron</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="n">power</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">A</span><span class="p">)</span>
        <span class="n">concatenated_polytope_b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">b</span><span class="p">,</span> <span class="p">(</span><span class="n">power</span><span class="p">,))</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_equalities</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">concatenated_polytope_Ae</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">kron</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="n">power</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">Ae</span><span class="p">)</span>
            <span class="n">concatenated_polytope_be</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">be</span><span class="p">,</span> <span class="p">(</span><span class="n">power</span><span class="p">,))</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span>
                <span class="n">A</span><span class="o">=</span><span class="n">concatenated_polytope_A</span><span class="p">,</span>
                <span class="n">b</span><span class="o">=</span><span class="n">concatenated_polytope_b</span><span class="p">,</span>
                <span class="n">Ae</span><span class="o">=</span><span class="n">concatenated_polytope_Ae</span><span class="p">,</span>
                <span class="n">be</span><span class="o">=</span><span class="n">concatenated_polytope_be</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="n">A</span><span class="o">=</span><span class="n">concatenated_polytope_A</span><span class="p">,</span> <span class="n">b</span><span class="o">=</span><span class="n">concatenated_polytope_b</span><span class="p">)</span>

    <span class="c1">######################</span>
    <span class="c1"># Comparison operators</span>
    <span class="c1">######################</span>
    <span class="n">contains</span> <span class="o">=</span> <span class="n">contains</span>
    <span class="fm">__contains__</span> <span class="o">=</span> <span class="n">contains</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__le__</span><span class="p">(</span><span class="bp">self</span><span class="p">:</span> <span class="n">Polytope</span><span class="p">,</span> <span class="n">Q</span><span class="p">:</span> <span class="n">ConstrainedZonotope</span> <span class="o">|</span> <span class="n">Polytope</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Any</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Overload &lt;= operator for containment. self &lt;= Q is equivalent to Q.contains(self).&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">is_polytope</span><span class="p">(</span><span class="n">Q</span><span class="p">)</span> <span class="ow">or</span> <span class="n">is_constrained_zonotope</span><span class="p">(</span><span class="n">Q</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">Q</span><span class="o">.</span><span class="n">contains</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Q is a constrained zonotope ====&gt; Polytope &lt;= ConstrainedZonotope case</span>
            <span class="k">return</span> <span class="bp">NotImplemented</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__ge__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">:</span> <span class="n">Polytope</span><span class="p">,</span>
        <span class="n">Q</span><span class="p">:</span> <span class="s2">&quot;Sequence[float] | np.ndarray | ConstrainedZonotope | Ellipsoid | Polytope&quot;</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Overload &gt;= operator for containment. self &gt;= Q is equivalent to P.contains(Q).&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">is_polytope</span><span class="p">(</span><span class="n">Q</span><span class="p">)</span> <span class="ow">or</span> <span class="n">is_constrained_zonotope</span><span class="p">(</span><span class="n">Q</span><span class="p">)</span> <span class="ow">or</span> <span class="n">is_ellipsoid</span><span class="p">(</span><span class="n">Q</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">contains</span><span class="p">(</span><span class="n">Q</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">Q_arr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="n">Q</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span>
            <span class="k">except</span> <span class="p">(</span><span class="ne">TypeError</span><span class="p">,</span> <span class="ne">ValueError</span><span class="p">):</span>
                <span class="k">return</span> <span class="bp">NotImplemented</span>
            <span class="k">if</span> <span class="n">Q_arr</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">dim</span> <span class="ow">and</span> <span class="n">Q_arr</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="c1"># Q is a point ====&gt; Polytope &gt;= Point case</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">contains</span><span class="p">(</span><span class="n">Q_arr</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">NotImplemented</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">:</span> <span class="n">Polytope</span><span class="p">,</span> <span class="n">Q</span><span class="p">:</span> <span class="nb">object</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Any</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Overload == operator with equality check. P == Q is equivalent to Q.contains(P) and P.contains(Q)&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span> <span class="o">&lt;=</span> <span class="n">cast</span><span class="p">(</span><span class="s2">&quot;ConstrainedZonotope | Polytope&quot;</span><span class="p">,</span> <span class="n">Q</span><span class="p">)</span> <span class="ow">and</span> <span class="bp">self</span> <span class="o">&gt;=</span> <span class="n">Q</span>

    <span class="fm">__lt__</span> <span class="o">=</span> <span class="fm">__le__</span>
    <span class="fm">__gt__</span> <span class="o">=</span> <span class="fm">__ge__</span>

    <span class="c1">####################</span>
    <span class="c1"># Binary operations</span>
    <span class="c1">####################</span>
    <span class="c1"># Since it is symmetric</span>
    <span class="n">plus</span> <span class="o">=</span> <span class="n">plus</span>
    <span class="fm">__add__</span> <span class="o">=</span> <span class="n">plus</span>
    <span class="fm">__radd__</span> <span class="o">=</span> <span class="n">plus</span>
    <span class="n">minus</span> <span class="o">=</span> <span class="n">minus</span>
    <span class="fm">__sub__</span> <span class="o">=</span> <span class="n">minus</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__rsub__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">Q</span><span class="p">:</span> <span class="n">Any</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Unsupported operation: </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">Q</span><span class="p">)</span><span class="si">}</span><span class="s2"> - Polytope!&quot;</span><span class="p">)</span>

    <span class="n">__array_ufunc__</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># Allows for numpy matrix times Polytope</span>
    <span class="n">affine_map</span> <span class="o">=</span> <span class="n">affine_map</span>
    <span class="n">inverse_affine_map_under_invertible_matrix</span> <span class="o">=</span> <span class="n">inverse_affine_map_under_invertible_matrix</span>

    <span class="c1"># Polytope times Matrix</span>
    <span class="fm">__matmul__</span> <span class="o">=</span> <span class="n">inverse_affine_map_under_invertible_matrix</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__mul__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="n">Any</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Do not allow Polytope * anything&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">NotImplemented</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__neg__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Polytope</span><span class="p">:</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Negation of the polytope :math:`\mathcal{R}=\{-p: p\in\mathcal{ P}\}`.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Polytope: The polytope :math:`\mathcal{R}` that flips the polytope :math:`\mathcal{P}` about origin.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">affine_map</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>

    <span class="c1"># Scalar/Matrix times Polytope (called when left operand does not support multiplication)</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__rmatmul__</span><span class="p">(</span><span class="bp">self</span><span class="p">:</span> <span class="n">Polytope</span><span class="p">,</span> <span class="n">M</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">|</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">Sequence</span><span class="p">[</span><span class="nb">float</span><span class="p">]]</span> <span class="o">|</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Polytope</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Overload @ operator for affine map (matrix times Polytope).&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">affine_map</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">M</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__rmul__</span><span class="p">(</span><span class="bp">self</span><span class="p">:</span> <span class="n">Polytope</span><span class="p">,</span> <span class="n">m</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="nb">float</span> <span class="o">|</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">|</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Polytope</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Overload * operator for multiplication.&quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">m</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">m</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span>
        <span class="k">except</span> <span class="p">(</span><span class="ne">TypeError</span><span class="p">,</span> <span class="ne">ValueError</span><span class="p">)</span> <span class="k">as</span> <span class="n">err</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Unsupported operation: </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">m</span><span class="p">)</span><span class="si">}</span><span class="s2"> * Polytope!&quot;</span><span class="p">)</span> <span class="kn">from</span><span class="w"> </span><span class="nn">err</span>
        <span class="k">return</span> <span class="n">affine_map</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">m</span><span class="p">)</span>

    <span class="n">closest_point</span> <span class="o">=</span> <span class="n">convex_set_closest_point</span>
    <span class="n">distance</span> <span class="o">=</span> <span class="n">convex_set_distance</span>
    <span class="n">extreme</span> <span class="o">=</span> <span class="n">convex_set_extreme</span>
    <span class="n">intersection</span> <span class="o">=</span> <span class="n">intersection</span>
    <span class="n">intersection_with_halfspaces</span> <span class="o">=</span> <span class="n">intersection_with_halfspaces</span>
    <span class="n">intersection_with_affine_set</span> <span class="o">=</span> <span class="n">intersection_with_affine_set</span>
    <span class="n">intersection_under_inverse_affine_map</span> <span class="o">=</span> <span class="n">intersection_under_inverse_affine_map</span>

<div class="viewcode-block" id="Polytope.project">
<a class="viewcode-back" href="../../pycvxset.Polytope.html#pycvxset.Polytope.project">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">project</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">:</span> <span class="n">Polytope</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">|</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">Sequence</span><span class="p">[</span><span class="nb">float</span><span class="p">]]</span> <span class="o">|</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">p</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="nb">str</span> <span class="o">=</span> <span class="mi">2</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]:</span>
        <span class="k">return</span> <span class="n">convex_set_project</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">p</span><span class="o">=</span><span class="n">p</span><span class="p">)</span></div>


    <span class="n">project</span><span class="o">.</span><span class="vm">__doc__</span> <span class="o">=</span> <span class="p">(</span><span class="n">convex_set_project</span><span class="o">.</span><span class="vm">__doc__</span> <span class="ow">or</span> <span class="s2">&quot;&quot;</span><span class="p">)</span> <span class="o">+</span> <span class="n">DOCSTRING_FOR_PROJECT</span>

<div class="viewcode-block" id="Polytope.projection">
<a class="viewcode-back" href="../../pycvxset.Polytope.html#pycvxset.Polytope.projection">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">projection</span><span class="p">(</span><span class="bp">self</span><span class="p">:</span> <span class="n">Polytope</span><span class="p">,</span> <span class="n">project_away_dims</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">|</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Polytope</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">convex_set_projection</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">project_away_dims</span><span class="o">=</span><span class="n">project_away_dims</span><span class="p">)</span></div>


    <span class="n">projection</span><span class="o">.</span><span class="vm">__doc__</span> <span class="o">=</span> <span class="p">(</span><span class="n">convex_set_projection</span><span class="o">.</span><span class="vm">__doc__</span> <span class="ow">or</span> <span class="s2">&quot;&quot;</span><span class="p">)</span> <span class="o">+</span> <span class="n">DOCSTRING_FOR_PROJECTION</span>

<div class="viewcode-block" id="Polytope.slice">
<a class="viewcode-back" href="../../pycvxset.Polytope.html#pycvxset.Polytope.slice">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">slice</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">:</span> <span class="n">Polytope</span><span class="p">,</span> <span class="n">dims</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">|</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">constants</span><span class="p">:</span> <span class="nb">float</span> <span class="o">|</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">|</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Polytope</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">convex_set_slice</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dims</span><span class="p">,</span> <span class="n">constants</span><span class="p">)</span></div>


    <span class="nb">slice</span><span class="o">.</span><span class="vm">__doc__</span> <span class="o">=</span> <span class="p">(</span><span class="n">convex_set_slice</span><span class="o">.</span><span class="vm">__doc__</span> <span class="ow">or</span> <span class="s2">&quot;&quot;</span><span class="p">)</span> <span class="o">+</span> <span class="n">DOCSTRING_FOR_SLICE</span>

<div class="viewcode-block" id="Polytope.slice_then_projection">
<a class="viewcode-back" href="../../pycvxset.Polytope.html#pycvxset.Polytope.slice_then_projection">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">slice_then_projection</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">:</span> <span class="n">Polytope</span><span class="p">,</span> <span class="n">dims</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">|</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">constants</span><span class="p">:</span> <span class="nb">float</span> <span class="o">|</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">|</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Polytope</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">convex_set_slice_then_projection</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dims</span><span class="o">=</span><span class="n">dims</span><span class="p">,</span> <span class="n">constants</span><span class="o">=</span><span class="n">constants</span><span class="p">)</span></div>


    <span class="n">slice_then_projection</span><span class="o">.</span><span class="vm">__doc__</span> <span class="o">=</span> <span class="p">(</span>
        <span class="n">convex_set_slice_then_projection</span><span class="o">.</span><span class="vm">__doc__</span> <span class="ow">or</span> <span class="s2">&quot;&quot;</span>
    <span class="p">)</span> <span class="o">+</span> <span class="n">DOCSTRING_FOR_SLICE_THEN_PROJECTION</span>

<div class="viewcode-block" id="Polytope.support">
<a class="viewcode-back" href="../../pycvxset.Polytope.html#pycvxset.Polytope.support">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">support</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">:</span> <span class="n">Polytope</span><span class="p">,</span> <span class="n">eta</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">|</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">Sequence</span><span class="p">[</span><span class="nb">float</span><span class="p">]]</span> <span class="o">|</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]:</span>
        <span class="k">return</span> <span class="n">convex_set_support</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">eta</span><span class="p">)</span></div>


    <span class="n">support</span><span class="o">.</span><span class="vm">__doc__</span> <span class="o">=</span> <span class="p">(</span><span class="n">convex_set_support</span><span class="o">.</span><span class="vm">__doc__</span> <span class="ow">or</span> <span class="s2">&quot;&quot;</span><span class="p">)</span> <span class="o">+</span> <span class="n">DOCSTRING_FOR_SUPPORT</span>

    <span class="n">_compute_support_function_multiple_eta</span> <span class="o">=</span> <span class="n">_compute_support_function_multiple_eta</span>
    <span class="n">_compute_project_multiple_points</span> <span class="o">=</span> <span class="n">_compute_project_multiple_points</span>

    <span class="c1">###########################</span>
    <span class="c1"># Vertex-halfspace enumeration</span>
    <span class="c1">###########################</span>
    <span class="n">determine_H_rep</span> <span class="o">=</span> <span class="n">determine_H_rep</span>
    <span class="n">determine_V_rep</span> <span class="o">=</span> <span class="n">determine_V_rep</span>
    <span class="n">minimize_H_rep</span> <span class="o">=</span> <span class="n">minimize_H_rep</span>
    <span class="n">minimize_V_rep</span> <span class="o">=</span> <span class="n">minimize_V_rep</span>

    <span class="c1">#########################</span>
    <span class="c1"># Polytope representation</span>
    <span class="c1">#########################</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_empty</span><span class="p">:</span>
            <span class="n">repr_str</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;(empty) in R^</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">dim</span><span class="si">:</span><span class="s2">d</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">in_H_rep</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">in_V_rep</span><span class="p">:</span>
                <span class="n">repr_str</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;in R^</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">dim</span><span class="si">:</span><span class="s2">d</span><span class="si">}</span><span class="s2"> in H-Rep and V-Rep&quot;</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">in_H_rep</span><span class="p">:</span>
                <span class="n">repr_str</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;in R^</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">dim</span><span class="si">:</span><span class="s2">d</span><span class="si">}</span><span class="s2"> in only H-Rep&quot;</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">repr_str</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;in R^</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">dim</span><span class="si">:</span><span class="s2">d</span><span class="si">}</span><span class="s2"> in only V-Rep&quot;</span>
        <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;Polytope </span><span class="si">{</span><span class="n">repr_str</span><span class="si">:</span><span class="s2">s</span><span class="si">}</span><span class="s2">&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="n">repr_str</span> <span class="o">=</span> <span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="p">)]</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">in_H_rep</span><span class="p">:</span>
            <span class="n">inequality_str</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">n_halfspaces</span><span class="si">:</span><span class="s2">d</span><span class="si">}</span><span class="s2"> inequalities&quot;</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_equalities</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">equality_str</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">n_equalities</span><span class="si">:</span><span class="s2">d</span><span class="si">}</span><span class="s2"> equality constraints&quot;</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_equalities</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">equality_str</span> <span class="o">=</span> <span class="s2">&quot;1 equality constraint&quot;</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">equality_str</span> <span class="o">=</span> <span class="s2">&quot;no equality constraints&quot;</span>
            <span class="n">repr_str</span> <span class="o">+=</span> <span class="p">[</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n\t</span><span class="s2">In H-rep: </span><span class="si">{</span><span class="n">inequality_str</span><span class="si">:</span><span class="s2">s</span><span class="si">}</span><span class="s2"> and </span><span class="si">{</span><span class="n">equality_str</span><span class="si">:</span><span class="s2">s</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">]</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">in_V_rep</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_vertices</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">vertex_str</span> <span class="o">=</span> <span class="s2">&quot;vertices&quot;</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">vertex_str</span> <span class="o">=</span> <span class="s2">&quot;vertex&quot;</span>
            <span class="n">repr_str</span> <span class="o">+=</span> <span class="p">[</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n\t</span><span class="s2">In V-rep: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">n_vertices</span><span class="si">:</span><span class="s2">d</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="n">vertex_str</span><span class="si">:</span><span class="s2">s</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">]</span>
        <span class="k">return</span> <span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">repr_str</span><span class="p">)</span></div>

</pre></div>

          </div>
          
        </div>
      </div>
    <div class="clearer"></div>
  </div>
    <div class="footer">
      &#169;2020-2026, Mitsubishi Electric Research Laboratories (MERL).
      
      |
      Powered by <a href="https://www.sphinx-doc.org/">Sphinx 9.1.0</a>
      &amp; <a href="https://alabaster.readthedocs.io">Alabaster 1.0.0</a>
      
    </div>

    

    
  </body>
</html>