<!DOCTYPE html>

<html lang="en" data-content_root="../../">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>pycvxset.common &#8212; pycvxset 1.2.0 documentation</title>
    <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=03e43079" />
    <link rel="stylesheet" type="text/css" href="../../_static/basic.css?v=b08954a9" />
    <link rel="stylesheet" type="text/css" href="../../_static/alabaster.css?v=f6a572b4" />
    <script src="../../_static/documentation_options.js?v=6efca38a"></script>
    <script src="../../_static/doctools.js?v=fd6eb6e6"></script>
    <script src="../../_static/sphinx_highlight.js?v=6ffebe34"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
   
  <link rel="stylesheet" href="../../_static/custom.css" type="text/css" />
  

  
  

  </head><body>
  <div class="document">
    
      <div class="sphinxsidebar" role="navigation" aria-label="Main">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="../../index.html">
              <img class="logo" src="../../_static/pycvxset_logo.png" alt="Logo of pycvxset"/>
            </a></p>
<h1 class="logo"><a href="../../index.html">pycvxset</a></h1>



<p class="blurb">A Python package for manipulation and visualization of convex sets.</p>




<p>
<iframe src="https://ghbtns.com/github-btn.html?user=merlresearch&repo=pycvxset&type=star&count=true&size=large&v=2"
  allowtransparency="true" frameborder="0" scrolling="0" width="200px" height="35px"></iframe>
</p>






<search id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</search>
<script>document.getElementById('searchbox').style.display = "block"</script><!-- Copyright (C) 2020-2026 Mitsubishi Electric Research Laboratories (MERL)

SPDX-License-Identifier: AGPL-3.0-or-later

Code purpose: Custom navigation side bar for documentation website -->

</br>
<h3>Navigation</h3>
<ul>
    <li class="toctree-l1">
        <a class="reference internal" href="../../tutorials/tutorials.html">Tutorials</a>
    </li>
    <li class="toctree-l1" style="color: #444;font-size:120%">Set Representations</li>
    <ul>
        <li class="toctree-l2">
            <a class="reference internal" href="../../api_summary/pycvxset.Polytope.html">Polytope</a>
        </li>
        <li class="toctree-l2">
            <a class="reference internal" href="../../api_summary/pycvxset.Ellipsoid.html">Ellipsoid</a>
        </li>
        <li class="toctree-l2">
            <a class="reference internal"
                href="../../api_summary/pycvxset.ConstrainedZonotope.html">ConstrainedZonotope
            </a>
        </li>
    </ul>
    <li class="toctree-l1"><a class="reference internal" href="../../pycvxset.common.html">Other useful
            methods</a></li>
    <li class="toctree-l1"><a class="reference internal"
            href="../../pycvxset.common.constants.html">Constants</a></li>
    <li class="toctree-l1"><a class="reference external"
            href="https://raw.githubusercontent.com/merlresearch/pycvxset/main/MANUAL.pdf" target="_blank">Manual
            (PDF)</a></li>
    <li class="toctree-l1"><a class="reference external" href="https://www.merl.com/publications/docs/TR2025-086.pdf" target="_blank">Paper (ACC '25)
            </a></li>
    <li class="toctree-l1"><a class="reference internal" href="../../references.html">References</a></li>
</ul>
        </div>
      </div>
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <h1>Source code for pycvxset.common</h1><div class="highlight"><pre>
<span></span><span class="c1"># Copyright (C) 2020-2026 Mitsubishi Electric Research Laboratories (MERL)</span>
<span class="c1"># Copyright (c) 2019 Tor Aksel N. Heirung</span>
<span class="c1">#</span>
<span class="c1"># SPDX-License-Identifier: AGPL-3.0-or-later</span>
<span class="c1"># SPDX-License-Identifier: MIT</span>

<span class="c1"># Code purpose: Describe various constants and methods that are common to different set representations.</span>
<span class="c1"># Coverage: This file has 5 missing statements + 31 excluded statements + 0 partial branches.</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">__future__</span><span class="w"> </span><span class="kn">import</span> <span class="n">annotations</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">warnings</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">typing</span><span class="w"> </span><span class="kn">import</span> <span class="n">TYPE_CHECKING</span><span class="p">,</span> <span class="n">Any</span><span class="p">,</span> <span class="n">Optional</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">,</span> <span class="n">cast</span>

<span class="k">if</span> <span class="n">TYPE_CHECKING</span><span class="p">:</span>
    <span class="kn">from</span><span class="w"> </span><span class="nn">pycvxset.ConstrainedZonotope</span><span class="w"> </span><span class="kn">import</span> <span class="n">ConstrainedZonotope</span>
    <span class="kn">from</span><span class="w"> </span><span class="nn">pycvxset.Ellipsoid</span><span class="w"> </span><span class="kn">import</span> <span class="n">Ellipsoid</span>
    <span class="kn">from</span><span class="w"> </span><span class="nn">pycvxset.Polytope</span><span class="w"> </span><span class="kn">import</span> <span class="n">Polytope</span>
    <span class="kn">import</span><span class="w"> </span><span class="nn">cvxpy</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">itertools</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">os</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">cdd</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">matplotlib.axes</span><span class="w"> </span><span class="kn">import</span> <span class="n">Axes</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">mpl_toolkits.mplot3d.axes3d</span><span class="w"> </span><span class="kn">import</span> <span class="n">Axes3D</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">pycvxset.common.constants</span><span class="w"> </span><span class="kn">import</span> <span class="p">(</span>
    <span class="n">DEFAULT_CVXPY_ARGS_SOCP</span><span class="p">,</span>
    <span class="n">PLOTTING_DECIMAL_PRECISION_CDD</span><span class="p">,</span>
    <span class="n">PYCVXSET_ZERO</span><span class="p">,</span>
    <span class="n">PYCVXSET_ZERO_CDD</span><span class="p">,</span>
    <span class="n">SPOAUS_COST_TOLERANCE</span><span class="p">,</span>
    <span class="n">SPOAUS_DIRECTIONS_PER_QUADRANT</span><span class="p">,</span>
    <span class="n">SPOAUS_INITIAL_TAU</span><span class="p">,</span>
    <span class="n">SPOAUS_ITERATIONS_AT_TAU_MAX</span><span class="p">,</span>
    <span class="n">SPOAUS_MINIMUM_NORM_VALUE_SQR</span><span class="p">,</span>
    <span class="n">SPOAUS_SAVE_POINTS_ON_A_UNIT_SPHERE</span><span class="p">,</span>
    <span class="n">SPOAUS_SCALING_TAU</span><span class="p">,</span>
    <span class="n">SPOAUS_SLACK_TOLERANCE</span><span class="p">,</span>
    <span class="n">SPOAUS_TAU_MAX</span><span class="p">,</span>
<span class="p">)</span>

<span class="n">DOCSTRING_FOR_PROJECT</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>


<div class="viewcode-block" id="approximate_volume_from_grid">
<a class="viewcode-back" href="../../pycvxset.common.html#pycvxset.common.approximate_volume_from_grid">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">approximate_volume_from_grid</span><span class="p">(</span>
    <span class="n">cvx_set</span><span class="p">:</span> <span class="s2">&quot;ConstrainedZonotope | Ellipsoid | Polytope&quot;</span><span class="p">,</span> <span class="n">area_grid_step_size</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="nb">float</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Estimate area of a two-dimensional set using a grid of given step size</span>

<span class="sd">    Args:</span>
<span class="sd">        cvx_set (ConstrainedZonotope | Ellipsoid | Polytope): Set for which area is to be computed</span>
<span class="sd">        area_grid_step_size (int | float): Scalar step size that is constant in both dimensions</span>

<span class="sd">    Raises:</span>
<span class="sd">        ValueError: When set is not 2-dimensional</span>

<span class="sd">    Returns:</span>
<span class="sd">        float: Approximate area of the set</span>

<span class="sd">    Notes:</span>
<span class="sd">        This function creates a 2D grid of points with a given step size, and computes the fraction of points that lie</span>
<span class="sd">        in the set. Consequently, the computed area is an approximation of the actual area of the set. The area of the</span>
<span class="sd">        bounding box is computed using the :meth:`minimum_volume_circumscribing_rectangle` method associated with the</span>
<span class="sd">        set.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">cvx_set</span><span class="o">.</span><span class="n">dim</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Expected 2-dimensional set&quot;</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">cvx_set</span><span class="o">.</span><span class="n">is_empty</span><span class="p">:</span>
        <span class="k">return</span> <span class="mf">0.0</span>
    <span class="k">elif</span> <span class="n">area_grid_step_size</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Expected area_grid_step_size to be a positive float!&quot;</span><span class="p">)</span>

    <span class="n">lb</span><span class="p">,</span> <span class="n">ub</span> <span class="o">=</span> <span class="n">cvx_set</span><span class="o">.</span><span class="n">minimum_volume_circumscribing_rectangle</span><span class="p">()</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">lb</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">()</span> <span class="ow">and</span> <span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">ub</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">()):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Expected the set to be bounded for approximate_volume_from_grid!&quot;</span><span class="p">)</span>
    <span class="k">elif</span> <span class="p">(</span><span class="n">lb</span> <span class="o">&gt;</span> <span class="n">ub</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">()</span> <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">ub</span> <span class="o">-</span> <span class="n">lb</span><span class="p">))</span> <span class="o">&lt;=</span> <span class="n">PYCVXSET_ZERO</span><span class="p">:</span>
        <span class="k">return</span> <span class="mf">0.0</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">area_of_bounding_box</span> <span class="o">=</span> <span class="p">(</span><span class="n">ub</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">lb</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">*</span> <span class="p">(</span><span class="n">ub</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">lb</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">corrected_lb</span> <span class="o">=</span> <span class="n">lb</span> <span class="o">+</span> <span class="n">area_grid_step_size</span> <span class="o">/</span> <span class="mi">2</span>
        <span class="n">corrected_ub</span> <span class="o">=</span> <span class="n">ub</span> <span class="o">-</span> <span class="n">area_grid_step_size</span> <span class="o">/</span> <span class="mi">2</span>
        <span class="n">x1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">corrected_lb</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">corrected_ub</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">area_grid_step_size</span><span class="p">,</span> <span class="n">area_grid_step_size</span><span class="p">)</span>
        <span class="n">x2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">corrected_lb</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">corrected_ub</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">area_grid_step_size</span><span class="p">,</span> <span class="n">area_grid_step_size</span><span class="p">)</span>
        <span class="n">X1</span><span class="p">,</span> <span class="n">X2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">)</span>
        <span class="n">n_area_boxes</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">x1</span><span class="p">)</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">x2</span><span class="p">)</span>
        <span class="n">points_to_test</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">X1</span><span class="o">.</span><span class="n">flatten</span><span class="p">(),</span> <span class="n">X2</span><span class="o">.</span><span class="n">flatten</span><span class="p">()))</span><span class="o">.</span><span class="n">T</span>
        <span class="n">containment_flag</span> <span class="o">=</span> <span class="n">cvx_set</span><span class="o">.</span><span class="n">contains</span><span class="p">(</span><span class="n">points_to_test</span><span class="p">)</span>
        <span class="n">set_area</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">count_nonzero</span><span class="p">(</span><span class="n">containment_flag</span><span class="p">)</span> <span class="o">/</span> <span class="n">n_area_boxes</span> <span class="o">*</span> <span class="n">area_of_bounding_box</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">set_area</span></div>



<span class="k">def</span><span class="w"> </span><span class="nf">check_matrices_are_equal_ignoring_row_order</span><span class="p">(</span>
    <span class="n">A</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">Sequence</span><span class="p">[</span><span class="nb">float</span><span class="p">]]</span> <span class="o">|</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">B</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">Sequence</span><span class="p">[</span><span class="nb">float</span><span class="p">]]</span> <span class="o">|</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Check matrices are equal while ignoring row order</span>

<span class="sd">    Args:</span>
<span class="sd">        A (Sequence[Sequence[float]] | np.ndarray): Matrix 1</span>
<span class="sd">        B (Sequence[Sequence[float]] | np.ndarray): Matrix 2</span>

<span class="sd">    Returns:</span>
<span class="sd">        bool: A == B</span>

<span class="sd">    Notes:</span>
<span class="sd">        isclose does element-wise comparison, all with axis=1, provides a row-wise test, and finally any checks for some</span>
<span class="sd">        row where row-wise match is true</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">A_arr</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
    <span class="n">B_arr</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">B</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
    <span class="k">return</span> <span class="p">(</span>
        <span class="n">A_arr</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="n">B_arr</span><span class="o">.</span><span class="n">shape</span>
        <span class="ow">and</span> <span class="nb">sum</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isclose</span><span class="p">(</span><span class="n">row</span><span class="p">,</span> <span class="n">B_arr</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span> <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">A_arr</span><span class="p">])</span> <span class="o">==</span> <span class="n">B_arr</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="p">)</span>


<span class="k">def</span><span class="w"> </span><span class="nf">check_vectors_are_equal_ignoring_row_order</span><span class="p">(</span>
    <span class="n">A</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">|</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">B</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">|</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Check vectors are equal while ignoring row order</span>

<span class="sd">    Args:</span>
<span class="sd">        A (Sequence[float] | np.ndarray): Vector 1</span>
<span class="sd">        B (Sequence[float] | np.ndarray): Vector 2</span>

<span class="sd">    Returns:</span>
<span class="sd">        bool: A == B</span>

<span class="sd">    Notes:</span>
<span class="sd">        isclose does element-wise comparison and we sort</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">A_arr</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">A</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span>
    <span class="n">B_arr</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">B</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">cast</span><span class="p">(</span>
        <span class="nb">bool</span><span class="p">,</span>
        <span class="n">A_arr</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">A_arr</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="n">B_arr</span><span class="o">.</span><span class="n">shape</span> <span class="ow">and</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isclose</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">A_arr</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">B_arr</span><span class="p">))),</span>
    <span class="p">)</span>


<span class="k">def</span><span class="w"> </span><span class="nf">convex_set_closest_point</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="s2">&quot;ConstrainedZonotope | Ellipsoid | Polytope&quot;</span><span class="p">,</span> <span class="n">points</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">Sequence</span><span class="p">[</span><span class="nb">float</span><span class="p">]]</span> <span class="o">|</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">p</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="nb">str</span> <span class="o">=</span> <span class="mi">2</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Wrapper for :meth:`project` to compute the point in the convex set closest to the given point.</span>

<span class="sd">    Args:</span>
<span class="sd">        points (Sequence[Sequence[float]] | np.ndarray): Points to project. Matrix (N times self.dim), where each row</span>
<span class="sd">            is a point.</span>
<span class="sd">        p (str | int): Norm-type. It can be 1, 2, or &#39;inf&#39;. Defaults to 2.</span>

<span class="sd">    Returns:</span>
<span class="sd">        numpy.ndarray: Projection of points to the set as a 2D numpy.ndarray. These arrays have as many rows as points.</span>

<span class="sd">    Notes:</span>
<span class="sd">        For more detailed description, see documentation for :meth:`project` function.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">project</span><span class="p">(</span><span class="n">points</span><span class="p">,</span> <span class="n">p</span><span class="o">=</span><span class="n">p</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>


<span class="k">def</span><span class="w"> </span><span class="nf">convex_set_contains_points</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="s2">&quot;ConstrainedZonotope | Ellipsoid | Polytope&quot;</span><span class="p">,</span> <span class="n">points</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">Sequence</span><span class="p">[</span><span class="nb">float</span><span class="p">]]</span> <span class="o">|</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span> <span class="o">|</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Wrapper for :meth:`distance` to compute containment from a given collection of points.</span>

<span class="sd">    Args:</span>
<span class="sd">        points (Sequence[Sequence[float]] | np.ndarray): Points to project (N times self.dim) with each row as a point.</span>

<span class="sd">    Returns:</span>
<span class="sd">        bool | numpy.ndarray[bool]: Logical array of containment of points in the set.</span>

<span class="sd">    Notes:</span>
<span class="sd">        For more detailed description, see documentation for :meth:`distance` function.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">points_arr</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="n">points</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span>
    <span class="n">n_points</span><span class="p">,</span> <span class="n">point_dim</span> <span class="o">=</span> <span class="n">points_arr</span><span class="o">.</span><span class="n">shape</span>
    <span class="k">if</span> <span class="n">point_dim</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dim</span><span class="p">:</span>
        <span class="c1"># Could transpose here if test_points.shape[1] == self.dim, but better to</span>
        <span class="c1"># specify that points must be columns:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Mismatch in dimensions (self.dim: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">dim</span><span class="si">:</span><span class="s2">d</span><span class="si">}</span><span class="s2"> and test_points.dim: </span><span class="si">{</span><span class="n">point_dim</span><span class="si">:</span><span class="s2">d</span><span class="si">}</span><span class="s2">)&quot;</span><span class="p">)</span>
    <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_empty</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">n_points</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n_points</span><span class="p">,),</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;bool&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">distance_to_test_points</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">distance</span><span class="p">(</span><span class="n">points_arr</span><span class="p">,</span> <span class="n">p</span><span class="o">=</span><span class="s2">&quot;inf&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">n_points</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">distance_to_test_points</span> <span class="o">&lt;=</span> <span class="n">PYCVXSET_ZERO</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">bool</span><span class="p">(</span><span class="n">distance_to_test_points</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">PYCVXSET_ZERO</span><span class="p">)</span>


<span class="k">def</span><span class="w"> </span><span class="nf">convex_set_distance</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="s2">&quot;ConstrainedZonotope | Ellipsoid | Polytope&quot;</span><span class="p">,</span> <span class="n">points</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">Sequence</span><span class="p">[</span><span class="nb">float</span><span class="p">]]</span> <span class="o">|</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">p</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="nb">str</span> <span class="o">=</span> <span class="mi">2</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Wrapper for :meth:`project` to compute distance of a point to a convex set.</span>

<span class="sd">    Args:</span>
<span class="sd">        points (Sequence[Sequence[float]] | np.ndarray): Points to project. Matrix (N times self.dim), where each row</span>
<span class="sd">            is a point.</span>
<span class="sd">        p (int | str): Norm-type. It can be 1, 2, or &#39;inf&#39;. Defaults to 2.</span>

<span class="sd">    Returns:</span>
<span class="sd">        numpy.ndarray: Distance of points to the set as a 1D numpy.ndarray. These arrays have as many rows as points.</span>

<span class="sd">    Notes:</span>
<span class="sd">        For more detailed description, see documentation for :meth:`project` function.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">project</span><span class="p">(</span><span class="n">points</span><span class="p">,</span> <span class="n">p</span><span class="o">=</span><span class="n">p</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span>


<span class="k">def</span><span class="w"> </span><span class="nf">convex_set_extreme</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="s2">&quot;ConstrainedZonotope | Ellipsoid | Polytope&quot;</span><span class="p">,</span> <span class="n">eta</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">Sequence</span><span class="p">[</span><span class="nb">float</span><span class="p">]]</span> <span class="o">|</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Wrapper for :meth:`support` to compute the extreme point.</span>

<span class="sd">    Args:</span>
<span class="sd">        eta (Sequence[Sequence[float]] | np.ndarray): Support directions. Matrix (N times self.dim), where each row is</span>
<span class="sd">            a support direction.</span>

<span class="sd">    Returns:</span>
<span class="sd">        numpy.ndarray: Support vector evaluation(s) as a 2D numpy.ndarray. The array has as many rows as eta.</span>

<span class="sd">    Notes:</span>
<span class="sd">        For more detailed description, see documentation for :meth:`support` function.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">support</span><span class="p">(</span><span class="n">eta</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span>


<span class="k">def</span><span class="w"> </span><span class="nf">convex_set_minimum_volume_circumscribing_rectangle</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="s2">&quot;ConstrainedZonotope | Ellipsoid | Polytope&quot;</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]:</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Compute the minimum volume circumscribing rectangle for a set.</span>

<span class="sd">    Raises:</span>
<span class="sd">        ValueError: Solver error or set is empty!</span>

<span class="sd">    Returns:</span>
<span class="sd">        tuple: A tuple of two elements</span>
<span class="sd">            - lb (numpy.ndarray): Lower bound :math:`l` on the set,</span>
<span class="sd">              :math:`\mathcal{P}\subseteq\{l\}\oplus\mathbb{R}_{\geq 0}`.</span>
<span class="sd">            - ub (numpy.ndarray): Upper bound :math:`u` on the set,</span>
<span class="sd">              :math:`\mathcal{P}\subseteq\{u\}\oplus(-\mathbb{R}_{\geq 0})`.</span>

<span class="sd">    Notes:</span>
<span class="sd">        This function computes the lower/upper bound by an element-wise support computation (2n linear programs), where</span>
<span class="sd">        n is attr:`self.dim`. To reuse the :meth:`support` function for the lower bound computation, we solve the</span>
<span class="sd">        optimization for each :math:`i\in\{1,2,...,n\}`,</span>

<span class="sd">        .. math::</span>
<span class="sd">            \inf_{x\in\mathcal{P}} e_i^\top x=-\sup_{x\in\mathcal{P}} -e_i^\top x=-\rho_{\mathcal{P}}(-e_i),</span>

<span class="sd">        where :math:`e_i\in\mathbb{R}^n` denotes the standard coordinate vector, and :math:`\rho_{\mathcal{P}}` is the</span>
<span class="sd">        support function of :math:`\mathcal{P}`.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">lb</span> <span class="o">=</span> <span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">support</span><span class="p">(</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dim</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">ub</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">support</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dim</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">except</span> <span class="ne">ValueError</span> <span class="k">as</span> <span class="n">err</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Can not compute minimum_volume_circumscribing_rectangle. Is set empty?&quot;</span><span class="p">)</span> <span class="kn">from</span><span class="w"> </span><span class="nn">err</span>
    <span class="k">except</span> <span class="ne">NotImplementedError</span> <span class="k">as</span> <span class="n">err</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Computation of minimum_volume_circumscribing_rectangle failed!&quot;</span><span class="p">)</span> <span class="kn">from</span><span class="w"> </span><span class="nn">err</span>
    <span class="k">return</span> <span class="n">lb</span><span class="p">,</span> <span class="n">ub</span>


<span class="k">def</span><span class="w"> </span><span class="nf">convex_set_project</span><span class="p">(</span>
    <span class="n">cvx_set</span><span class="p">:</span> <span class="s2">&quot;ConstrainedZonotope | Ellipsoid | Polytope&quot;</span><span class="p">,</span>
    <span class="n">points</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">Sequence</span><span class="p">[</span><span class="nb">float</span><span class="p">]]</span> <span class="o">|</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
    <span class="n">p</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="nb">str</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]:</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Project a point or a collection of points on to a set.</span>

<span class="sd">    Given a set :math:`\mathcal{P}` and a test point :math:`y\in\mathbb{R}^{\mathcal{P}.\text{dim}}`, this function</span>
<span class="sd">    solves a convex program,</span>

<span class="sd">        .. math::</span>
<span class="sd">            \text{minimize}    &amp;\quad  \|x - y\|_p\\</span>
<span class="sd">            \text{subject to}  &amp;\quad  x \in \mathcal{P}\\</span>

<span class="sd">    Args:</span>
<span class="sd">        points (Sequence[Sequence[float]] | np.ndarray): Points to project (N times self.dim) with each row as a point.</span>
<span class="sd">        p (str | int): Norm-type. It can be 1, 2, or &#39;inf&#39;. Defaults to 2, which is the Euclidean norm.</span>

<span class="sd">    Raises:</span>
<span class="sd">        ValueError: Set is empty</span>
<span class="sd">        ValueError: Dimension mismatch --- no. of columns in points is different from self.dim.</span>
<span class="sd">        ValueError: Points is not convertible into a 2D array</span>
<span class="sd">        NotImplementedError: Unable to solve problem using CVXPY</span>

<span class="sd">    Returns:</span>
<span class="sd">        tuple: A tuple with two items:</span>
<span class="sd">            1. projected_point (numpy.ndarray): Projection point(s) as a 2D numpy.ndarray. Matrix (N times self.dim),</span>
<span class="sd">               where each row is a projection of the point in points to the set :math:`\mathcal{P}`.</span>
<span class="sd">            2. distance (numpy.ndarray): Distance(s) as a 1D numpy.ndarray. Vector (N,), where each row is a projection</span>
<span class="sd">               of the point in points to the set :math:`\mathcal{P}`.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">cvx_set</span><span class="o">.</span><span class="n">is_empty</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Set must be non-empty for project.&quot;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">points_arr</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="n">points</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">points_arr</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Expected points to be a 1D/2D numpy array&quot;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">points_arr</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="n">cvx_set</span><span class="o">.</span><span class="n">dim</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;points dim. (</span><span class="si">{</span><span class="n">points_arr</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="si">:</span><span class="s2">d</span><span class="si">}</span><span class="s2">), no. of columns, is different from set dim. (</span><span class="si">{</span><span class="n">cvx_set</span><span class="o">.</span><span class="n">dim</span><span class="si">:</span><span class="s2">d</span><span class="si">}</span><span class="s2">)&quot;</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>  <span class="c1"># points.ndim == 2</span>
            <span class="k">return</span> <span class="n">cvx_set</span><span class="o">.</span><span class="n">_compute_project_multiple_points</span><span class="p">(</span><span class="n">points_arr</span><span class="p">,</span> <span class="n">p</span><span class="p">)</span>


<span class="k">def</span><span class="w"> </span><span class="nf">convex_set_projection</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="s2">&quot;ConstrainedZonotope | Ellipsoid | Polytope&quot;</span><span class="p">,</span> <span class="n">project_away_dims</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">|</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Any</span><span class="p">:</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Orthogonal projection of a set :math:`\mathcal{P}` after removing some user-specified dimensions.</span>

<span class="sd">    .. math::</span>
<span class="sd">        \mathcal{R} = \{r \in \mathbb{R}^{m}\ |\  \exists v \in \mathbb{R}^{n - m},\ \text{Lift}(r,v)\in \mathcal{P}\}</span>

<span class="sd">    Here, :math:`m = \mathcal{P}.\text{dim} - \text{length}(\text{project\_away\_dim})`, and</span>
<span class="sd">    :math:`\text{Lift}(r,v)` lifts (&quot;undo&quot;s the projection) using the appropriate components of `v`. This function uses</span>
<span class="sd">    :meth:`affine_map` to implement the projection by designing an appropriate affine map :math:`M \in</span>
<span class="sd">    \{0,1\}^{m\times\mathcal{P}.\text{dim}}` with each row of :math:`M` corresponding to some standard axis vector</span>
<span class="sd">    :math:`e_i\in\mathbb{R}^m`.</span>

<span class="sd">    Args:</span>
<span class="sd">        project_away_dims (Sequence[int] | np.ndarray): Dimensions to projected away in integer interval</span>
<span class="sd">            [0, 1, ..., n - 1].</span>

<span class="sd">    Raises:</span>
<span class="sd">        ValueError: When project_away_dims are not in the integer interval | All dimensions are projected away</span>

<span class="sd">    Returns:</span>
<span class="sd">        object: Set obtained via projection.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">project_away_dims_arr</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">project_away_dims</span><span class="p">))</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">project_away_dims_arr</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">project_away_dims_arr</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">project_away_dims_arr</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dim</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Expected project_away_dims to be in the integer interval [0:</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">dim</span><span class="o">-</span><span class="mi">1</span><span class="si">:</span><span class="s2">d</span><span class="si">}</span><span class="s2">]!&quot;</span>
                <span class="sa">f</span><span class="s2">&quot;Got </span><span class="si">{</span><span class="n">np</span><span class="o">.</span><span class="n">array2string</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">project_away_dims_arr</span><span class="p">))</span><span class="si">:</span><span class="s2">s</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>
        <span class="n">project_away_dims_list</span> <span class="o">=</span> <span class="n">project_away_dims_arr</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
        <span class="n">corrected_retain_dimensions</span> <span class="o">=</span> <span class="p">[</span><span class="n">d</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dim</span><span class="p">)</span> <span class="k">if</span> <span class="n">d</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">project_away_dims_list</span><span class="p">]</span>
        <span class="n">n_dimensions_to_retain</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">corrected_retain_dimensions</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">n_dimensions_to_retain</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Can not project away all dimensions!&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Perform the projection using projection_matrix @ V</span>
            <span class="n">projection_matrix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n_dimensions_to_retain</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dim</span><span class="p">))</span>
            <span class="k">for</span> <span class="n">row_index</span><span class="p">,</span> <span class="n">d</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">corrected_retain_dimensions</span><span class="p">):</span>
                <span class="n">projection_matrix</span><span class="p">[</span><span class="n">row_index</span><span class="p">,</span> <span class="n">d</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="k">return</span> <span class="n">projection_matrix</span> <span class="o">@</span> <span class="bp">self</span>


<span class="k">def</span><span class="w"> </span><span class="nf">convex_set_support</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="s2">&quot;ConstrainedZonotope | Polytope&quot;</span><span class="p">,</span> <span class="n">eta</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">|</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">Sequence</span><span class="p">[</span><span class="nb">float</span><span class="p">]]</span> <span class="o">|</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]:</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Evaluates the support function and support vector of a set.</span>

<span class="sd">    The support function of a set :math:`\mathcal{P}` is defined as :math:`\rho_{\mathcal{P}}(\eta) =</span>
<span class="sd">    \max_{x\in\mathcal{P}} \eta^\top x`. The support vector of a set :math:`\mathcal{P}` is defined as</span>
<span class="sd">    :math:`\nu_{\mathcal{P}}(\eta) = \arg\max_{x\in\mathcal{P}} \eta^\top x`.</span>

<span class="sd">    Args:</span>
<span class="sd">        eta (Sequence[float] | Sequence[Sequence[float]] | np.ndarray): Support directions. Matrix (N times self.dim),</span>
<span class="sd">            where each row is a support direction.</span>

<span class="sd">    Raises:</span>
<span class="sd">        ValueError: Set is empty</span>
<span class="sd">        ValueError: Mismatch in eta dimension</span>
<span class="sd">        ValueError: eta is not convertible into a 2D array</span>
<span class="sd">        NotImplementedError: Unable to solve problem using CVXPY</span>

<span class="sd">    Returns:</span>
<span class="sd">        tuple: A tuple with two items:</span>
<span class="sd">            1. support_function_evaluations (numpy.ndarray): Support function evaluation(s) as a 2D numpy.ndarray.</span>
<span class="sd">               Vector (N,) with as many rows as eta.</span>
<span class="sd">            2. support_vectors (numpy.ndarray): Support vectors as a 2D numpy.ndarray. Matrix N x self.dim with as many</span>
<span class="sd">               rows as eta.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">eta_arr</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="n">eta</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">eta_arr</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Expected eta to be a 1D/2D numpy array&quot;</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">eta_arr</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dim</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;eta dim. (</span><span class="si">{</span><span class="n">eta_arr</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="si">:</span><span class="s2">d</span><span class="si">}</span><span class="s2">), no. of columns, is different from set dimension (</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">dim</span><span class="si">:</span><span class="s2">d</span><span class="si">}</span><span class="s2">)&quot;</span>
        <span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>  <span class="c1"># eta.ndim == 2:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_compute_support_function_multiple_eta</span><span class="p">(</span><span class="n">eta_arr</span><span class="p">)</span>


<span class="k">def</span><span class="w"> </span><span class="nf">convex_set_slice</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="s2">&quot;ConstrainedZonotope | Ellipsoid | Polytope&quot;</span><span class="p">,</span>
    <span class="n">dims</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">|</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
    <span class="n">constants</span><span class="p">:</span> <span class="nb">float</span> <span class="o">|</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">|</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Any</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Slice a set restricting certain dimensions to constants.</span>

<span class="sd">    This function uses :meth:`intersection_with_affine_set` to implement the slicing by designing an appropriate affine</span>
<span class="sd">    set from dims and constants.</span>

<span class="sd">    Args:</span>
<span class="sd">        dims (Sequence[int] | np.ndarray): List of dims to restrict to a constant in the integer interval</span>
<span class="sd">            [0, 1, ..., n - 1].</span>
<span class="sd">        constants (float | Sequence[float] | np.ndarray): List of constants</span>

<span class="sd">    Raises:</span>
<span class="sd">        ValueError: dims has entries beyond n</span>
<span class="sd">        ValueError: dims and constants are not 1D arrays of same size</span>

<span class="sd">    Returns:</span>
<span class="sd">        object: Sliced set.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">dims_arr_raw</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">dims</span><span class="p">))</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">issubdtype</span><span class="p">(</span><span class="n">dims_arr_raw</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">integer</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Expected dims to be finite integers.&quot;</span><span class="p">)</span>
    <span class="n">dims_arr</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">dims_arr_raw</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
    <span class="n">constants_arr</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">(</span><span class="n">constants</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">dims_arr</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="mi">1</span> <span class="ow">or</span> <span class="n">constants_arr</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="n">dims_arr</span><span class="o">.</span><span class="n">shape</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Expected dims and constants to be 1D sequences or numpy arrays of same shape.&quot;</span><span class="p">)</span>
    <span class="n">Ae</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">dims_arr</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">dim</span><span class="p">))</span>
    <span class="n">be</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">dims_arr</span><span class="p">),))</span>
    <span class="k">for</span> <span class="n">index</span><span class="p">,</span> <span class="p">(</span><span class="n">dim</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">dims_arr</span><span class="p">,</span> <span class="n">constants_arr</span><span class="p">)):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">Ae</span><span class="p">[</span><span class="n">index</span><span class="p">,</span> <span class="n">dim</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">except</span> <span class="ne">IndexError</span> <span class="k">as</span> <span class="n">err</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;dims has an entry </span><span class="si">{</span><span class="n">dim</span><span class="si">}</span><span class="s2"> that is not in the integer interval [1:</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">dim</span><span class="si">:</span><span class="s2">d</span><span class="si">}</span><span class="s2">]&quot;</span><span class="p">)</span> <span class="kn">from</span><span class="w"> </span><span class="nn">err</span>
        <span class="n">be</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">intersection_with_affine_set</span><span class="p">(</span><span class="n">Ae</span><span class="p">,</span> <span class="n">be</span><span class="p">)</span>


<span class="k">def</span><span class="w"> </span><span class="nf">convex_set_slice_then_projection</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="s2">&quot;ConstrainedZonotope | Ellipsoid | Polytope&quot;</span><span class="p">,</span>
    <span class="n">dims</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">|</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
    <span class="n">constants</span><span class="p">:</span> <span class="nb">float</span> <span class="o">|</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">|</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Any</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Wrapper for :meth:`slice` and :meth:`projection`.</span>

<span class="sd">    The function first restricts a set at certain dimensions to constants, and then projects away those dimensions.</span>
<span class="sd">    Useful for visual inspection of higher dimensional sets.</span>

<span class="sd">    Args:</span>
<span class="sd">        dims (Sequence[int] | np.ndarray): List of dims to restrict to a constant in the integer interval</span>
<span class="sd">            [0, 1, ..., dim - 1], and then project away.</span>
<span class="sd">        constants (float | Sequence[float] | np.ndarray): List of constants</span>

<span class="sd">    Raises:</span>
<span class="sd">        ValueError: dims has entries beyond n</span>
<span class="sd">        ValueError: dims and constants are not 1D arrays of same size</span>
<span class="sd">        ValueError: When dims are not in the integer interval | All dimensions are projected away</span>

<span class="sd">    Returns:</span>
<span class="sd">        object: Sliced then projected set.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">slice</span><span class="p">(</span><span class="n">dims</span><span class="o">=</span><span class="n">dims</span><span class="p">,</span> <span class="n">constants</span><span class="o">=</span><span class="n">constants</span><span class="p">)</span><span class="o">.</span><span class="n">projection</span><span class="p">(</span><span class="n">project_away_dims</span><span class="o">=</span><span class="n">dims</span><span class="p">)</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_compute_project_multiple_points</span><span class="p">(</span>  <span class="c1"># pyright: ignore[reportUnusedFunction]</span>
    <span class="bp">self</span><span class="p">:</span> <span class="s2">&quot;ConstrainedZonotope | Ellipsoid | Polytope&quot;</span><span class="p">,</span> <span class="n">points</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">Sequence</span><span class="p">[</span><span class="nb">float</span><span class="p">]]</span> <span class="o">|</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">p</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="nb">str</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="nb">float</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Private function to project a point on to a set with distance characterized an appropriate p-norm. This function</span>
<span class="sd">    is not to be called directly. Instead, call `project` method.&quot;&quot;&quot;</span>
    <span class="kn">import</span><span class="w"> </span><span class="nn">cvxpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">cp</span>

    <span class="k">if</span> <span class="n">p</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span> <span class="ow">and</span> <span class="nb">str</span><span class="p">(</span><span class="n">p</span><span class="p">)</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">!=</span> <span class="s2">&quot;inf&quot;</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Unhandled p norm: </span><span class="si">{</span><span class="n">p</span><span class="si">}</span><span class="s2">!&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">p</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
        <span class="n">cvxpy_args</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cvxpy_args_socp</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">cvxpy_args</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cvxpy_args_lp</span>

    <span class="n">points_arr</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">points</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
    <span class="n">projected_points_on_the_polytope</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="n">points_arr</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">dim</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
    <span class="n">projection_distances</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="n">points_arr</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
    <span class="n">point</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">Parameter</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">dim</span><span class="p">,))</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">Variable</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">dim</span><span class="p">,))</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">containment_constraints</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">containment_constraints</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">ValueError</span> <span class="k">as</span> <span class="n">err</span><span class="p">:</span>  <span class="c1"># pragma: no cover</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Can not compute project points on to an empty set!&quot;</span><span class="p">)</span> <span class="kn">from</span><span class="w"> </span><span class="nn">err</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">problem</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">Problem</span><span class="p">(</span><span class="n">cp</span><span class="o">.</span><span class="n">Minimize</span><span class="p">(</span><span class="n">cast</span><span class="p">(</span><span class="n">cp</span><span class="o">.</span><span class="n">Expression</span><span class="p">,</span> <span class="n">cp</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">point</span> <span class="o">-</span> <span class="n">x</span><span class="p">,</span> <span class="n">p</span><span class="o">=</span><span class="n">p</span><span class="p">))),</span> <span class="n">containment_constraints</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">index</span><span class="p">,</span> <span class="n">point_row</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">points_arr</span><span class="p">):</span>
            <span class="n">point</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="n">point_row</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">problem</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="o">**</span><span class="n">cvxpy_args</span><span class="p">)</span>
            <span class="k">except</span> <span class="n">cp</span><span class="o">.</span><span class="n">error</span><span class="o">.</span><span class="n">SolverError</span> <span class="k">as</span> <span class="n">err</span><span class="p">:</span>  <span class="c1"># pyright: ignore[reportAttributeAccessIssue]</span>
                <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;Unable to project the point </span><span class="si">{</span><span class="n">np</span><span class="o">.</span><span class="n">array2string</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">point_row</span><span class="p">))</span><span class="si">:</span><span class="s2">s</span><span class="si">}</span><span class="s2"> to the set. &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;CVXPY returned error: </span><span class="si">{</span><span class="nb">str</span><span class="p">(</span><span class="n">err</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="p">)</span> <span class="kn">from</span><span class="w"> </span><span class="nn">err</span>
            <span class="k">if</span> <span class="n">problem</span><span class="o">.</span><span class="n">status</span> <span class="ow">in</span> <span class="p">[</span><span class="n">cp</span><span class="o">.</span><span class="n">OPTIMAL</span><span class="p">,</span> <span class="n">cp</span><span class="o">.</span><span class="n">OPTIMAL_INACCURATE</span><span class="p">]:</span>
                <span class="n">projected_points_on_the_polytope</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">value</span>  <span class="c1"># type: ignore[assignment]</span>
                <span class="n">projection_distances</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="n">problem</span><span class="o">.</span><span class="n">value</span>  <span class="c1"># type: ignore[assignment]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;Unable to project the point </span><span class="si">{</span><span class="n">np</span><span class="o">.</span><span class="n">array2string</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">point_row</span><span class="p">))</span><span class="si">:</span><span class="s2">s</span><span class="si">}</span><span class="s2"> to the set. &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;CVXPY returned an unhandled status: </span><span class="si">{</span><span class="n">problem</span><span class="o">.</span><span class="n">status</span><span class="si">:</span><span class="s2">s</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="p">)</span>
    <span class="k">return</span> <span class="n">projected_points_on_the_polytope</span><span class="p">,</span> <span class="n">projection_distances</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_compute_support_function_multiple_eta</span><span class="p">(</span>  <span class="c1"># pyright: ignore[reportUnusedFunction]</span>
    <span class="bp">self</span><span class="p">:</span> <span class="s2">&quot;ConstrainedZonotope | Polytope&quot;</span><span class="p">,</span> <span class="n">eta</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">|</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Private function to compute the support function of a set along the support direction eta. Instead, call</span>
<span class="sd">    `support` method. Relies on the solver to detect unbounded/empty sets.&quot;&quot;&quot;</span>
    <span class="kn">import</span><span class="w"> </span><span class="nn">cvxpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">cp</span>

    <span class="n">eta_arr</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">eta</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
    <span class="n">support_vector</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="n">eta_arr</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">dim</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
    <span class="n">support_value</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="n">eta_arr</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
    <span class="n">eta</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">Parameter</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">dim</span><span class="p">,))</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">Variable</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">dim</span><span class="p">,))</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">containment_constraints</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">containment_constraints</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">ValueError</span> <span class="k">as</span> <span class="n">err</span><span class="p">:</span>  <span class="c1"># pragma: no cover</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Can not compute support function for an empty set!&quot;</span><span class="p">)</span> <span class="kn">from</span><span class="w"> </span><span class="nn">err</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">problem</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">Problem</span><span class="p">(</span><span class="n">cp</span><span class="o">.</span><span class="n">Maximize</span><span class="p">(</span><span class="n">eta</span> <span class="o">@</span> <span class="n">x</span><span class="p">),</span> <span class="n">containment_constraints</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">index</span><span class="p">,</span> <span class="n">eta_row</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">eta_arr</span><span class="p">):</span>
            <span class="n">eta</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="n">eta_row</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">problem</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">cvxpy_args_lp</span><span class="p">)</span>
            <span class="k">except</span> <span class="n">cp</span><span class="o">.</span><span class="n">error</span><span class="o">.</span><span class="n">SolverError</span> <span class="k">as</span> <span class="n">err</span><span class="p">:</span>  <span class="c1"># pyright: ignore[reportAttributeAccessIssue]</span>
                <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;Unable to solve the task (support function evaluation of the set at )&quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;eta = </span><span class="si">{</span><span class="n">np</span><span class="o">.</span><span class="n">array2string</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">eta_row</span><span class="p">))</span><span class="si">:</span><span class="s2">s</span><span class="si">}</span><span class="s2">). CVXPY returned error: </span><span class="si">{</span><span class="nb">str</span><span class="p">(</span><span class="n">err</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="p">)</span> <span class="kn">from</span><span class="w"> </span><span class="nn">err</span>
            <span class="k">if</span> <span class="n">problem</span><span class="o">.</span><span class="n">status</span> <span class="ow">in</span> <span class="p">[</span><span class="n">cp</span><span class="o">.</span><span class="n">OPTIMAL</span><span class="p">,</span> <span class="n">cp</span><span class="o">.</span><span class="n">OPTIMAL_INACCURATE</span><span class="p">]:</span>
                <span class="n">support_vector</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">value</span>  <span class="c1"># type: ignore[assignment]</span>
                <span class="n">support_value</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="n">problem</span><span class="o">.</span><span class="n">value</span>  <span class="c1"># type: ignore[assignment]</span>
            <span class="k">elif</span> <span class="n">problem</span><span class="o">.</span><span class="n">status</span> <span class="ow">in</span> <span class="p">[</span><span class="n">cp</span><span class="o">.</span><span class="n">UNBOUNDED</span><span class="p">,</span> <span class="n">cp</span><span class="o">.</span><span class="n">UNBOUNDED_INACCURATE</span><span class="p">]:</span>
                <span class="n">support_vector</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">dim</span><span class="p">,),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
                <span class="n">support_value</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;Could not solve the task (support function evaluation of the set at eta = &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">np</span><span class="o">.</span><span class="n">array2string</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">eta_row</span><span class="p">))</span><span class="si">:</span><span class="s2">s</span><span class="si">}</span><span class="s2">), due to an unhandled status: </span><span class="si">{</span><span class="n">problem</span><span class="o">.</span><span class="n">status</span><span class="si">:</span><span class="s2">s</span><span class="si">}</span><span class="s2">.&quot;</span>
                <span class="p">)</span>
    <span class="k">return</span> <span class="n">support_value</span><span class="p">,</span> <span class="n">support_vector</span>


<span class="k">def</span><span class="w"> </span><span class="nf">compute_irredundant_affine_set_using_cdd</span><span class="p">(</span>
    <span class="n">Ae</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">Sequence</span><span class="p">[</span><span class="nb">float</span><span class="p">]]</span> <span class="o">|</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">be</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">|</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Given an affine set (Ae, be), compute an irredundant set (irredundant_Ae, irredundant_be) using cdd</span>

<span class="sd">    Args:</span>
<span class="sd">        Ae (Sequence[Sequence[float]] | np.ndarray): Equality coefficient matrix (N times self.dim) that define the</span>
<span class="sd">            affine set</span>
<span class="sd">            :math:`\\{x|A_ex = b_e\\}`.</span>
<span class="sd">        be (Sequence[float] | np.ndarray): Equality constant vector (N,) that define the affine set</span>
<span class="sd">            :math:`\\{x| A_ex = b_e\\}`.</span>

<span class="sd">    Returns:</span>
<span class="sd">        tuple: A tuple containing two elements:</span>
<span class="sd">            1. irredundant_Ae (numpy.ndarray): Irredundant Ae describing the given affine set :math:`{x|A_e x = b_e}`</span>
<span class="sd">            2. irredundant_be (numpy.ndarray): Irredundant be describing the given affine set :math:`{x|A_e x = b_e}`</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">Ae_arr</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">Ae</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
    <span class="n">be_arr</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">be</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
    <span class="n">be_mAe</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">be_arr</span><span class="p">])</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="o">-</span><span class="n">Ae_arr</span><span class="p">))</span>
    <span class="n">He_cdd</span> <span class="o">=</span> <span class="n">cdd</span><span class="o">.</span><span class="n">matrix_from_array</span><span class="p">(</span><span class="n">be_mAe</span><span class="p">,</span> <span class="n">lin_set</span><span class="o">=</span><span class="nb">set</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">be_arr</span><span class="p">))),</span> <span class="n">rep_type</span><span class="o">=</span><span class="n">cdd</span><span class="o">.</span><span class="n">RepType</span><span class="o">.</span><span class="n">INEQUALITY</span><span class="p">)</span>
    <span class="n">cdd</span><span class="o">.</span><span class="n">matrix_canonicalize</span><span class="p">(</span><span class="n">He_cdd</span><span class="p">)</span>
    <span class="n">He_cdd_values</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">He_cdd</span><span class="o">.</span><span class="n">array</span><span class="p">)</span>
    <span class="n">irredundant_be</span><span class="p">,</span> <span class="n">irredundant__Ae</span> <span class="o">=</span> <span class="n">He_cdd_values</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="o">-</span><span class="n">He_cdd_values</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">:]</span>
    <span class="k">return</span> <span class="n">irredundant__Ae</span><span class="p">,</span> <span class="n">irredundant_be</span>


<div class="viewcode-block" id="is_ellipsoid">
<a class="viewcode-back" href="../../pycvxset.common.html#pycvxset.common.is_ellipsoid">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">is_ellipsoid</span><span class="p">(</span><span class="n">Q</span><span class="p">:</span> <span class="n">Any</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Check if the set is an ellipsoid</span>

<span class="sd">    Args:</span>
<span class="sd">        Q (object): Set to check</span>

<span class="sd">    Returns:</span>
<span class="sd">        bool: Returns True if the set is an ellipsoid, False otherwise</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">Q</span><span class="p">,</span> <span class="s2">&quot;_type_of_set&quot;</span><span class="p">)</span> <span class="ow">and</span> <span class="n">Q</span><span class="o">.</span><span class="n">type_of_set</span> <span class="o">==</span> <span class="s2">&quot;Ellipsoid&quot;</span></div>



<div class="viewcode-block" id="is_constrained_zonotope">
<a class="viewcode-back" href="../../pycvxset.common.html#pycvxset.common.is_constrained_zonotope">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">is_constrained_zonotope</span><span class="p">(</span><span class="n">Q</span><span class="p">:</span> <span class="n">Any</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Check if the set is a constrained zonotope</span>

<span class="sd">    Args:</span>
<span class="sd">        Q (object): Set to check</span>

<span class="sd">    Returns:</span>
<span class="sd">        bool: Returns True if the set is a constrained zonotope, False otherwise</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">Q</span><span class="p">,</span> <span class="s2">&quot;_type_of_set&quot;</span><span class="p">)</span> <span class="ow">and</span> <span class="n">Q</span><span class="o">.</span><span class="n">type_of_set</span> <span class="o">==</span> <span class="s2">&quot;ConstrainedZonotope&quot;</span></div>



<div class="viewcode-block" id="is_polytope">
<a class="viewcode-back" href="../../pycvxset.common.html#pycvxset.common.is_polytope">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">is_polytope</span><span class="p">(</span><span class="n">Q</span><span class="p">:</span> <span class="n">Any</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Check if the set is a polytope</span>

<span class="sd">    Args:</span>
<span class="sd">        Q (object): Set to check</span>

<span class="sd">    Returns:</span>
<span class="sd">        bool: Returns True if the set is a polytope, False otherwise</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">Q</span><span class="p">,</span> <span class="s2">&quot;_type_of_set&quot;</span><span class="p">)</span> <span class="ow">and</span> <span class="n">Q</span><span class="o">.</span><span class="n">type_of_set</span> <span class="o">==</span> <span class="s2">&quot;Polytope&quot;</span></div>



<span class="k">def</span><span class="w"> </span><span class="nf">make_aspect_ratio_equal</span><span class="p">(</span>
    <span class="n">set_with_unequal_aspect_ratio</span><span class="p">:</span> <span class="n">Polytope</span> <span class="o">|</span> <span class="n">Ellipsoid</span> <span class="o">|</span> <span class="n">ConstrainedZonotope</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">Polytope</span> <span class="o">|</span> <span class="n">Ellipsoid</span> <span class="o">|</span> <span class="n">ConstrainedZonotope</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]:</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute the set whose minimum_volume_circumscribing_rectangle is the unit box, and find the center and scaling</span>
<span class="sd">    matrix to undo the affine transformation.</span>

<span class="sd">    Args:</span>
<span class="sd">        set_with_unequal_aspect_ratio (Polytope | Ellipsoid | ConstrainedZonotope): Set to make aspect ratio equal</span>

<span class="sd">    Returns:</span>
<span class="sd">        tuple: A tuple with two items</span>
<span class="sd">            #. set_with_equal_aspect_ratio (Polytope | Ellipsoid | ConstrainedZonotope): Set with equal aspect ratio.</span>
<span class="sd">               Obtained after a specific affine transformation. The minimum_volume_circumscribing_rectangle of</span>
<span class="sd">               set_with_equal_aspect_ratio is the unit box.</span>
<span class="sd">            #. shift_to_undo_the_affine_transform (numpy.ndarray): Shift for the affine transformation</span>
<span class="sd">            #. scaling_matrix_to_undo_the_affine_transform  (numpy.ndarray): Scaling matrix for the affine</span>
<span class="sd">               transformation</span>

<span class="sd">    Notes:</span>
<span class="sd">        The function expects the set to be full-dimensional. Otherwise, scaling_matrix_to_make_aspect_equal may be</span>
<span class="sd">        undefined. To recover set_with_unequal_aspect_ratio from set_with_equal_aspect_ratio, perform the affine</span>
<span class="sd">        transform `(scaling_matrix_to_undo_the_affine_transform @ set_with_equal_aspect_ratio) +</span>
<span class="sd">        shift_to_under_the_affine_transform`.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">lb</span><span class="p">,</span> <span class="n">ub</span> <span class="o">=</span> <span class="n">set_with_unequal_aspect_ratio</span><span class="o">.</span><span class="n">minimum_volume_circumscribing_rectangle</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">ub</span> <span class="o">-</span> <span class="n">lb</span><span class="p">))</span> <span class="o">&lt;=</span> <span class="n">PYCVXSET_ZERO</span><span class="p">:</span>
        <span class="c1"># At least one dimension has zero width in the minimum_volume_circumscribing_rectangle, so the set is not</span>
        <span class="c1"># full-dimensional and we can not make aspect ratio equal.</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Expected the set </span><span class="si">{</span><span class="nb">repr</span><span class="p">(</span><span class="n">set_with_unequal_aspect_ratio</span><span class="p">)</span><span class="si">:</span><span class="s2">s</span><span class="si">}</span><span class="s2"> to be full-dimensional!&quot;</span><span class="p">)</span>
    <span class="n">shift_to_undo_the_affine_transform</span> <span class="o">=</span> <span class="p">(</span><span class="n">lb</span> <span class="o">+</span> <span class="n">ub</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span>
    <span class="n">scaling_matrix_to_make_aspect_equal</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="mi">2</span> <span class="o">/</span> <span class="p">(</span><span class="n">ub</span> <span class="o">-</span> <span class="n">lb</span><span class="p">))</span>
    <span class="n">scaling_matrix_to_undo_the_affine_transform</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">((</span><span class="n">ub</span> <span class="o">-</span> <span class="n">lb</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span>
    <span class="n">set_with_equal_aspect_ratio</span> <span class="o">=</span> <span class="n">scaling_matrix_to_make_aspect_equal</span> <span class="o">@</span> <span class="p">(</span>
        <span class="n">set_with_unequal_aspect_ratio</span> <span class="o">-</span> <span class="n">shift_to_undo_the_affine_transform</span>
    <span class="p">)</span>
    <span class="k">return</span> <span class="n">set_with_equal_aspect_ratio</span><span class="p">,</span> <span class="n">shift_to_undo_the_affine_transform</span><span class="p">,</span> <span class="n">scaling_matrix_to_undo_the_affine_transform</span>


<span class="k">def</span><span class="w"> </span><span class="nf">plot_polytopic_approximation</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="s2">&quot;ConstrainedZonotope | Ellipsoid&quot;</span><span class="p">,</span>
    <span class="n">method</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;inner&quot;</span><span class="p">,</span>
    <span class="n">ax</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Axes</span> <span class="o">|</span> <span class="n">Axes3D</span> <span class="o">|</span> <span class="kc">None</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">direction_vectors</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Sequence</span><span class="p">[</span><span class="n">Sequence</span><span class="p">[</span><span class="nb">float</span><span class="p">]]</span> <span class="o">|</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">n_vertices</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">n_halfspaces</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">patch_args</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">vertex_args</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">center_args</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">autoscale_enable</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">decimal_precision</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="n">PLOTTING_DECIMAL_PRECISION_CDD</span><span class="p">,</span>
    <span class="n">enable_warning</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">Any</span><span class="p">,</span> <span class="o">...</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Plot a polytopic approximation of the set.</span>

<span class="sd">    Args:</span>
<span class="sd">        method (str, optional): Type of polytopic approximation to use. Can be [&quot;inner&quot; or &quot;outer&quot;]. Defaults to</span>
<span class="sd">            &quot;inner&quot;.</span>
<span class="sd">        ax (Axes | Axes3D | None, optional): Axis on which the patch is to be plotted</span>
<span class="sd">        direction_vectors (Sequence[Sequence[float]] | np.ndarray, optional): Directions to use when performing ray</span>
<span class="sd">            shooting. Matrix (N times self.dim) for some N &gt;= 1. Defaults to None, in which case we use</span>
<span class="sd">            :meth:`pycvxset.common.spread_points_on_a_unit_sphere` to compute the direction vectors.</span>
<span class="sd">        n_vertices (int, optional): Number of vertices to use when computing the polytopic inner-approximation. Ignored</span>
<span class="sd">            if method is &quot;outer&quot; or when direction_vectors are provided. More than n_vertices may be used in some cases</span>
<span class="sd">            (see notes). Defaults to None.</span>
<span class="sd">        n_halfspaces (int, optional): Number of halfspaces to use when computing the polytopic outer-approximation.</span>
<span class="sd">            Ignored if method is &quot;outer&quot; or when direction_vectors are provided. More than n_halfspaces may be used in</span>
<span class="sd">            some cases (see notes). Defaults to None.</span>
<span class="sd">        patch_args (dict, optional): Arguments to pass for plotting faces and edges. See</span>
<span class="sd">            :meth:`pycvxset.Polytope.Polytope.plot` for more details. Defaults to None.</span>
<span class="sd">        vertex_args (dict, optional): Arguments to pass for plotting vertices. See</span>
<span class="sd">            :meth:`pycvxset.Polytope.Polytope.plot` for more details. Defaults to None.</span>
<span class="sd">        center_args (dict, optional): For ellipsoidal set, arguments to pass to scatter plot for the center. If a label</span>
<span class="sd">            is desired, pass it in center_args.</span>
<span class="sd">        autoscale_enable (bool, optional): When set to True, matplotlib adjusts axes to view full polytope. See</span>
<span class="sd">            :meth:`pycvxset.Polytope.Polytope.plot` for more details. Defaults to True.</span>
<span class="sd">        decimal_precision (int, optional): When plotting a 3D polytope that is in V-Rep and not in H-Rep, we round</span>
<span class="sd">            vertex to the specified precision to avoid numerical issues. Defaults to PLOTTING_DECIMAL_PRECISION_CDD</span>
<span class="sd">            specified in pycvxset.common.constants.</span>
<span class="sd">        enable_warning (bool, optional): Enables the UserWarning. May be turned off if expected. Defaults to True.</span>

<span class="sd">    Returns:</span>
<span class="sd">        tuple: See :meth:`pycvxset.Polytope.Polytope.plot` for details.</span>

<span class="sd">    Notes:</span>
<span class="sd">        This function is a wrapper for :meth:`polytopic_inner_approximation` and :meth:`polytopic_outer_approximation`</span>
<span class="sd">        for more details in polytope construction.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">is_constrained_zonotope</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="ow">or</span> <span class="n">is_polytope</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span> <span class="ow">and</span> <span class="n">center_args</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;center_args is only for ellipsoidal set plotting!&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="s2">&quot;inner&quot;</span><span class="p">:</span>
        <span class="n">polytopic_inner_approximation</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">polytopic_inner_approximation</span><span class="p">(</span>
            <span class="n">direction_vectors</span><span class="p">,</span> <span class="n">n_vertices</span><span class="p">,</span> <span class="n">enable_warning</span><span class="o">=</span><span class="n">enable_warning</span>
        <span class="p">)</span>
        <span class="n">tuple_to_return</span> <span class="o">=</span> <span class="n">polytopic_inner_approximation</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span>
            <span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">,</span>
            <span class="n">patch_args</span><span class="o">=</span><span class="n">patch_args</span><span class="p">,</span>
            <span class="n">vertex_args</span><span class="o">=</span><span class="n">vertex_args</span><span class="p">,</span>
            <span class="n">autoscale_enable</span><span class="o">=</span><span class="n">autoscale_enable</span><span class="p">,</span>
            <span class="n">decimal_precision</span><span class="o">=</span><span class="n">decimal_precision</span><span class="p">,</span>
            <span class="n">enable_warning</span><span class="o">=</span><span class="n">enable_warning</span><span class="p">,</span>
        <span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>  <span class="c1"># &quot;outer&quot; case</span>
        <span class="n">polytopic_outer_approximation</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">polytopic_outer_approximation</span><span class="p">(</span>
            <span class="n">direction_vectors</span><span class="p">,</span> <span class="n">n_halfspaces</span><span class="p">,</span> <span class="n">enable_warning</span><span class="o">=</span><span class="n">enable_warning</span>
        <span class="p">)</span>
        <span class="n">tuple_to_return</span> <span class="o">=</span> <span class="n">polytopic_outer_approximation</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span>
            <span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">,</span>
            <span class="n">patch_args</span><span class="o">=</span><span class="n">patch_args</span><span class="p">,</span>
            <span class="n">vertex_args</span><span class="o">=</span><span class="n">vertex_args</span><span class="p">,</span>
            <span class="n">autoscale_enable</span><span class="o">=</span><span class="n">autoscale_enable</span><span class="p">,</span>
            <span class="n">enable_warning</span><span class="o">=</span><span class="n">enable_warning</span><span class="p">,</span>
        <span class="p">)</span>
    <span class="c1"># In case of ellipsoids, plot the center when needed.</span>
    <span class="k">if</span> <span class="n">is_ellipsoid</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="ow">and</span> <span class="n">center_args</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="s2">&quot;color&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">center_args</span><span class="p">:</span>
            <span class="n">center_args</span><span class="p">[</span><span class="s2">&quot;color&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;k&quot;</span>
        <span class="n">ax</span> <span class="o">=</span> <span class="n">cast</span><span class="p">(</span><span class="s2">&quot;Axes | Axes3D&quot;</span><span class="p">,</span> <span class="n">tuple_to_return</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="o">*</span><span class="n">cast</span><span class="p">(</span><span class="s2">&quot;Ellipsoid&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">c</span><span class="p">,</span> <span class="o">**</span><span class="n">center_args</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">tuple_to_return</span>


<div class="viewcode-block" id="prune_and_round_vertices">
<a class="viewcode-back" href="../../pycvxset.common.html#pycvxset.common.prune_and_round_vertices">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">prune_and_round_vertices</span><span class="p">(</span>
    <span class="n">V</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">Sequence</span><span class="p">[</span><span class="nb">float</span><span class="p">]]</span> <span class="o">|</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">decimal_precision</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="n">PLOTTING_DECIMAL_PRECISION_CDD</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Filter through the vertices to skip any point that has another point (down in the list) that is close to it in</span>
<span class="sd">    the list.</span>

<span class="sd">    Args:</span>
<span class="sd">        V (Sequence[Sequence[float]] | np.ndarray): Matrix of vertices (N times self.dim)</span>
<span class="sd">        decimal_precision (int, optional): The decimal precision for rounding the vertices. Defaults to</span>
<span class="sd">            PLOTTING_DECIMAL_PRECISION_CDD from pycvxset.common.constants.</span>

<span class="sd">    Returns:</span>
<span class="sd">        numpy.ndarray: The pruned and rounded array of vertices.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">V_arr</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">V</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
    <span class="n">n_vertices</span> <span class="o">=</span> <span class="n">V_arr</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">new_vertex_list</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">ind_1</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_vertices</span><span class="p">):</span>
        <span class="n">no_point_is_close_to_this_point</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">for</span> <span class="n">ind_2</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">ind_1</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">n_vertices</span><span class="p">):</span>
            <span class="n">distances</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">V_arr</span><span class="p">[</span><span class="n">ind_1</span><span class="p">,</span> <span class="p">:]</span> <span class="o">-</span> <span class="n">V_arr</span><span class="p">[</span><span class="n">ind_2</span><span class="p">,</span> <span class="p">:])</span>
            <span class="k">if</span> <span class="n">distances</span> <span class="o">&lt;=</span> <span class="n">PYCVXSET_ZERO_CDD</span><span class="p">:</span>
                <span class="n">no_point_is_close_to_this_point</span> <span class="o">=</span> <span class="kc">False</span>
                <span class="k">break</span>
        <span class="k">if</span> <span class="n">no_point_is_close_to_this_point</span><span class="p">:</span>
            <span class="n">new_vertex_list</span> <span class="o">+=</span> <span class="p">[</span><span class="n">V_arr</span><span class="p">[</span><span class="n">ind_1</span><span class="p">,</span> <span class="p">:]]</span>
    <span class="n">new_vertex_list</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">new_vertex_list</span><span class="p">),</span> <span class="n">decimal_precision</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">new_vertex_list</span></div>



<span class="k">def</span><span class="w"> </span><span class="nf">sanitize_Ab</span><span class="p">(</span>
    <span class="n">A</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">Sequence</span><span class="p">[</span><span class="nb">float</span><span class="p">]]</span> <span class="o">|</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">|</span> <span class="kc">None</span><span class="p">,</span> <span class="n">b</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">|</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">|</span> <span class="kc">None</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">|</span> <span class="kc">None</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">|</span> <span class="kc">None</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Sanitize and check if (`A`, `b`) to make a valid halfspace combination</span>

<span class="sd">    Args:</span>
<span class="sd">        A (Sequence[Sequence[float]] | np.ndarray | None): Can be numpy arrays, list, or tuples</span>
<span class="sd">        b (Sequence[float] | np.ndarray | None): Can be numpy arrays, list, or tuples</span>

<span class="sd">    Raises:</span>
<span class="sd">        ValueError: A is not 2D numpy array free from NaNs and inf</span>
<span class="sd">        ValueError: b is not 1D numpy array free from NaNs</span>

<span class="sd">    Returns:</span>
<span class="sd">        tuple: A tuple with two items:</span>
<span class="sd">            #. A (numpy.ndarray | None): 2D Inequality coefficient matrix. None when no valid rows for A, b.</span>
<span class="sd">            #. b (numpy.ndarray | None): 1D Inequality constant vector. None when no valid rows for A, b.</span>

<span class="sd">    Notes:</span>
<span class="sd">        This function is used in the constructor of Polytope to check if (A, b) is compatible.</span>
<span class="sd">        sanitize_Aebe also uses this function remove any NaNs as well check for dimensionality.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">A_value</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">b_value</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">A</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">A_value</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="n">A</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">ValueError</span> <span class="k">as</span> <span class="n">err</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Can not convert A into a float array. Got </span><span class="si">{</span><span class="n">np</span><span class="o">.</span><span class="n">array2string</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">A</span><span class="p">))</span><span class="si">:</span><span class="s2">s</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span> <span class="kn">from</span><span class="w"> </span><span class="nn">err</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">b</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">b_value</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">b</span><span class="p">))</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">ValueError</span> <span class="k">as</span> <span class="n">err</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Can not convert b into a float array. Got </span><span class="si">{</span><span class="n">np</span><span class="o">.</span><span class="n">array2string</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">b</span><span class="p">))</span><span class="si">:</span><span class="s2">s</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span> <span class="kn">from</span><span class="w"> </span><span class="nn">err</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">A_value</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">A_value</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">b_value</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">b_value</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">):</span>
        <span class="k">return</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span>
    <span class="k">elif</span> <span class="n">A_value</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">b_value</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Both A and b must be provided or both must be None.&quot;</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">A_value</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="mi">2</span> <span class="ow">or</span> <span class="n">b_value</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="s2">&quot;Expected A, b to be a 2D, 1D arrays! &quot;</span>
            <span class="sa">f</span><span class="s2">&quot;Got A: </span><span class="si">{</span><span class="n">np</span><span class="o">.</span><span class="n">array2string</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">A_value</span><span class="p">))</span><span class="si">:</span><span class="s2">s</span><span class="si">}</span><span class="s2"> and b: </span><span class="si">{</span><span class="n">np</span><span class="o">.</span><span class="n">array2string</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">b_value</span><span class="p">))</span><span class="si">:</span><span class="s2">s</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="p">)</span>
    <span class="k">elif</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">A_value</span><span class="p">))</span> <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">b_value</span><span class="p">)):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="s2">&quot;Expected A, b to be from NaNs. &quot;</span>
            <span class="sa">f</span><span class="s2">&quot;Got </span><span class="si">{</span><span class="n">np</span><span class="o">.</span><span class="n">array2string</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">A_value</span><span class="p">))</span><span class="si">:</span><span class="s2">s</span><span class="si">}</span><span class="s2">, </span><span class="si">{</span><span class="n">np</span><span class="o">.</span><span class="n">array2string</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">b_value</span><span class="p">))</span><span class="si">:</span><span class="s2">s</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="p">)</span>
    <span class="k">elif</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isinf</span><span class="p">(</span><span class="n">A_value</span><span class="p">)):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Expected A to be from inf. Got </span><span class="si">{</span><span class="n">np</span><span class="o">.</span><span class="n">array2string</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">A_value</span><span class="p">))</span><span class="si">:</span><span class="s2">s</span><span class="si">}</span><span class="s2">!&quot;</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">A_value</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="n">b_value</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">and</span> <span class="ow">not</span> <span class="p">(</span><span class="n">A_value</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">b_value</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;A and b has different number of rows! A: </span><span class="si">{</span><span class="n">A_value</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">:</span><span class="s2">d</span><span class="si">}</span><span class="s2"> and b: </span><span class="si">{</span><span class="n">b_value</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">:</span><span class="s2">d</span><span class="si">}</span><span class="s2">.&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">A_value</span><span class="p">,</span> <span class="n">b_value</span>


<span class="k">def</span><span class="w"> </span><span class="nf">sanitize_Gc</span><span class="p">(</span>
    <span class="n">G</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">Sequence</span><span class="p">[</span><span class="nb">float</span><span class="p">]]</span> <span class="o">|</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">|</span> <span class="kc">None</span><span class="p">,</span> <span class="n">c</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">|</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">|</span> <span class="kc">None</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">Optional</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Sanitize and check if (`G`, `c`) to make a valid zonotope generator combination</span>

<span class="sd">    Args:</span>
<span class="sd">        G (Sequence[Sequence[float]] | np.ndarray | None): Can be numpy arrays, list, or tuples or None</span>
<span class="sd">        c (Sequence[float] | np.ndarray | None): Can be numpy arrays, list, or tuples</span>

<span class="sd">    Raises:</span>
<span class="sd">        ValueError: G is not 2D numpy array free from NaNs</span>
<span class="sd">        ValueError: c is not 2D numpy array free from NaNs</span>
<span class="sd">        ValueError: Both G and c cannot be None</span>

<span class="sd">    Returns:</span>
<span class="sd">        tuple: A tuple with two items:</span>
<span class="sd">            # G (numpy.ndarray): 2D generator coefficient matrix.</span>
<span class="sd">            # c (numpy.ndarray): 1D center vector.</span>

<span class="sd">    Notes:</span>
<span class="sd">        This function is used in the constructor of Constrained Zonotope to check if ((G, c) is compatible.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">G_arr</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
    <span class="n">c_arr</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
    <span class="k">if</span> <span class="n">G</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">G_arr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="n">G</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">ValueError</span> <span class="k">as</span> <span class="n">err</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Expected G to be a 2D float matrix. Got </span><span class="si">{</span><span class="n">np</span><span class="o">.</span><span class="n">array2string</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">G</span><span class="p">))</span><span class="si">:</span><span class="s2">s</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span> <span class="kn">from</span><span class="w"> </span><span class="nn">err</span>
        <span class="k">if</span> <span class="n">G_arr</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;G is not a two-dimensional array!&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">c</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># (G not None, c None) Empty set with dimension provided by G</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="n">G_arr</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">0</span><span class="p">)),</span> <span class="kc">None</span>
    <span class="k">if</span> <span class="n">c</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">c_arr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">c</span><span class="p">))</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">ValueError</span> <span class="k">as</span> <span class="n">err</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Expected c to be a 1D float array. Got </span><span class="si">{</span><span class="n">np</span><span class="o">.</span><span class="n">array2string</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">c</span><span class="p">))</span><span class="si">:</span><span class="s2">s</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span> <span class="kn">from</span><span class="w"> </span><span class="nn">err</span>
        <span class="k">if</span> <span class="n">c_arr</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;c is not a one-dimensional array!&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">G</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># (G None, c not None) Singleton set with dimension provided by c</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="n">c_arr</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="mi">0</span><span class="p">)),</span> <span class="n">c_arr</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># (G None, c None)</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Both G and c cannot be None!&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isinf</span><span class="p">(</span><span class="n">G_arr</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">()</span> <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">isinf</span><span class="p">(</span><span class="n">c_arr</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">()</span> <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">G_arr</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">()</span> <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">c_arr</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;Expected G, c to be 2D and 1D array free from NaNs and infs. &quot;</span>
            <span class="sa">f</span><span class="s2">&quot;Got </span><span class="si">{</span><span class="n">np</span><span class="o">.</span><span class="n">array2string</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">G_arr</span><span class="p">))</span><span class="si">:</span><span class="s2">s</span><span class="si">}</span><span class="s2">, </span><span class="si">{</span><span class="n">np</span><span class="o">.</span><span class="n">array2string</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">c_arr</span><span class="p">))</span><span class="si">:</span><span class="s2">s</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="p">)</span>
    <span class="k">elif</span> <span class="n">G_arr</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="n">c_arr</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;G and c has different number of rows! G: </span><span class="si">{</span><span class="n">G_arr</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">:</span><span class="s2">d</span><span class="si">}</span><span class="s2"> and c: </span><span class="si">{</span><span class="n">c_arr</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">:</span><span class="s2">d</span><span class="si">}</span><span class="s2">.&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">G_arr</span><span class="p">,</span> <span class="n">c_arr</span>


<span class="k">def</span><span class="w"> </span><span class="nf">sanitize_Aebe</span><span class="p">(</span>
    <span class="n">Ae</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">Sequence</span><span class="p">[</span><span class="nb">float</span><span class="p">]]</span> <span class="o">|</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">|</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">be</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">|</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">|</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">enable_warning</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">|</span> <span class="kc">None</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">|</span> <span class="kc">None</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Sanitize and return (`Ae`, `be`) to make a valid affine set combination</span>

<span class="sd">    Args:</span>
<span class="sd">        Ae (Sequence[Sequence[float]] | np.ndarray | None): Equality coefficient matrix specifying the affine set</span>
<span class="sd">        be (Sequence[float] | np.ndarray | None): Equality constant vector specifying the affine set</span>
<span class="sd">        enable_warning (bool, optional): Enables the UserWarning. May be turned off if expected. Defaults to True.</span>

<span class="sd">    Raises:</span>
<span class="sd">        ValueError: Ae is not 2D numpy array free from NaNs and infs</span>
<span class="sd">        ValueError: be is not 1D numpy array free from NaNs and infs</span>
<span class="sd">        ValueError: Provided (Ae, be) is not a valid system of linear equations</span>
<span class="sd">        UserWarning: When Ae, be has a row of zeros</span>

<span class="sd">    Returns:</span>
<span class="sd">        tuple: A tuple with two items:</span>
<span class="sd">            #. Ae (numpy.ndarray | None): 2D Equality coefficient matrix. None when no valid rows for Ae, be.</span>
<span class="sd">            #. be (numpy.ndarray | None): 1D Equality constant vector. None when no valid rows for Ae, be.</span>

<span class="sd">    Notes:</span>
<span class="sd">        This function is used in the constructor of Polytope as well as Constrained Zonotope to check if</span>
<span class="sd">        (Ae, be) is compatible.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">Ae</span><span class="p">,</span> <span class="n">be</span> <span class="o">=</span> <span class="n">sanitize_Ab</span><span class="p">(</span><span class="n">Ae</span><span class="p">,</span> <span class="n">be</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">ValueError</span> <span class="k">as</span> <span class="n">err</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;Invalid linear system (Ae, be)! Got </span><span class="si">{</span><span class="n">np</span><span class="o">.</span><span class="n">array2string</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">Ae</span><span class="p">))</span><span class="si">:</span><span class="s2">s</span><span class="si">}</span><span class="s2">, </span><span class="si">{</span><span class="n">np</span><span class="o">.</span><span class="n">array2string</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">be</span><span class="p">))</span><span class="si">:</span><span class="s2">s</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="p">)</span> <span class="kn">from</span><span class="w"> </span><span class="nn">err</span>
    <span class="k">if</span> <span class="n">Ae</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">be</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span>
    <span class="n">Ae_arr</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="n">Ae</span>
    <span class="n">be_arr</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="n">be</span>
    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isinf</span><span class="p">(</span><span class="n">be_arr</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Expected be to free from NaNs and infs. Got </span><span class="si">{</span><span class="n">np</span><span class="o">.</span><span class="n">array2string</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">be_arr</span><span class="p">))</span><span class="si">:</span><span class="s2">s</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">valid_rows_Ae_be</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">Ae_arr</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">be_arr</span><span class="p">])</span><span class="o">.</span><span class="n">T</span><span class="p">)))</span> <span class="o">&gt;</span> <span class="n">PYCVXSET_ZERO</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">sum</span><span class="p">(</span><span class="n">valid_rows_Ae_be</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">enable_warning</span> <span class="ow">and</span> <span class="nb">sum</span><span class="p">(</span><span class="n">valid_rows_Ae_be</span><span class="p">)</span> <span class="o">!=</span> <span class="n">Ae_arr</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;Removed some rows in (Ae, be) that had all zeros!&quot;</span><span class="p">,</span> <span class="ne">UserWarning</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">Ae_arr</span><span class="p">[</span><span class="n">valid_rows_Ae_be</span><span class="p">,</span> <span class="p">:],</span> <span class="n">be_arr</span><span class="p">[</span><span class="n">valid_rows_Ae_be</span><span class="p">]</span>


<span class="k">def</span><span class="w"> </span><span class="nf">sanitize_and_identify_Aebe</span><span class="p">(</span>
    <span class="n">Ae</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">Sequence</span><span class="p">[</span><span class="nb">float</span><span class="p">]]</span> <span class="o">|</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">|</span> <span class="kc">None</span><span class="p">,</span> <span class="n">be</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">|</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">|</span> <span class="kc">None</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">|</span> <span class="kc">None</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">|</span> <span class="kc">None</span><span class="p">,</span> <span class="nb">str</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">|</span> <span class="kc">None</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;_summary_</span>

<span class="sd">    Args:</span>
<span class="sd">        Ae (Sequence[Sequence[float]] | np.ndarray): Equality coefficient matrix specifying the affine set after</span>
<span class="sd">            sanitize_Aebe</span>
<span class="sd">        be (Sequence[float] | np.ndarray): Equality constant vector specifying the affine set after sanitize_Aebe</span>

<span class="sd">    Raises:</span>
<span class="sd">        ValueError: _description_</span>

<span class="sd">    Returns:</span>
<span class="sd">        tuple: A tuple with two items:</span>
<span class="sd">            #. sanitize_Ae (numpy.ndarray): 2D Equality coefficient matrix. None when no valid rows for Ae, be.</span>
<span class="sd">            #. sanitize_be (numpy.ndarray): 1D Equality constant vector. None when no valid rows for Ae, be.</span>
<span class="sd">            #. Aebe_status (str): Can be one of [&quot;no_Ae_be&quot;, &quot;affine_set&quot;, &quot;single_point&quot;, &quot;infeasible&quot;]</span>
<span class="sd">            #. solution_to_Ae_x_eq_be (numpy.ndarray): 1D feasible solution to the affine set, when it exists. Set to</span>
<span class="sd">               None when Aebe_status is no_Ae_be or infeasible or unidentified.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">sanitized_Ae</span><span class="p">,</span> <span class="n">sanitized_be</span> <span class="o">=</span> <span class="n">sanitize_Aebe</span><span class="p">(</span><span class="n">Ae</span><span class="p">,</span> <span class="n">be</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">sanitized_Ae</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">sanitized_be</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">solution_to_Ae_x_eq_be</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">Aebe_status</span> <span class="o">=</span> <span class="s2">&quot;no_Ae_be&quot;</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">solution_to_Ae_x_eq_be</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">matrix_rank_Ae</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">lstsq</span><span class="p">(</span><span class="n">sanitized_Ae</span><span class="p">,</span> <span class="n">sanitized_be</span><span class="p">,</span> <span class="n">rcond</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
            <span class="n">max_abs_residual_Ax_x_eq_be</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">sanitized_be</span> <span class="o">-</span> <span class="n">sanitized_Ae</span> <span class="o">@</span> <span class="n">solution_to_Ae_x_eq_be</span><span class="p">))</span>
        <span class="k">except</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">LinAlgError</span> <span class="k">as</span> <span class="n">err</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Provided (Ae, be) is not a valid system of linear equations.&quot;</span><span class="p">)</span> <span class="kn">from</span><span class="w"> </span><span class="nn">err</span>

        <span class="k">if</span> <span class="n">max_abs_residual_Ax_x_eq_be</span> <span class="o">&gt;</span> <span class="n">PYCVXSET_ZERO</span><span class="p">:</span>  <span class="c1"># At least one equality has large residual</span>
            <span class="n">Aebe_status</span> <span class="o">=</span> <span class="s2">&quot;infeasible&quot;</span>
        <span class="k">elif</span> <span class="n">matrix_rank_Ae</span> <span class="o">==</span> <span class="n">sanitized_Ae</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
            <span class="c1"># There are as many linearly independent equality constraints as dimension. So (Ae, be) is</span>
            <span class="c1"># solved by a single point.</span>
            <span class="n">Aebe_status</span> <span class="o">=</span> <span class="s2">&quot;single_point&quot;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">Aebe_status</span> <span class="o">=</span> <span class="s2">&quot;affine_set&quot;</span>
    <span class="k">return</span> <span class="n">sanitized_Ae</span><span class="p">,</span> <span class="n">sanitized_be</span><span class="p">,</span> <span class="n">Aebe_status</span><span class="p">,</span> <span class="n">solution_to_Ae_x_eq_be</span>


<span class="k">def</span><span class="w"> </span><span class="nf">minimize</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="s2">&quot;ConstrainedZonotope | Ellipsoid | Polytope&quot;</span><span class="p">,</span>
    <span class="n">x</span><span class="p">:</span> <span class="n">cvxpy</span><span class="o">.</span><span class="n">Variable</span><span class="p">,</span>
    <span class="n">objective_to_minimize</span><span class="p">:</span> <span class="n">cvxpy</span><span class="o">.</span><span class="n">Expression</span><span class="p">,</span>
    <span class="n">cvxpy_args</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">],</span>
    <span class="n">task_str</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="nb">str</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Solve a convex program with CVXPY objective subject to containment constraints.</span>

<span class="sd">    Args:</span>
<span class="sd">        x (cvxpy.Variable): CVXPY variable to be optimized</span>
<span class="sd">        objective_to_minimize (cvxpy.Expression): CVXPY expression to be minimized</span>
<span class="sd">        cvxpy_args (dict): CVXPY arguments to be passed to the solver</span>
<span class="sd">        task_str (str, optional): Task string to be used in error messages. Defaults to &#39;&#39;.</span>

<span class="sd">    Raises:</span>
<span class="sd">        NotImplementedError: Unable to solve problem using CVXPY</span>

<span class="sd">    Returns:</span>
<span class="sd">        tuple: A tuple with three items:</span>
<span class="sd">            #. x.value (numpy.ndarray): Optimal value of x. np.nan * np.ones((self.dim,)) if the problem is not solved.</span>
<span class="sd">            #. problem.value (float): Optimal value of the convex program. np.inf if the problem is infeasible, -np.inf</span>
<span class="sd">               if problem is unbounded, and finite otherwise.</span>
<span class="sd">            #. problem_status (str): Status of the problem</span>

<span class="sd">    Notes:</span>
<span class="sd">        This function uses :meth:`containment_constraints` to obtain the list of CVXPY expressions that form the</span>
<span class="sd">        containment constraints on x.</span>

<span class="sd">    Warning:</span>
<span class="sd">        Please pay attention to the NotImplementedError generated by this function. It may be possible to get CVXPY to</span>
<span class="sd">        solve the same problem by switching the solver. For example, consider the following code block.</span>

<span class="sd">        .. code-block:: python</span>

<span class="sd">            from pycvxset import Polytope</span>
<span class="sd">            P = Polytope(A=[[1, 1], [-1, -1]], b=[1, 1])</span>
<span class="sd">            P.cvxpy_args_lp = {&#39;solver&#39;: &#39;CLARABEL&#39;}    # Default solver used in pycvxset</span>
<span class="sd">            try:</span>
<span class="sd">                print(&#39;Is polytope bounded?&#39;, P.is_bounded)</span>
<span class="sd">            except NotImplementedError as err:</span>
<span class="sd">                print(str(err))</span>
<span class="sd">            P.cvxpy_args_lp = {&#39;solver&#39;: &#39;OSQP&#39;}</span>
<span class="sd">            print(&#39;Is polytope bounded?&#39;, P.is_bounded)</span>

<span class="sd">        This code block produces the following output::</span>

<span class="sd">            Unable to solve the task (support function evaluation of the set at eta = [-0. -1.]). CVXPY returned error:</span>
<span class="sd">            Solver &#39;CLARABEL&#39; failed. Try another solver, or solve with verbose=True for more information.</span>

<span class="sd">            Is polytope bounded? False</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">import</span><span class="w"> </span><span class="nn">cvxpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">cp</span>

    <span class="k">try</span><span class="p">:</span>
        <span class="n">containment_constraints</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">containment_constraints</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">dim</span><span class="p">,)),</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">,</span> <span class="n">cp</span><span class="o">.</span><span class="n">INFEASIBLE</span>
    <span class="n">problem</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">Problem</span><span class="p">(</span><span class="n">cp</span><span class="o">.</span><span class="n">Minimize</span><span class="p">(</span><span class="n">objective_to_minimize</span><span class="p">),</span> <span class="n">containment_constraints</span><span class="p">)</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">problem</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="o">**</span><span class="n">cvxpy_args</span><span class="p">)</span>
    <span class="k">except</span> <span class="n">cp</span><span class="o">.</span><span class="n">error</span><span class="o">.</span><span class="n">SolverError</span> <span class="k">as</span> <span class="n">err</span><span class="p">:</span>  <span class="c1"># pyright: ignore[reportAttributeAccessIssue]</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Unable to solve the task (</span><span class="si">{</span><span class="n">task_str</span><span class="si">:</span><span class="s2">s</span><span class="si">}</span><span class="s2">). CVXPY returned error: </span><span class="si">{</span><span class="nb">str</span><span class="p">(</span><span class="n">err</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span> <span class="kn">from</span><span class="w"> </span><span class="nn">err</span>
    <span class="k">if</span> <span class="n">problem</span><span class="o">.</span><span class="n">status</span> <span class="ow">in</span> <span class="p">[</span><span class="n">cp</span><span class="o">.</span><span class="n">OPTIMAL</span><span class="p">,</span> <span class="n">cp</span><span class="o">.</span><span class="n">OPTIMAL_INACCURATE</span><span class="p">]:</span>
        <span class="n">x_value</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">value</span>  <span class="c1"># type: ignore[assignment]</span>
        <span class="n">problem_value</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="n">problem</span><span class="o">.</span><span class="n">value</span>  <span class="c1"># type: ignore[assignment]</span>
        <span class="k">return</span> <span class="n">x_value</span><span class="p">,</span> <span class="n">problem_value</span><span class="p">,</span> <span class="n">problem</span><span class="o">.</span><span class="n">status</span>
    <span class="k">elif</span> <span class="n">problem</span><span class="o">.</span><span class="n">status</span> <span class="ow">in</span> <span class="p">[</span><span class="n">cp</span><span class="o">.</span><span class="n">UNBOUNDED</span><span class="p">,</span> <span class="n">cp</span><span class="o">.</span><span class="n">UNBOUNDED_INACCURATE</span><span class="p">]:</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">dim</span><span class="p">,)),</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">,</span> <span class="n">problem</span><span class="o">.</span><span class="n">status</span>
    <span class="k">elif</span> <span class="n">problem</span><span class="o">.</span><span class="n">status</span> <span class="ow">in</span> <span class="p">[</span><span class="n">cp</span><span class="o">.</span><span class="n">INFEASIBLE</span><span class="p">,</span> <span class="n">cp</span><span class="o">.</span><span class="n">INFEASIBLE_INACCURATE</span><span class="p">]:</span>
        <span class="c1"># Infeasible is possible when containment_constraints returns infeasible constraints but without detection</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">dim</span><span class="p">,)),</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">,</span> <span class="n">problem</span><span class="o">.</span><span class="n">status</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># Should never happen!</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;Could not solve the task (</span><span class="si">{</span><span class="n">task_str</span><span class="si">:</span><span class="s2">s</span><span class="si">}</span><span class="s2">), due to an unhandled status: </span><span class="si">{</span><span class="n">problem</span><span class="o">.</span><span class="n">status</span><span class="si">:</span><span class="s2">s</span><span class="si">}</span><span class="s2">.&quot;</span>
        <span class="p">)</span>


<div class="viewcode-block" id="spread_points_on_a_unit_sphere">
<a class="viewcode-back" href="../../pycvxset.common.html#pycvxset.common.spread_points_on_a_unit_sphere">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">spread_points_on_a_unit_sphere</span><span class="p">(</span>
    <span class="n">dim</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
    <span class="n">n_points</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">cvxpy_socp_args</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">verbose</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">enable_warning</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">save_points_on_a_unit_sphere</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="n">SPOAUS_SAVE_POINTS_ON_A_UNIT_SPHERE</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]:</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Spread points on a unit sphere in n-dimensional space.</span>

<span class="sd">    Args:</span>
<span class="sd">        dim (int): The dimension of the sphere.</span>
<span class="sd">        n_points (int): The number of points to be spread on the unit sphere. Defaults to None, in which case, we choose</span>
<span class="sd">        n_points = (2 * self.dim) + (2**self.dim) * SPOAUS_DIRECTIONS_PER_QUADRANT.</span>
<span class="sd">        cvxpy_socp_args (dict): Additional arguments to be passed to the CVXPY solver. Defaults to None, in which case</span>
<span class="sd">            the function uses DEFAULT_CVXPY_ARGS_SOCP from pycvxset.common.constants.</span>
<span class="sd">        verbose (bool, optional): Whether to print verbose output. Defaults to False.</span>
<span class="sd">        enable_warning (bool, optional): Enables the UserWarning. May be turned off if expected. Defaults to True.</span>
<span class="sd">        save_points_on_a_unit_sphere (bool, optional): Whether to save the computed points and minimum separation to a</span>
<span class="sd">            file. Defaults to SPOAUS_SAVE_POINTS_ON_A_UNIT_SPHERE.</span>

<span class="sd">    Returns:</span>
<span class="sd">        tuple: A tuple containing three items:</span>
<span class="sd">            # opt_locations (ndarray): The spread points on the unit sphere.</span>
<span class="sd">            # minimum_separation (float): The minimum separation between the points.</span>
<span class="sd">            # opt_locations_first_quad (ndarray): The spread points in the first quadrant.</span>

<span class="sd">    Raises:</span>
<span class="sd">        ValueError: If n_points is less than 2 * dim.</span>
<span class="sd">        UserWarning: If n_points - 2 * dim is not a multiple of 2^dim.</span>
<span class="sd">        NotImplementedError: Unable to solve the convexified problem using CVXPY</span>
<span class="sd">        NotImplementedError: Convex-concave procedure did not converge!</span>

<span class="sd">    Notes:</span>
<span class="sd">        This function uses the CVXPY library to solve a convex optimization problem to spread the points on the unit</span>
<span class="sd">        sphere. The spread points are returned as opt_locations, the separation between the points is returned as</span>
<span class="sd">        separation, and the spread points in the first quadrant are returned as opt_locations_first_quad.</span>

<span class="sd">        For dim in [1, 2], the points are available in closed-form. For dim &gt;= 3, we solve the following non-convex</span>
<span class="sd">        optimization problem using convex-concave procedure:</span>

<span class="sd">        .. math ::</span>
<span class="sd">            \begin{array}{rlrl}</span>
<span class="sd">                \text{maximize}     &amp;\quad R \\</span>
<span class="sd">                \text{subject to}   &amp;\quad R \geq 0\\</span>
<span class="sd">                                    &amp;\quad x \geq R/2\\</span>
<span class="sd">                                    &amp;\quad \|x_i - x_j\| \geq R, &amp;&amp; 1 \leq i &lt; j \leq n_\text{points}\\</span>
<span class="sd">                                    &amp;\quad \|x_i - e_j\| \geq R, &amp;&amp; 1 \leq i \leq n_\text{points},</span>
<span class="sd">                                                                    1 \leq j \leq n_\text{dim}\\</span>
<span class="sd">                                    &amp;\quad \|x_i \| \leq 1,      &amp;&amp; 1 \leq i \leq n_\text{points}\\</span>
<span class="sd">                                    &amp;\quad \|x_i \| \geq 0.8,    &amp;&amp; 1 \leq i \leq n_\text{points}\\</span>
<span class="sd">            \end{array}</span>

<span class="sd">        The optimization problem seeks to spread points (apart from the standard axes) in the first quadrant so that</span>
<span class="sd">        their pairwise separation is maximized, while they have a norm close to 1. The second constraint is motivated to</span>
<span class="sd">        ensure that the reflections of the points about the quadrant plane is also separated by R.</span>

<span class="sd">        When `save_points_on_a_unit_sphere` is True, the function saves the computed points (all), the computed</span>
<span class="sd">        points in the first quadrant, and the minimum separation to a file named</span>
<span class="sd">        `tmp/spoaus_dim_{dim}_n_points_{n_points_int}.npz`. If the file already exists, the function loads the</span>
<span class="sd">        points and minimum separation from the file instead of recomputing them. This can save time when calling</span>
<span class="sd">        `spread_points_on_a_unit_sphere` with default values.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">import</span><span class="w"> </span><span class="nn">cvxpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">cp</span>

    <span class="k">if</span> <span class="n">n_points</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">n_points_int</span> <span class="o">=</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">dim</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="mi">2</span><span class="o">**</span><span class="n">dim</span><span class="p">)</span> <span class="o">*</span> <span class="n">SPOAUS_DIRECTIONS_PER_QUADRANT</span>
    <span class="k">elif</span> <span class="n">n_points</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Expected n_points to be positive! Got </span><span class="si">{</span><span class="n">n_points</span><span class="si">}</span><span class="s2">!&quot;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">n_points_int</span> <span class="o">=</span> <span class="n">n_points</span>
    <span class="k">if</span> <span class="n">dim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">opt_locations</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]])</span>
        <span class="n">opt_locations_first_quad</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">]])</span>
        <span class="n">minimum_separation</span> <span class="o">=</span> <span class="mf">2.0</span>
    <span class="k">elif</span> <span class="n">dim</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
        <span class="n">theta_vec</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span> <span class="n">n_points_int</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">opt_locations</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">theta_vec</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">theta_vec</span><span class="p">)))</span><span class="o">.</span><span class="n">T</span>
        <span class="n">minimum_separation</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">opt_locations</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span> <span class="o">-</span> <span class="n">opt_locations</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="nb">ord</span><span class="o">=</span><span class="mi">2</span><span class="p">))</span>
        <span class="n">opt_locations_first_quad</span> <span class="o">=</span> <span class="n">opt_locations</span><span class="p">[</span><span class="n">theta_vec</span> <span class="o">&lt;=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mi">2</span><span class="p">),</span> <span class="p">:]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># Ensure that n_points - (2 * dim) to be a multiple of 2**dim</span>
        <span class="k">if</span> <span class="n">n_points_int</span> <span class="o">&lt;</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">dim</span><span class="p">:</span>
            <span class="c1"># Need to allow at least the standard vectors and their reflections</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Expected n_points &gt;= 2*dim&quot;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="p">(</span>
            <span class="n">cvxpy_socp_args</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
            <span class="ow">and</span> <span class="s2">&quot;solver&quot;</span> <span class="ow">in</span> <span class="n">cvxpy_socp_args</span>
            <span class="ow">and</span> <span class="n">cvxpy_socp_args</span><span class="p">[</span><span class="s2">&quot;solver&quot;</span><span class="p">]</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">cp</span><span class="o">.</span><span class="n">installed_solvers</span><span class="p">()</span>
        <span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Solver </span><span class="si">{</span><span class="n">cvxpy_socp_args</span><span class="p">[</span><span class="s1">&#39;solver&#39;</span><span class="p">]</span><span class="si">:</span><span class="s2">s</span><span class="si">}</span><span class="s2"> is not installed!&quot;</span><span class="p">)</span>
        <span class="n">opt_locations</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="n">dim</span><span class="p">),</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="n">dim</span><span class="p">)))</span>
        <span class="c1"># Guaranteed to be positive since n_points_int &gt;= 2 * dim</span>
        <span class="n">n_points_first_quad_old</span> <span class="o">=</span> <span class="p">(</span><span class="n">n_points_int</span> <span class="o">-</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">dim</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span><span class="o">**</span><span class="n">dim</span><span class="p">)</span>
        <span class="n">n_points_old</span> <span class="o">=</span> <span class="n">n_points_int</span>
        <span class="n">n_points_first_quad</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">n_points_first_quad_old</span><span class="p">))</span>
        <span class="n">n_points_int</span> <span class="o">=</span> <span class="p">(</span><span class="mi">2</span><span class="o">**</span><span class="n">dim</span><span class="p">)</span> <span class="o">*</span> <span class="n">n_points_first_quad</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">dim</span>
        <span class="k">if</span> <span class="n">enable_warning</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">isclose</span><span class="p">(</span><span class="n">n_points_first_quad_old</span><span class="p">,</span> <span class="n">n_points_first_quad</span><span class="p">):</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Invalid combination of (dim=</span><span class="si">{</span><span class="n">dim</span><span class="si">}</span><span class="s2">, n_points=</span><span class="si">{</span><span class="n">n_points_old</span><span class="si">}</span><span class="s2">). &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;spread_points_on_a_unit_sphere requires n_points - 2*dim &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;(Got: </span><span class="si">{</span><span class="n">n_points_old</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="p">(</span><span class="mi">2</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">dim</span><span class="p">)</span><span class="si">:</span><span class="s2">d</span><span class="si">}</span><span class="s2">) to be a multiple of 2^dim&quot;</span>
                <span class="sa">f</span><span class="s2">&quot;(Got: </span><span class="si">{</span><span class="mi">2</span><span class="w"> </span><span class="o">**</span><span class="w"> </span><span class="n">dim</span><span class="si">:</span><span class="s2">d</span><span class="si">}</span><span class="s2">). Will return </span><span class="si">{</span><span class="n">n_points_int</span><span class="si">}</span><span class="s2"> points instead of requested </span><span class="si">{</span><span class="n">n_points_old</span><span class="si">}</span><span class="s2"> &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;points.&quot;</span><span class="p">,</span>
                <span class="ne">UserWarning</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="k">if</span> <span class="n">save_points_on_a_unit_sphere</span><span class="p">:</span>  <span class="c1"># pragma: no cover</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">os</span><span class="o">.</span><span class="n">makedirs</span><span class="p">(</span><span class="s2">&quot;tmp&quot;</span><span class="p">,</span> <span class="n">exist_ok</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">PermissionError</span> <span class="k">as</span> <span class="n">err</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">PermissionError</span><span class="p">(</span>
                    <span class="s2">&quot;Cannot create tmp/  no write permissions. Set save_points_on_a_unit_sphere to False or ensure &quot;</span>
                    <span class="s2">&quot;write permissions.&quot;</span>
                <span class="p">)</span> <span class="kn">from</span><span class="w"> </span><span class="nn">err</span>
            <span class="n">save_filename</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;tmp/spoaus_dim_</span><span class="si">{</span><span class="n">dim</span><span class="si">}</span><span class="s2">_n_points_</span><span class="si">{</span><span class="n">n_points_int</span><span class="si">}</span><span class="s2">.npz&quot;</span>
        <span class="k">else</span><span class="p">:</span>  <span class="c1"># pragma: no cover</span>
            <span class="n">save_filename</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>

        <span class="k">if</span> <span class="n">n_points_first_quad</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1"># Return the standard axes and their reflections</span>
            <span class="n">opt_locations_first_quad</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="n">dim</span><span class="p">)</span>
            <span class="n">minimum_separation</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span><span class="p">))</span>
            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Skipped spacing vectors! Returned the standard axes!&quot;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">save_points_on_a_unit_sphere</span> <span class="ow">and</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">save_filename</span><span class="p">):</span>
            <span class="n">loaded_data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">save_filename</span><span class="p">)</span>
            <span class="n">opt_locations</span> <span class="o">=</span> <span class="n">loaded_data</span><span class="p">[</span><span class="s2">&quot;opt_locations&quot;</span><span class="p">]</span>
            <span class="n">minimum_separation</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">loaded_data</span><span class="p">[</span><span class="s2">&quot;minimum_separation&quot;</span><span class="p">])</span>
            <span class="n">opt_locations_first_quad</span> <span class="o">=</span> <span class="n">loaded_data</span><span class="p">[</span><span class="s2">&quot;opt_locations_first_quad&quot;</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;Loaded pre-computed spread points on a unit sphere for dim=</span><span class="si">{</span><span class="n">dim</span><span class="si">}</span><span class="s2"> and n_points=</span><span class="si">{</span><span class="n">n_points_int</span><span class="si">}</span><span class="s2">!&quot;</span>
                    <span class="s2">&quot; This saves time. If you want to re-run the convex-concave procedure, please delete the file &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">save_filename</span><span class="si">}</span><span class="s2">, and run the function again.&quot;</span>
                <span class="p">)</span>
            <span class="k">return</span> <span class="n">opt_locations</span><span class="p">,</span> <span class="n">minimum_separation</span><span class="p">,</span> <span class="n">opt_locations_first_quad</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Spreading </span><span class="si">{</span><span class="n">n_points_int</span><span class="si">}</span><span class="s2"> unit-length vectors in </span><span class="si">{</span><span class="n">dim</span><span class="si">}</span><span class="s2">-dim space&quot;</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Analyzing </span><span class="si">{</span><span class="n">n_points_first_quad</span><span class="si">}</span><span class="s2"> unit-length vectors in first quadrant&quot;</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">cvxpy_socp_args</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">cvxpy_socp_args</span> <span class="o">=</span> <span class="n">DEFAULT_CVXPY_ARGS_SOCP</span>

            <span class="c1"># Difference of convex approach</span>
            <span class="c1"># INITIAL_TAU times SCALING_TAU ^ MAX_ITERATIONS = TAU_MAX</span>
            <span class="n">MAX_ITERATIONS</span> <span class="o">=</span> <span class="n">SPOAUS_ITERATIONS_AT_TAU_MAX</span> <span class="o">+</span> <span class="nb">int</span><span class="p">(</span>
                <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">SPOAUS_TAU_MAX</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">SPOAUS_SCALING_TAU</span><span class="p">)</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">SPOAUS_INITIAL_TAU</span><span class="p">))</span>
            <span class="p">)</span>

            <span class="c1"># Initialize counter for iterations</span>
            <span class="n">continue_condition</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="n">tau_iter</span> <span class="o">=</span> <span class="n">SPOAUS_INITIAL_TAU</span>
            <span class="n">iter_count</span> <span class="o">=</span> <span class="mi">1</span>

            <span class="c1"># Initialize vectors by assigning all along the unit-norm vector equidistant from all standard vectors</span>
            <span class="n">x_iter</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="n">n_points_first_quad</span><span class="p">,</span> <span class="n">dim</span><span class="p">))</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">dim</span><span class="p">)</span>

            <span class="c1"># For DC approach, initialize the previous costs</span>
            <span class="n">separation_prev</span> <span class="o">=</span> <span class="mf">0.0</span>
            <span class="n">sum_slack_var_prev</span> <span class="o">=</span> <span class="mf">0.0</span>
            <span class="n">objective_value_prev</span> <span class="o">=</span> <span class="mf">0.0</span>
            <span class="n">cost_prev_with_new_tau_iter</span> <span class="o">=</span> <span class="mf">0.0</span>
            <span class="k">while</span> <span class="n">continue_condition</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">iter_count</span><span class="si">}</span><span class="s2">/</span><span class="si">{</span><span class="n">MAX_ITERATIONS</span><span class="si">}</span><span class="s2">. Setting up the CVXPY problem...&quot;</span><span class="p">)</span>

                <span class="n">x</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">Variable</span><span class="p">((</span><span class="n">n_points_first_quad</span><span class="p">,</span> <span class="n">dim</span><span class="p">))</span>
                <span class="n">separation</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">Variable</span><span class="p">(</span><span class="n">nonneg</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                <span class="n">pairwise_separation_slack_var</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">Variable</span><span class="p">((</span><span class="n">n_points_first_quad</span><span class="p">,</span> <span class="n">n_points_first_quad</span><span class="p">),</span> <span class="n">nonneg</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                <span class="n">standard_vector_separation_slack_var</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">Variable</span><span class="p">((</span><span class="n">n_points_first_quad</span><span class="p">,</span> <span class="n">dim</span><span class="p">),</span> <span class="n">nonneg</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                <span class="n">minimum_norm_slack_var</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">Variable</span><span class="p">((</span><span class="n">n_points_first_quad</span><span class="p">,),</span> <span class="n">nonneg</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                <span class="c1"># Constraint 1: Enforces the separation constraint is satisfied by reflections about quadrant planes</span>
                <span class="n">constraints</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">cp</span><span class="o">.</span><span class="n">Constraint</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span>
                    <span class="n">np</span><span class="o">.</span><span class="n">power</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span> <span class="o">/</span> <span class="n">dim</span><span class="p">)</span> <span class="o">*</span> <span class="n">x</span> <span class="o">&gt;=</span> <span class="n">separation</span><span class="p">,</span>
                <span class="p">]</span>
                <span class="c1"># Constraint 2: Set the unused slack variables to zero</span>
                <span class="n">constraints</span> <span class="o">+=</span> <span class="p">[</span><span class="n">pairwise_separation_slack_var</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">triu_indices</span><span class="p">(</span><span class="n">n_points_first_quad</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">]</span>
                <span class="k">for</span> <span class="n">pt_index_1</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_points_first_quad</span><span class="p">):</span>
                    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">pt_index_1</span><span class="si">:</span><span class="s2">2d</span><span class="si">}</span><span class="s2"> | &quot;</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">)</span>
                        <span class="k">if</span> <span class="p">((</span><span class="n">pt_index_1</span> <span class="o">-</span> <span class="mi">9</span><span class="p">)</span> <span class="o">%</span> <span class="mi">10</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="ow">or</span> <span class="n">pt_index_1</span> <span class="o">==</span> <span class="n">n_points_first_quad</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
                            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;&quot;</span><span class="p">)</span>

                    <span class="c1"># Constraint 3: Enforces the pairwise separation constraint ||x_i - x_j||^2 &gt;= r^2</span>
                    <span class="n">x_i_prev</span> <span class="o">=</span> <span class="n">x_iter</span><span class="p">[</span><span class="n">pt_index_1</span><span class="p">,</span> <span class="p">:]</span>
                    <span class="k">for</span> <span class="n">pt_index_2</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">pt_index_1</span><span class="p">):</span>
                        <span class="n">x_j_prev</span> <span class="o">=</span> <span class="n">x_iter</span><span class="p">[</span><span class="n">pt_index_2</span><span class="p">,</span> <span class="p">:]</span>
                        <span class="n">constraints</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                            <span class="p">(</span><span class="n">x_i_prev</span> <span class="o">-</span> <span class="n">x_j_prev</span><span class="p">)</span> <span class="o">@</span> <span class="p">(</span><span class="n">x_i_prev</span> <span class="o">-</span> <span class="n">x_j_prev</span><span class="p">)</span>
                            <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="p">((</span><span class="n">x_i_prev</span> <span class="o">-</span> <span class="n">x_j_prev</span><span class="p">)</span> <span class="o">@</span> <span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">pt_index_1</span><span class="p">,</span> <span class="p">:]</span> <span class="o">-</span> <span class="n">x_i_prev</span><span class="p">))</span>
                            <span class="o">-</span> <span class="mi">2</span> <span class="o">*</span> <span class="p">((</span><span class="n">x_i_prev</span> <span class="o">-</span> <span class="n">x_j_prev</span><span class="p">)</span> <span class="o">@</span> <span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">pt_index_2</span><span class="p">,</span> <span class="p">:]</span> <span class="o">-</span> <span class="n">x_j_prev</span><span class="p">))</span>
                            <span class="o">+</span> <span class="n">pairwise_separation_slack_var</span><span class="p">[</span><span class="n">pt_index_1</span><span class="p">,</span> <span class="n">pt_index_2</span><span class="p">]</span>
                            <span class="o">&gt;=</span> <span class="n">cp</span><span class="o">.</span><span class="n">square</span><span class="p">(</span><span class="n">separation</span><span class="p">)</span>
                        <span class="p">)</span>

                    <span class="c1"># Constraint 4: Enforces the pairwise separation constraint ||x_i - e_j||^2 &gt;= r^2</span>
                    <span class="k">for</span> <span class="n">dim_index</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">dim</span><span class="p">):</span>
                        <span class="n">e_i_vector</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">dim</span><span class="p">)</span>
                        <span class="n">e_i_vector</span><span class="p">[</span><span class="n">dim_index</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
                        <span class="n">constraints</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                            <span class="p">(</span><span class="n">x_i_prev</span> <span class="o">-</span> <span class="n">e_i_vector</span><span class="p">)</span> <span class="o">@</span> <span class="p">(</span><span class="n">x_i_prev</span> <span class="o">-</span> <span class="n">e_i_vector</span><span class="p">)</span>
                            <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="n">x_i_prev</span> <span class="o">-</span> <span class="n">e_i_vector</span><span class="p">)</span> <span class="o">@</span> <span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">pt_index_1</span><span class="p">,</span> <span class="p">:]</span> <span class="o">-</span> <span class="n">x_i_prev</span><span class="p">)</span>
                            <span class="o">+</span> <span class="n">standard_vector_separation_slack_var</span><span class="p">[</span><span class="n">pt_index_1</span><span class="p">,</span> <span class="n">dim_index</span><span class="p">]</span>
                            <span class="o">&gt;=</span> <span class="n">cp</span><span class="o">.</span><span class="n">square</span><span class="p">(</span><span class="n">separation</span><span class="p">)</span>
                        <span class="p">)</span>

                    <span class="c1"># Constraint 5: Enforces the maximum norm constraint ||x_i ||_2 &lt;= 1</span>
                    <span class="n">constraints</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cast</span><span class="p">(</span><span class="n">cp</span><span class="o">.</span><span class="n">Constraint</span><span class="p">,</span> <span class="n">cp</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">pt_index_1</span><span class="p">,</span> <span class="p">:],</span> <span class="n">p</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">))</span>

                    <span class="c1"># Constraint 6: Enforces the minimum norm constraint ||x_i ||_2 &gt;= 0.8</span>
                    <span class="n">constraints</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                        <span class="n">x_i_prev</span> <span class="o">@</span> <span class="n">x_i_prev</span>
                        <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">x_i_prev</span> <span class="o">@</span> <span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">pt_index_1</span><span class="p">,</span> <span class="p">:]</span> <span class="o">-</span> <span class="n">x_i_prev</span><span class="p">)</span>
                        <span class="o">+</span> <span class="n">minimum_norm_slack_var</span><span class="p">[</span><span class="n">pt_index_1</span><span class="p">]</span>
                        <span class="o">&gt;=</span> <span class="n">SPOAUS_MINIMUM_NORM_VALUE_SQR</span>
                    <span class="p">)</span>

                <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Solving the CVXPY problem...&quot;</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">)</span>

                <span class="n">sum_slack_var</span> <span class="o">=</span> <span class="n">cast</span><span class="p">(</span>
                    <span class="n">cp</span><span class="o">.</span><span class="n">Expression</span><span class="p">,</span>
                    <span class="n">cp</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">minimum_norm_slack_var</span><span class="p">)</span>
                    <span class="o">+</span> <span class="n">cp</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">standard_vector_separation_slack_var</span><span class="p">)</span>
                    <span class="o">+</span> <span class="n">cp</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">pairwise_separation_slack_var</span><span class="p">),</span>
                <span class="p">)</span>
                <span class="n">objective</span> <span class="o">=</span> <span class="o">-</span><span class="n">separation</span> <span class="o">+</span> <span class="n">tau_iter</span> <span class="o">*</span> <span class="n">sum_slack_var</span>

                <span class="n">problem</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">Problem</span><span class="p">(</span><span class="n">cp</span><span class="o">.</span><span class="n">Minimize</span><span class="p">(</span><span class="n">objective</span><span class="p">),</span> <span class="n">constraints</span><span class="p">)</span>

                <span class="k">try</span><span class="p">:</span>
                    <span class="n">problem</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="o">**</span><span class="n">cvxpy_socp_args</span><span class="p">)</span>
                <span class="k">except</span> <span class="n">cp</span><span class="o">.</span><span class="n">error</span><span class="o">.</span><span class="n">SolverError</span> <span class="k">as</span> <span class="n">err</span><span class="p">:</span>  <span class="c1"># pyright: ignore[reportAttributeAccessIssue]</span>
                    <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span>
                        <span class="sa">f</span><span class="s2">&quot;Unable to spread points on a unit sphere! CVXPY returned error: </span><span class="si">{</span><span class="nb">str</span><span class="p">(</span><span class="n">err</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span>
                    <span class="p">)</span> <span class="kn">from</span><span class="w"> </span><span class="nn">err</span>

                <span class="k">if</span> <span class="n">problem</span><span class="o">.</span><span class="n">status</span> <span class="ow">in</span> <span class="p">[</span><span class="n">cp</span><span class="o">.</span><span class="n">OPTIMAL</span><span class="p">,</span> <span class="n">cp</span><span class="o">.</span><span class="n">OPTIMAL_INACCURATE</span><span class="p">]:</span>
                    <span class="n">cost_prev_with_new_tau_iter</span> <span class="o">=</span> <span class="o">-</span><span class="n">separation_prev</span> <span class="o">+</span> <span class="n">tau_iter</span> <span class="o">*</span> <span class="n">sum_slack_var_prev</span>
                    <span class="n">sum_slack_value</span> <span class="o">=</span> <span class="n">cast</span><span class="p">(</span><span class="nb">float</span><span class="p">,</span> <span class="n">sum_slack_var</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>
                    <span class="n">separation_value</span> <span class="o">=</span> <span class="n">cast</span><span class="p">(</span><span class="nb">float</span><span class="p">,</span> <span class="n">separation</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>
                    <span class="n">objective_value</span> <span class="o">=</span> <span class="n">cast</span><span class="p">(</span><span class="nb">float</span><span class="p">,</span> <span class="n">objective</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>
                    <span class="n">x_value</span> <span class="o">=</span> <span class="n">cast</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">x</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;done! Successfully solved.&quot;</span><span class="p">)</span>
                        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Tau: </span><span class="si">{</span><span class="n">tau_iter</span><span class="si">:</span><span class="s2">1.2f</span><span class="si">}</span><span class="s2"> (&lt; </span><span class="si">{</span><span class="n">SPOAUS_TAU_MAX</span><span class="si">:</span><span class="s2">1.2f</span><span class="si">}</span><span class="s2">)&quot;</span><span class="p">)</span>
                        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Sum of slack: </span><span class="si">{</span><span class="n">sum_slack_value</span><span class="si">:</span><span class="s2">.3e</span><span class="si">}</span><span class="s2"> (&lt; </span><span class="si">{</span><span class="n">SPOAUS_SLACK_TOLERANCE</span><span class="si">:</span><span class="s2">.3e</span><span class="si">}</span><span class="s2">)&quot;</span><span class="p">)</span>
                        <span class="nb">print</span><span class="p">(</span>
                            <span class="sa">f</span><span class="s2">&quot;Change in opt cost: </span><span class="si">{</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">objective_value</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">cost_prev_with_new_tau_iter</span><span class="p">)</span><span class="si">:</span><span class="s2">.3e</span><span class="si">}</span><span class="s2"> &quot;</span>
                            <span class="sa">f</span><span class="s2">&quot;(&lt; </span><span class="si">{</span><span class="n">SPOAUS_COST_TOLERANCE</span><span class="si">:</span><span class="s2">.3e</span><span class="si">}</span><span class="s2">)&quot;</span>
                        <span class="p">)</span>
                        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Max. change in ||x_i||_2: </span><span class="si">{</span><span class="nb">max</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">x_value</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">x_iter</span><span class="p">,</span><span class="w"> </span><span class="nb">ord</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span><span class="si">:</span><span class="s2">.3e</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
                    <span class="n">continue_condition</span> <span class="o">=</span> <span class="p">(</span>
                        <span class="n">sum_slack_value</span> <span class="o">&gt;</span> <span class="n">SPOAUS_SLACK_TOLERANCE</span>
                        <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">objective_value</span> <span class="o">-</span> <span class="n">cost_prev_with_new_tau_iter</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">SPOAUS_COST_TOLERANCE</span>
                    <span class="p">)</span> <span class="ow">and</span> <span class="n">iter_count</span> <span class="o">&lt;</span> <span class="n">MAX_ITERATIONS</span>
                    <span class="c1"># Update the values for the next iteration</span>
                    <span class="n">x_iter</span> <span class="o">=</span> <span class="n">x_value</span>
                    <span class="n">objective_value_prev</span> <span class="o">=</span> <span class="n">objective_value</span>
                    <span class="n">separation_prev</span> <span class="o">=</span> <span class="n">separation_value</span>
                    <span class="n">sum_slack_var_prev</span> <span class="o">=</span> <span class="n">sum_slack_value</span>
                    <span class="n">iter_count</span> <span class="o">+=</span> <span class="mi">1</span>
                    <span class="n">tau_iter</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">tau_iter</span> <span class="o">*</span> <span class="n">SPOAUS_SCALING_TAU</span><span class="p">,</span> <span class="n">SPOAUS_TAU_MAX</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span>
                        <span class="sa">f</span><span class="s2">&quot;Use of slack variables should have prevented problem status: </span><span class="si">{</span><span class="n">problem</span><span class="o">.</span><span class="n">status</span><span class="si">}</span><span class="s2">&quot;</span>
                    <span class="p">)</span>

            <span class="k">if</span> <span class="p">(</span>
                <span class="n">iter_count</span> <span class="o">&gt;=</span> <span class="n">MAX_ITERATIONS</span>
                <span class="ow">or</span> <span class="n">sum_slack_var_prev</span> <span class="o">&gt;</span> <span class="n">SPOAUS_SLACK_TOLERANCE</span>
                <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">objective_value_prev</span> <span class="o">-</span> <span class="n">cost_prev_with_new_tau_iter</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">SPOAUS_COST_TOLERANCE</span>
            <span class="p">):</span>
                <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;Difference of convex programming did not converge while spreading </span><span class="si">{</span><span class="n">n_points_int</span><span class="si">}</span><span class="s2"> points on a &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">dim</span><span class="si">}</span><span class="s2">-dimensional unit sphere! The convex-concave procedure parameters may need tuning.</span><span class="se">\n</span><span class="s2">&quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;iter_count &gt;= </span><span class="si">{</span><span class="n">MAX_ITERATIONS</span><span class="si">:</span><span class="s2">d</span><span class="si">}</span><span class="s2">: </span><span class="si">{</span><span class="n">iter_count</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="n">MAX_ITERATIONS</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;sum_slack_var.value &gt; </span><span class="si">{</span><span class="n">SPOAUS_SLACK_TOLERANCE</span><span class="si">:</span><span class="s2">1.2f</span><span class="si">}</span><span class="s2">: &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">sum_slack_var_prev</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">SPOAUS_SLACK_TOLERANCE</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;np.abs(objective.value - cost_prev_with_new_tau_iter) &gt; </span><span class="si">{</span><span class="n">SPOAUS_COST_TOLERANCE</span><span class="si">:</span><span class="s2">1.2f</span><span class="si">}</span><span class="s2">: &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">objective_value_prev</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">cost_prev_with_new_tau_iter</span><span class="p">)</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">SPOAUS_COST_TOLERANCE</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="p">)</span>
            <span class="n">norm_val</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">x_iter</span><span class="p">,</span> <span class="nb">ord</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">opt_locations_first_quad_without_axes</span> <span class="o">=</span> <span class="n">x_iter</span> <span class="o">/</span> <span class="n">norm_val</span>
            <span class="k">for</span> <span class="n">sign_vector</span> <span class="ow">in</span> <span class="n">itertools</span><span class="o">.</span><span class="n">product</span><span class="p">([</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">repeat</span><span class="o">=</span><span class="n">dim</span><span class="p">):</span>
                <span class="n">opt_locations</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">opt_locations</span><span class="p">,</span> <span class="n">sign_vector</span> <span class="o">*</span> <span class="n">opt_locations_first_quad_without_axes</span><span class="p">))</span>
            <span class="n">opt_locations_first_quad</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="n">dim</span><span class="p">),</span> <span class="n">opt_locations_first_quad_without_axes</span><span class="p">))</span>
            <span class="n">minimum_separation</span> <span class="o">=</span> <span class="n">separation_prev</span>

            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Completed spreading the vectors!&quot;</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Minimum separation among the points: </span><span class="si">{</span><span class="n">minimum_separation</span><span class="si">:</span><span class="s2">1.4f</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">save_points_on_a_unit_sphere</span><span class="p">:</span>  <span class="c1"># pragma: no cover</span>
                <span class="n">np</span><span class="o">.</span><span class="n">savez</span><span class="p">(</span>
                    <span class="n">save_filename</span><span class="p">,</span>
                    <span class="n">opt_locations</span><span class="o">=</span><span class="n">opt_locations</span><span class="p">,</span>
                    <span class="n">minimum_separation</span><span class="o">=</span><span class="n">minimum_separation</span><span class="p">,</span>
                    <span class="n">opt_locations_first_quad</span><span class="o">=</span><span class="n">opt_locations_first_quad</span><span class="p">,</span>
                <span class="p">)</span>
                <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Saved the computed points on a unit sphere for dim=</span><span class="si">{</span><span class="n">dim</span><span class="si">}</span><span class="s2"> and n_points=</span><span class="si">{</span><span class="n">n_points_int</span><span class="si">:</span><span class="s2">d</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">opt_locations</span><span class="p">,</span> <span class="n">minimum_separation</span><span class="p">,</span> <span class="n">opt_locations_first_quad</span></div>

</pre></div>

          </div>
          
        </div>
      </div>
    <div class="clearer"></div>
  </div>
    <div class="footer">
      &#169;2020-2026, Mitsubishi Electric Research Laboratories (MERL).
      
      |
      Powered by <a href="https://www.sphinx-doc.org/">Sphinx 9.1.0</a>
      &amp; <a href="https://alabaster.readthedocs.io">Alabaster 1.0.0</a>
      
    </div>

    

    
  </body>
</html>