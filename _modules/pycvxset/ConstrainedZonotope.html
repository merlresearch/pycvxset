<!DOCTYPE html>

<html lang="en" data-content_root="../../">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>pycvxset.ConstrainedZonotope &#8212; pycvxset 1.2.0 documentation</title>
    <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=03e43079" />
    <link rel="stylesheet" type="text/css" href="../../_static/basic.css?v=b08954a9" />
    <link rel="stylesheet" type="text/css" href="../../_static/alabaster.css?v=f6a572b4" />
    <script src="../../_static/documentation_options.js?v=6efca38a"></script>
    <script src="../../_static/doctools.js?v=fd6eb6e6"></script>
    <script src="../../_static/sphinx_highlight.js?v=6ffebe34"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
   
  <link rel="stylesheet" href="../../_static/custom.css" type="text/css" />
  

  
  

  </head><body>
  <div class="document">
    
      <div class="sphinxsidebar" role="navigation" aria-label="Main">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="../../index.html">
              <img class="logo" src="../../_static/pycvxset_logo.png" alt="Logo of pycvxset"/>
            </a></p>
<h1 class="logo"><a href="../../index.html">pycvxset</a></h1>



<p class="blurb">A Python package for manipulation and visualization of convex sets.</p>




<p>
<iframe src="https://ghbtns.com/github-btn.html?user=merlresearch&repo=pycvxset&type=star&count=true&size=large&v=2"
  allowtransparency="true" frameborder="0" scrolling="0" width="200px" height="35px"></iframe>
</p>






<search id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</search>
<script>document.getElementById('searchbox').style.display = "block"</script><!-- Copyright (C) 2020-2026 Mitsubishi Electric Research Laboratories (MERL)

SPDX-License-Identifier: AGPL-3.0-or-later

Code purpose: Custom navigation side bar for documentation website -->

</br>
<h3>Navigation</h3>
<ul>
    <li class="toctree-l1">
        <a class="reference internal" href="../../tutorials/tutorials.html">Tutorials</a>
    </li>
    <li class="toctree-l1" style="color: #444;font-size:120%">Set Representations</li>
    <ul>
        <li class="toctree-l2">
            <a class="reference internal" href="../../api_summary/pycvxset.Polytope.html">Polytope</a>
        </li>
        <li class="toctree-l2">
            <a class="reference internal" href="../../api_summary/pycvxset.Ellipsoid.html">Ellipsoid</a>
        </li>
        <li class="toctree-l2">
            <a class="reference internal"
                href="../../api_summary/pycvxset.ConstrainedZonotope.html">ConstrainedZonotope
            </a>
        </li>
    </ul>
    <li class="toctree-l1"><a class="reference internal" href="../../pycvxset.common.html">Other useful
            methods</a></li>
    <li class="toctree-l1"><a class="reference internal"
            href="../../pycvxset.common.constants.html">Constants</a></li>
    <li class="toctree-l1"><a class="reference external"
            href="https://raw.githubusercontent.com/merlresearch/pycvxset/main/MANUAL.pdf" target="_blank">Manual
            (PDF)</a></li>
    <li class="toctree-l1"><a class="reference external" href="https://www.merl.com/publications/docs/TR2025-086.pdf" target="_blank">Paper (ACC '25)
            </a></li>
    <li class="toctree-l1"><a class="reference internal" href="../../references.html">References</a></li>
</ul>
        </div>
      </div>
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <h1>Source code for pycvxset.ConstrainedZonotope</h1><div class="highlight"><pre>
<span></span><span class="c1"># Copyright (C) 2020-2026 Mitsubishi Electric Research Laboratories (MERL)</span>
<span class="c1">#</span>
<span class="c1"># SPDX-License-Identifier: AGPL-3.0-or-later</span>

<span class="c1"># Code purpose:  Define the ConstrainedZonotope class</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">__future__</span><span class="w"> </span><span class="kn">import</span> <span class="n">annotations</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">typing</span><span class="w"> </span><span class="kn">import</span> <span class="n">TYPE_CHECKING</span><span class="p">,</span> <span class="n">Any</span><span class="p">,</span> <span class="n">Literal</span><span class="p">,</span> <span class="n">Optional</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">,</span> <span class="n">cast</span><span class="p">,</span> <span class="n">overload</span>

<span class="k">if</span> <span class="n">TYPE_CHECKING</span><span class="p">:</span>
    <span class="kn">from</span><span class="w"> </span><span class="nn">pycvxset.Polytope</span><span class="w"> </span><span class="kn">import</span> <span class="n">Polytope</span>
    <span class="kn">import</span><span class="w"> </span><span class="nn">cvxpy</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">pycvxset.common</span><span class="w"> </span><span class="kn">import</span> <span class="p">(</span>
    <span class="n">_compute_project_multiple_points</span><span class="p">,</span>
    <span class="n">_compute_support_function_multiple_eta</span><span class="p">,</span>
    <span class="n">convex_set_closest_point</span><span class="p">,</span>
    <span class="n">convex_set_distance</span><span class="p">,</span>
    <span class="n">convex_set_extreme</span><span class="p">,</span>
    <span class="n">convex_set_minimum_volume_circumscribing_rectangle</span><span class="p">,</span>
    <span class="n">convex_set_project</span><span class="p">,</span>
    <span class="n">convex_set_projection</span><span class="p">,</span>
    <span class="n">convex_set_slice</span><span class="p">,</span>
    <span class="n">convex_set_slice_then_projection</span><span class="p">,</span>
    <span class="n">convex_set_support</span><span class="p">,</span>
    <span class="n">is_constrained_zonotope</span><span class="p">,</span>
    <span class="n">is_polytope</span><span class="p">,</span>
    <span class="n">minimize</span><span class="p">,</span>
    <span class="n">plot_polytopic_approximation</span><span class="p">,</span>
    <span class="n">sanitize_Aebe</span><span class="p">,</span>
    <span class="n">sanitize_Gc</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">pycvxset.common.constants</span><span class="w"> </span><span class="kn">import</span> <span class="n">DEFAULT_CVXPY_ARGS_LP</span><span class="p">,</span> <span class="n">DEFAULT_CVXPY_ARGS_SOCP</span><span class="p">,</span> <span class="n">PYCVXSET_ZERO</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">pycvxset.common.polytope_approximations</span><span class="w"> </span><span class="kn">import</span> <span class="n">polytopic_inner_approximation</span><span class="p">,</span> <span class="n">polytopic_outer_approximation</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">pycvxset.ConstrainedZonotope.operations_binary</span><span class="w"> </span><span class="kn">import</span> <span class="p">(</span>
    <span class="n">DOCSTRING_FOR_PROJECT</span><span class="p">,</span>
    <span class="n">DOCSTRING_FOR_PROJECTION</span><span class="p">,</span>
    <span class="n">DOCSTRING_FOR_SLICE</span><span class="p">,</span>
    <span class="n">DOCSTRING_FOR_SLICE_THEN_PROJECTION</span><span class="p">,</span>
    <span class="n">DOCSTRING_FOR_SUPPORT</span><span class="p">,</span>
    <span class="n">affine_map</span><span class="p">,</span>
    <span class="n">approximate_pontryagin_difference</span><span class="p">,</span>
    <span class="n">cartesian_product</span><span class="p">,</span>
    <span class="n">contains</span><span class="p">,</span>
    <span class="n">intersection</span><span class="p">,</span>
    <span class="n">intersection_under_inverse_affine_map</span><span class="p">,</span>
    <span class="n">intersection_with_affine_set</span><span class="p">,</span>
    <span class="n">intersection_with_halfspaces</span><span class="p">,</span>
    <span class="n">inverse_affine_map_under_invertible_matrix</span><span class="p">,</span>
    <span class="n">minus</span><span class="p">,</span>
    <span class="n">plus</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">pycvxset.ConstrainedZonotope.operations_unary</span><span class="w"> </span><span class="kn">import</span> <span class="p">(</span>
    <span class="n">chebyshev_centering</span><span class="p">,</span>
    <span class="n">interior_point</span><span class="p">,</span>
    <span class="n">maximum_volume_inscribing_ellipsoid</span><span class="p">,</span>
    <span class="n">remove_redundancies</span><span class="p">,</span>
<span class="p">)</span>


<div class="viewcode-block" id="ConstrainedZonotope">
<a class="viewcode-back" href="../../pycvxset.ConstrainedZonotope.html#pycvxset.ConstrainedZonotope">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">ConstrainedZonotope</span><span class="p">:</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Constrained zonotope class</span>

<span class="sd">    Constrained zonotope defines a polytope in the working dimension :math:`\mathbb{R}^n` as an affine transformation of</span>
<span class="sd">    a polytope defined in latent space :math:`B_\infty(A_e, b_e)\subset \mathbb{R}^{N_C}`. Here, :math:`B_\infty(A_e,</span>
<span class="sd">    b_e)` is defined as the intersection of a unit :math:`\ell_\infty`-norm ball and a collection of :math:`M_C` linear</span>
<span class="sd">    constraints :math:`\{\xi\in\mathbb{R}^{N_C}|A_e \xi = b_e\}.`</span>

<span class="sd">    Formally, a **constrained zonotope** is defined as follows,</span>

<span class="sd">    .. math::</span>
<span class="sd">            \mathcal{C} = \{G \xi + c\ |\ \xi \in B_\infty(A_e, b_e)\} \subset \mathbb{R}^n,</span>

<span class="sd">    where</span>

<span class="sd">    .. math::</span>
<span class="sd">            B_\infty(A_e, b_e)= \{\xi\ |\ \| \xi \|_\infty \leq 1, A_e \xi = b_e\} \subset \mathbb{R}^{N_C},</span>

<span class="sd">    with :math:`G\in\mathbb{R}^{n\times N_C}`, :math:`c\in\mathbb{R}^{n}`, :math:`A_e\in\mathbb{R}^{M_C\times N_C}`, and</span>
<span class="sd">    :math:`b\in\mathbb{R}^{M_C}`.</span>

<span class="sd">    A constrained zonotope provide an alternative and equivalent representation of any</span>
<span class="sd">    convex and compact polytope.  Furthermore, a constrained zonotope admits closed-form expressions for several set</span>
<span class="sd">    manipulations that can often be accomplished without invoking any optimization solvers. See [SDGR16]_ [RK22]_</span>
<span class="sd">    [VWD24]_ for more details.</span>

<span class="sd">    A **zonotope** is a special class of constrained zonotopes, and are defined as</span>

<span class="sd">    .. math::</span>
<span class="sd">            \mathcal{Z} = \{G \xi + c\ |\ \|\xi\|_\infty \leq 1\} \subset \mathbb{R}^n.</span>

<span class="sd">    In other words, a zonotope is a constrained zonotope with no equality constraints in the latent dimension space. In</span>
<span class="sd">    :class:`ConstrainedZonotope`, we model zonotopes by having (Ae,be) be empty (n\_equalities is zero).</span>

<span class="sd">    Constrained zonotope object construction admits **one** of the following combinations (as keyword arguments):</span>

<span class="sd">    #. dim for an **empty** constrained zonotope of dimension dim,</span>
<span class="sd">    #. (G, c, Ae, be) for a **constrained zonotope**,</span>
<span class="sd">    #. (G, c) for a **zonotope**,</span>
<span class="sd">    #. (lb, ub) for a **zonotope** equivalent to an **axis-aligned cuboid** with appropriate bounds :math:`\{x\ |\</span>
<span class="sd">       lb\leq x \leq ub\}`, and</span>
<span class="sd">    #. (c, h) for a **zonotope** equivalent to an **axis-aligned cuboid** centered at c with specified</span>
<span class="sd">       scalar/vector half-sides :math:`h`, :math:`\{x\ |\ \forall i\in\{1,2,...,n\}, |x_i - c_i| \leq h_i\}`.</span>
<span class="sd">    #. (c=p, G=None) for a **zonotope** equivalent to a **single point** p,</span>
<span class="sd">    #. P for a **constrained zonotope** equivalent to the :class:`pycvxset.Polytope.Polytope` object P,</span>

<span class="sd">    Args:</span>
<span class="sd">        dim (int, optional): Dimension of the empty constrained zonotope. If NOTHING is provided, dim=0 is assumed.</span>
<span class="sd">        c (Sequence[float] | numpy.ndarray, optional): Affine transformation translation vector. Must be 1D array, and</span>
<span class="sd">            the constrained zonotope dimension is determined by number of elements in c. When c is provided, either (G)</span>
<span class="sd">            or (G, Ae, be) or (h) must be provided additionally. When h is provided, c is the centroid of the resulting</span>
<span class="sd">            zonotope.</span>
<span class="sd">        G (Sequence[Sequence[float]] | numpy.ndarray):  Affine transformation matrix. The vectors are stacked vertically</span>
<span class="sd">            with matching number of rows as c. When G is provided, (c, Ae, be) OR (c) must also be provided. To define a</span>
<span class="sd">            constrained zonotope with a single point, set c to the point AND G to None (do not set (Ae, be) or set them</span>
<span class="sd">            to (None, None)).</span>
<span class="sd">        Ae (Sequence[Sequence[float]] | numpy.ndarray):  Equality coefficient vectors. The vectors are stacked</span>
<span class="sd">            vertically with matching number of columns as G. When Ae is provided, (G, c, be) must also be provided.</span>
<span class="sd">        be (Sequence[float] | numpy.ndarray):  Equality coefficient constants. The constants are expected to be in a 1D</span>
<span class="sd">            numpy array. When be is provided, (G, c, Ae) must also be provided.</span>
<span class="sd">        lb (Sequence[float] | numpy.ndarray, optional): Lower bounds of the axis-aligned cuboid. Must be 1D array, and</span>
<span class="sd">            the constrained zonotope dimension is determined by number of elements in lb. When lb is provided, ub must</span>
<span class="sd">            also be provided.</span>
<span class="sd">        ub (Sequence[float] | numpy.ndarray, optional): Upper bounds of the axis-aligned cuboid. Must be 1D array of</span>
<span class="sd">            length as same as lb.  When ub is provided, lb must also be provided.</span>
<span class="sd">        h (float | Sequence[float] | numpy.ndarray, optional): Half-side length of the axis-aligned cuboid. Can be a</span>
<span class="sd">            scalar or a vector of length as same as c. When h is provided, c must also be provided.</span>
<span class="sd">        polytope (Polytope, optional): Polytope to use to construct constrained zonotope.</span>

<span class="sd">    Raises:</span>
<span class="sd">        ValueError: (G, c) is not compatible.</span>
<span class="sd">        ValueError: (G, c, Ae, be) is not compatible.</span>
<span class="sd">        ValueError: (lb, ub) is not valid</span>
<span class="sd">        ValueError: (c, h) is not valid</span>
<span class="sd">        ValueError: Provided polytope is not bounded.</span>
<span class="sd">        UserWarning: When a row with all zeros in Ae and be.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="n">TYPE_CHECKING</span><span class="p">:</span>

        <span class="nd">@overload</span>
        <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span> <span class="o">...</span>

        <span class="nd">@overload</span>
        <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">dim</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span> <span class="o">...</span>

        <span class="nd">@overload</span>
        <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">G</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">Sequence</span><span class="p">[</span><span class="nb">float</span><span class="p">]]</span> <span class="o">|</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">|</span> <span class="kc">None</span><span class="p">,</span> <span class="n">c</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">|</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span>
        <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span> <span class="o">...</span>

        <span class="nd">@overload</span>
        <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="o">*</span><span class="p">,</span>
            <span class="n">G</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">Sequence</span><span class="p">[</span><span class="nb">float</span><span class="p">]]</span> <span class="o">|</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">|</span> <span class="kc">None</span><span class="p">,</span>
            <span class="n">c</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">|</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
            <span class="n">Ae</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">Sequence</span><span class="p">[</span><span class="nb">float</span><span class="p">]]</span> <span class="o">|</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
            <span class="n">be</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">|</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
        <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span> <span class="o">...</span>

        <span class="nd">@overload</span>
        <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">lb</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">|</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">ub</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">|</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span> <span class="o">...</span>

        <span class="nd">@overload</span>
        <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="o">*</span><span class="p">,</span>
            <span class="n">c</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">|</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
            <span class="n">h</span><span class="p">:</span> <span class="nb">float</span> <span class="o">|</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">|</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
        <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span> <span class="o">...</span>

        <span class="nd">@overload</span>
        <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">polytope</span><span class="p">:</span> <span class="s2">&quot;Polytope&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span> <span class="o">...</span>

<div class="viewcode-block" id="ConstrainedZonotope.__init__">
<a class="viewcode-back" href="../../pycvxset.ConstrainedZonotope.html#pycvxset.ConstrainedZonotope.__init__">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">:</span> <span class="n">Any</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Constructor for ConstrainedZonotope class&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_type_of_set</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;ConstrainedZonotope&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_G</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_c</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_Ae</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_be</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_is_full_dimensional</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_is_empty</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_is_singleton</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="c1"># These attributes are used by CVXPY to solve problems</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_cvxpy_args_lp</span> <span class="o">=</span> <span class="n">DEFAULT_CVXPY_ARGS_LP</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_cvxpy_args_socp</span> <span class="o">=</span> <span class="n">DEFAULT_CVXPY_ARGS_SOCP</span>

        <span class="c1"># Check how the constructor was called.</span>
        <span class="n">empty_constrained_zonotope_passed</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;dim&quot;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">)</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">kwargs</span>
        <span class="n">lb_and_ub_passed</span> <span class="o">=</span> <span class="nb">all</span><span class="p">(</span><span class="n">kw</span> <span class="ow">in</span> <span class="n">kwargs</span> <span class="k">for</span> <span class="n">kw</span> <span class="ow">in</span> <span class="p">(</span><span class="s2">&quot;lb&quot;</span><span class="p">,</span> <span class="s2">&quot;ub&quot;</span><span class="p">))</span>
        <span class="n">c_and_h_passed</span> <span class="o">=</span> <span class="nb">all</span><span class="p">(</span><span class="n">kw</span> <span class="ow">in</span> <span class="n">kwargs</span> <span class="k">for</span> <span class="n">kw</span> <span class="ow">in</span> <span class="p">(</span><span class="s2">&quot;c&quot;</span><span class="p">,</span> <span class="s2">&quot;h&quot;</span><span class="p">))</span>
        <span class="n">G_and_c_passed</span> <span class="o">=</span> <span class="nb">all</span><span class="p">(</span><span class="n">k</span> <span class="ow">in</span> <span class="n">kwargs</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="p">(</span><span class="s2">&quot;G&quot;</span><span class="p">,</span> <span class="s2">&quot;c&quot;</span><span class="p">))</span>
        <span class="n">Ae_and_be_passed</span> <span class="o">=</span> <span class="nb">all</span><span class="p">(</span><span class="n">k</span> <span class="ow">in</span> <span class="n">kwargs</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="p">(</span><span class="s2">&quot;Ae&quot;</span><span class="p">,</span> <span class="s2">&quot;be&quot;</span><span class="p">))</span>
        <span class="n">polytope_passed</span> <span class="o">=</span> <span class="s2">&quot;polytope&quot;</span> <span class="ow">in</span> <span class="n">kwargs</span>

        <span class="c1"># Set _G, _c, _Ae, _be, _is_empty, _is_full_dimensional</span>
        <span class="k">if</span> <span class="n">empty_constrained_zonotope_passed</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Cannot set dimension dim with other arguments&quot;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">dim</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;dim&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_G</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_c</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_Ae</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_be</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_Gc_Aebe_for_empty_constrained_zonotope</span><span class="p">(</span><span class="n">dim</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_is_full_dimensional</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_empty</span> <span class="o">=</span> <span class="p">(</span><span class="n">dim</span> <span class="o">==</span> <span class="mi">0</span><span class="p">),</span> <span class="kc">True</span>
        <span class="k">elif</span> <span class="n">lb_and_ub_passed</span> <span class="ow">or</span> <span class="n">c_and_h_passed</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">lb_and_ub_passed</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Cannot set bounds (lb, ub) with other arguments&quot;</span><span class="p">)</span>
                <span class="n">lb</span><span class="p">,</span> <span class="n">ub</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;lb&quot;</span><span class="p">),</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;ub&quot;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>  <span class="c1"># We have c_and_h_passed is True</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Cannot set up constrained zonotope from (c, h) with other arguments&quot;</span><span class="p">)</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">c</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;c&quot;</span><span class="p">)))</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span>
                    <span class="n">h</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;h&quot;</span><span class="p">))</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span>
                <span class="k">except</span> <span class="p">(</span><span class="ne">TypeError</span><span class="p">,</span> <span class="ne">ValueError</span><span class="p">)</span> <span class="k">as</span> <span class="n">err</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                        <span class="s2">&quot;Expected c and h to be convertible into a numpy 1D array and scalar/1D array of &quot;</span>
                        <span class="sa">f</span><span class="s2">&quot;float respectively! Got c: </span><span class="si">{</span><span class="n">np</span><span class="o">.</span><span class="n">array2string</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;c&#39;</span><span class="p">)))</span><span class="si">}</span><span class="s2"> and &quot;</span>
                        <span class="sa">f</span><span class="s2">&quot;h: </span><span class="si">{</span><span class="n">np</span><span class="o">.</span><span class="n">array2string</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;h&#39;</span><span class="p">)))</span><span class="si">}</span><span class="s2">&quot;</span>
                    <span class="p">)</span> <span class="kn">from</span><span class="w"> </span><span class="nn">err</span>
                <span class="k">if</span> <span class="n">c</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&gt;=</span> <span class="mi">2</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                        <span class="sa">f</span><span class="s2">&quot;Expected c to be a 1-dimensional array-like object! Got c: </span><span class="si">{</span><span class="n">np</span><span class="o">.</span><span class="n">array2string</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">c</span><span class="p">))</span><span class="si">}</span><span class="s2">.&quot;</span>
                    <span class="p">)</span>
                <span class="k">if</span> <span class="n">h</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&gt;=</span> <span class="mi">2</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                        <span class="s2">&quot;Expected h to be a 0-dimensional or 1-dimensional array-like object &quot;</span>
                        <span class="sa">f</span><span class="s2">&quot;Got </span><span class="si">{</span><span class="n">np</span><span class="o">.</span><span class="n">array2string</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">h</span><span class="p">))</span><span class="si">}</span><span class="s2">.&quot;</span>
                    <span class="p">)</span>
                <span class="k">elif</span> <span class="n">h</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">h</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="n">c</span><span class="o">.</span><span class="n">shape</span><span class="p">:</span>
                        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                            <span class="s2">&quot;Expected c and 1-dimensional h to match in dimensions. Got </span><span class="si">{c.shape}</span><span class="s2"> and </span><span class="si">{h.shape}</span><span class="s2">&quot;</span>
                        <span class="p">)</span>
                    <span class="n">lb</span> <span class="o">=</span> <span class="n">c</span> <span class="o">-</span> <span class="n">h</span>
                    <span class="n">ub</span> <span class="o">=</span> <span class="n">c</span> <span class="o">+</span> <span class="n">h</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">lb</span> <span class="o">=</span> <span class="n">c</span> <span class="o">-</span> <span class="n">h</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">ones_like</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
                    <span class="n">ub</span> <span class="o">=</span> <span class="n">c</span> <span class="o">+</span> <span class="n">h</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">ones_like</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_G</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_c</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_Ae</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_be</span><span class="p">,</span> <span class="n">lb</span><span class="p">,</span> <span class="n">ub</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_Gc_Aebe_from_bounds</span><span class="p">(</span><span class="n">lb</span><span class="p">,</span> <span class="n">ub</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_is_full_dimensional</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">ub</span> <span class="o">-</span> <span class="n">lb</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">PYCVXSET_ZERO</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_is_empty</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">c</span> <span class="ow">is</span> <span class="kc">None</span>
        <span class="k">elif</span> <span class="n">G_and_c_passed</span><span class="p">:</span>
            <span class="c1"># Either it is a zonotope (G, c) or a constrained zonotope (G, c, Ae, be)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">2</span> <span class="ow">and</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">4</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">Ae_and_be_passed</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;Cannot set zonotope (G, c) or constrained zonotope (G, c, Ae, be) with other arguments&quot;</span>
                <span class="p">)</span>
            <span class="n">G_val</span><span class="p">,</span> <span class="n">c_val</span> <span class="o">=</span> <span class="n">sanitize_Gc</span><span class="p">(</span><span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;G&quot;</span><span class="p">),</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;c&quot;</span><span class="p">))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_G</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_c</span> <span class="o">=</span> <span class="n">G_val</span><span class="p">,</span> <span class="n">c_val</span>
            <span class="k">if</span> <span class="n">Ae_and_be_passed</span><span class="p">:</span>
                <span class="n">sanitized_Ae</span><span class="p">,</span> <span class="n">sanitized_be</span> <span class="o">=</span> <span class="n">sanitize_Aebe</span><span class="p">(</span><span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;Ae&quot;</span><span class="p">),</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;be&quot;</span><span class="p">))</span>
                <span class="k">if</span> <span class="n">G_val</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="p">(</span><span class="n">sanitized_Ae</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">sanitized_be</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">):</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;When G is None and (Ae, be) was passed, then (Ae, be) must be (None, None)!&quot;</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">sanitized_Ae</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">_Ae</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_be</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dim</span><span class="p">)),</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="mi">0</span><span class="p">,))</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">_Ae</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_be</span> <span class="o">=</span> <span class="n">sanitized_Ae</span><span class="p">,</span> <span class="n">sanitized_be</span>
                        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">Ae</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">latent_dim</span><span class="p">:</span>  <span class="c1"># Check if (Ae, be) and (A, b) can go together?</span>
                            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                                <span class="sa">f</span><span class="s2">&quot;Expected Ae to have </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">latent_dim</span><span class="si">:</span><span class="s2">d</span><span class="si">}</span><span class="s2"> number of columns. Got Ae.shape: &quot;</span>
                                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">Ae</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2">!&quot;</span>
                            <span class="p">)</span>
                    <span class="c1"># ConstrainedZonotope emptiness and full-dimensionality needs to be confirmed</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Zonotope =&gt; Set only (Ae, be) to empty | Full-dimensionality needs to be confirmed</span>
                <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_Ae</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_be</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_Gc_Aebe_for_empty_constrained_zonotope</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dim</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">latent_dim</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_is_empty</span> <span class="o">=</span> <span class="n">c_val</span> <span class="ow">is</span> <span class="kc">None</span>
                <span class="k">if</span> <span class="n">G_val</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_empty</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_is_full_dimensional</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dim</span> <span class="o">==</span> <span class="mi">1</span>
        <span class="k">elif</span> <span class="n">polytope_passed</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Cannot construct constrained zonotope from polytope if other arguments are provided&quot;</span><span class="p">)</span>
            <span class="n">polytope</span><span class="p">:</span> <span class="n">Polytope</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;polytope&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">polytope</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">is_polytope</span><span class="p">(</span><span class="n">polytope</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Expected a polytope when constructing a constrained zonotope.&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_is_full_dimensional</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_empty</span> <span class="o">=</span> <span class="n">polytope</span><span class="o">.</span><span class="n">is_full_dimensional</span><span class="p">,</span> <span class="n">polytope</span><span class="o">.</span><span class="n">is_empty</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">polytope</span><span class="o">.</span><span class="n">is_bounded</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Expected a convex and compact polytope!&quot;</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">polytope</span><span class="o">.</span><span class="n">is_empty</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_G</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_c</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_Ae</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_be</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_Gc_Aebe_for_empty_constrained_zonotope</span><span class="p">(</span><span class="n">polytope</span><span class="o">.</span><span class="n">dim</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">polytope</span><span class="o">.</span><span class="n">in_H_rep</span><span class="p">:</span>
                    <span class="c1"># Compute zonotope Z_0 ={G \xi + c| ||\xi||_\infty \leq 1, \xi\in R^n_g} s.t. polytope &lt;= Z_0.</span>
                    <span class="n">lb</span><span class="p">,</span> <span class="n">ub</span> <span class="o">=</span> <span class="n">polytope</span><span class="o">.</span><span class="n">minimum_volume_circumscribing_rectangle</span><span class="p">()</span>
                    <span class="n">Z_0</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="n">lb</span><span class="o">=</span><span class="n">lb</span><span class="p">,</span> <span class="n">ub</span><span class="o">=</span><span class="n">ub</span><span class="p">)</span>

                    <span class="c1"># sigma satisfies sigma &lt;= H z &lt;= k for all z \in polytope where H is polytope.A (using Scott&#39;s</span>
                    <span class="c1"># notation in the paper [SDGR16]_)</span>
                    <span class="n">H</span> <span class="o">=</span> <span class="n">polytope</span><span class="o">.</span><span class="n">A</span>
                    <span class="n">sigma</span><span class="p">,</span> <span class="n">k</span> <span class="o">=</span> <span class="o">-</span><span class="n">polytope</span><span class="o">.</span><span class="n">support</span><span class="p">(</span><span class="o">-</span><span class="n">H</span><span class="p">)[</span><span class="mi">0</span><span class="p">],</span> <span class="n">polytope</span><span class="o">.</span><span class="n">b</span>

                    <span class="c1"># Implement (21) from Scott&#39;s paper (with additional equality constraints when needed)</span>
                    <span class="n">latent_dim</span> <span class="o">=</span> <span class="n">Z_0</span><span class="o">.</span><span class="n">dim</span> <span class="o">+</span> <span class="n">polytope</span><span class="o">.</span><span class="n">n_halfspaces</span>
                    <span class="n">G</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">Z_0</span><span class="o">.</span><span class="n">G</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">Z_0</span><span class="o">.</span><span class="n">dim</span><span class="p">,</span> <span class="n">latent_dim</span> <span class="o">-</span> <span class="n">Z_0</span><span class="o">.</span><span class="n">dim</span><span class="p">))))</span>
                    <span class="n">c</span> <span class="o">=</span> <span class="n">Z_0</span><span class="o">.</span><span class="n">c</span>
                    <span class="n">Ae</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">H</span> <span class="o">@</span> <span class="n">Z_0</span><span class="o">.</span><span class="n">G</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">((</span><span class="n">sigma</span> <span class="o">-</span> <span class="n">k</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)))</span>
                    <span class="n">be</span> <span class="o">=</span> <span class="p">(</span><span class="n">sigma</span> <span class="o">+</span> <span class="n">k</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">-</span> <span class="p">(</span><span class="n">H</span> <span class="o">@</span> <span class="n">Z_0</span><span class="o">.</span><span class="n">c</span><span class="p">)</span>

                    <span class="k">if</span> <span class="n">polytope</span><span class="o">.</span><span class="n">n_equalities</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="c1"># Define CZ and unpack relevant members</span>
                        <span class="n">CZ</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="n">G</span><span class="o">=</span><span class="n">G</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="n">c</span><span class="p">,</span> <span class="n">Ae</span><span class="o">=</span><span class="n">Ae</span><span class="p">,</span> <span class="n">be</span><span class="o">=</span><span class="n">be</span><span class="p">)</span><span class="o">.</span><span class="n">intersection_with_affine_set</span><span class="p">(</span>
                            <span class="n">Ae</span><span class="o">=</span><span class="n">polytope</span><span class="o">.</span><span class="n">Ae</span><span class="p">,</span> <span class="n">be</span><span class="o">=</span><span class="n">polytope</span><span class="o">.</span><span class="n">be</span>
                        <span class="p">)</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">_G</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_c</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_Ae</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_be</span> <span class="o">=</span> <span class="n">CZ</span><span class="o">.</span><span class="n">G</span><span class="p">,</span> <span class="n">CZ</span><span class="o">.</span><span class="n">c</span><span class="p">,</span> <span class="n">CZ</span><span class="o">.</span><span class="n">Ae</span><span class="p">,</span> <span class="n">CZ</span><span class="o">.</span><span class="n">be</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">_G</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_c</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_Ae</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_be</span> <span class="o">=</span> <span class="n">G</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">Ae</span><span class="p">,</span> <span class="n">be</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">polytope</span><span class="o">.</span><span class="n">n_vertices</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">_G</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_Ae</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_be</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_Gc_Aebe_for_empty_constrained_zonotope</span><span class="p">(</span>
                            <span class="n">polytope</span><span class="o">.</span><span class="n">dim</span><span class="p">,</span> <span class="mi">0</span>
                        <span class="p">)</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">_c</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">polytope</span><span class="o">.</span><span class="n">V</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="c1"># Define a ConstrainedZonotope object corresponding to the polytope.n_vertices-dimension simplex</span>
                        <span class="n">CZ_simplex</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span>
                            <span class="n">lb</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">polytope</span><span class="o">.</span><span class="n">n_vertices</span><span class="p">,</span> <span class="mi">1</span><span class="p">)),</span> <span class="n">ub</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="n">polytope</span><span class="o">.</span><span class="n">n_vertices</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
                        <span class="p">)</span><span class="o">.</span><span class="n">intersection_with_affine_set</span><span class="p">(</span><span class="n">Ae</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="n">polytope</span><span class="o">.</span><span class="n">n_vertices</span><span class="p">)),</span> <span class="n">be</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
                        <span class="c1"># CZ of interest is the affine transformation of the simplex</span>
                        <span class="n">CZ</span> <span class="o">=</span> <span class="n">polytope</span><span class="o">.</span><span class="n">V</span><span class="o">.</span><span class="n">T</span> <span class="o">@</span> <span class="n">CZ_simplex</span>
                        <span class="c1"># Unpack relevant members</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">_G</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_c</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_Ae</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_be</span> <span class="o">=</span> <span class="n">CZ</span><span class="o">.</span><span class="n">G</span><span class="p">,</span> <span class="n">CZ</span><span class="o">.</span><span class="n">c</span><span class="p">,</span> <span class="n">CZ</span><span class="o">.</span><span class="n">Ae</span><span class="p">,</span> <span class="n">CZ</span><span class="o">.</span><span class="n">be</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Got invalid arguments while defining a constrained zonotope. Please specify either (G, c) or &quot;</span>
                <span class="s2">&quot;(G, c, Ae, be) or (lb, ub) or (c, h) or polytope or dim or NOTHING.&quot;</span>
            <span class="p">)</span></div>


    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">type_of_set</span><span class="p">(</span><span class="bp">self</span><span class="p">:</span> <span class="n">ConstrainedZonotope</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return the type of set</span>

<span class="sd">        Returns:</span>
<span class="sd">            str: Type of the set</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_type_of_set</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_get_Gc_Aebe_for_empty_constrained_zonotope</span><span class="p">(</span>
        <span class="n">dim</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">latent_dim</span><span class="p">:</span> <span class="nb">int</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]:</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="n">dim</span><span class="p">,</span> <span class="n">latent_dim</span><span class="p">)),</span> <span class="kc">None</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="n">latent_dim</span><span class="p">)),</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="mi">0</span><span class="p">,))</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_get_Gc_Aebe_from_bounds</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">lb</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">|</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">ub</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">|</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">Optional</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]:</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Define a zonotope from bounds (lb, ub), i.e., a zonotope that is equivalent to the polytope defined from the</span>
<span class="sd">        bounds (lb, ub).</span>

<span class="sd">        Args:</span>
<span class="sd">            lb (Sequence[float] | numpy.ndarray): Lower bound of the constrained zonotope.</span>
<span class="sd">            ub (Sequence[float] | numpy.ndarray): Upper bound of the constrained zonotope.</span>

<span class="sd">        Raises:</span>
<span class="sd">            ValueError: Mismatch in lb, ub shape</span>
<span class="sd">            ValueError: lb, ub is not convertible into 1D numpy float arrays</span>

<span class="sd">        Notes:</span>
<span class="sd">            When :math:`lb_i &gt; ub_i` for any :math:`i`, then the zonotope is empty. Otherwise, we uses the following</span>
<span class="sd">            simple manipulations to define a zonotope from the bounds lb, ub:</span>

<span class="sd">            .. math ::</span>
<span class="sd">                newobj  &amp;= {x\ |\ lb \leq x \leq ub}\\</span>
<span class="sd">                        &amp;= {x\ |\ - (ub - lb)/2 \leq x - (ub + lb)/2 \leq + (ub - lb)/2}\\</span>
<span class="sd">                        &amp;= {x\ |\ - d \leq x - c \leq d}\\</span>
<span class="sd">                        &amp;= {x\ |\ -1 \leq diag(1./d)(x - c) \leq 1}\\</span>
<span class="sd">                        &amp;= {diag(d)z + c\ |\ -1 \leq z \leq 1}</span>

<span class="sd">            Embedded zonotopes (some dimension is held constant) also have their latent dimension equal to set</span>
<span class="sd">            dimension.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">lb_arr</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">lb</span><span class="p">))</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span>
            <span class="n">ub_arr</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">ub</span><span class="p">))</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span>
        <span class="k">except</span> <span class="p">(</span><span class="ne">TypeError</span><span class="p">,</span> <span class="ne">ValueError</span><span class="p">)</span> <span class="k">as</span> <span class="n">err</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Expected lb, ub to convertible into 1D float numpy arrays&quot;</span><span class="p">)</span> <span class="kn">from</span><span class="w"> </span><span class="nn">err</span>
        <span class="k">if</span> <span class="n">lb_arr</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="n">ub_arr</span><span class="o">.</span><span class="n">shape</span> <span class="ow">or</span> <span class="n">lb_arr</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Expected lb, ub to 1D numpy arrays of same shape&quot;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">ub_arr</span> <span class="o">&lt;</span> <span class="n">lb_arr</span><span class="p">):</span>
            <span class="k">return</span> <span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">_get_Gc_Aebe_for_empty_constrained_zonotope</span><span class="p">(</span><span class="n">lb_arr</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">0</span><span class="p">),</span> <span class="n">lb_arr</span><span class="p">,</span> <span class="n">ub_arr</span>
        <span class="k">elif</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">lb_arr</span><span class="p">,</span> <span class="n">ub_arr</span><span class="p">):</span>
            <span class="n">G</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">Ae</span><span class="p">,</span> <span class="n">be</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_Gc_Aebe_for_empty_constrained_zonotope</span><span class="p">(</span><span class="n">lb_arr</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">0</span><span class="p">)</span>
            <span class="n">c</span> <span class="o">=</span> <span class="n">lb_arr</span>
            <span class="k">return</span> <span class="n">G</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">Ae</span><span class="p">,</span> <span class="n">be</span><span class="p">,</span> <span class="n">lb_arr</span><span class="p">,</span> <span class="n">ub_arr</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">dim</span><span class="p">,</span> <span class="n">latent_dim</span> <span class="o">=</span> <span class="n">lb_arr</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">lb_arr</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">Ae</span><span class="p">,</span> <span class="n">be</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_Gc_Aebe_for_empty_constrained_zonotope</span><span class="p">(</span><span class="n">dim</span><span class="p">,</span> <span class="n">latent_dim</span><span class="p">)</span>
            <span class="n">d</span> <span class="o">=</span> <span class="p">(</span><span class="n">ub_arr</span> <span class="o">-</span> <span class="n">lb_arr</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span>
            <span class="n">G</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
            <span class="n">c</span> <span class="o">=</span> <span class="p">(</span><span class="n">lb_arr</span> <span class="o">+</span> <span class="n">ub_arr</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span>
            <span class="k">return</span> <span class="n">G</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">Ae</span><span class="p">,</span> <span class="n">be</span><span class="p">,</span> <span class="n">lb_arr</span><span class="p">,</span> <span class="n">ub_arr</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">dim</span><span class="p">(</span><span class="bp">self</span><span class="p">:</span> <span class="n">ConstrainedZonotope</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Dimension of the constrained zonotope.</span>

<span class="sd">        Returns:</span>
<span class="sd">            int: Dimension of the constrained zonotope.</span>

<span class="sd">        Notes:</span>
<span class="sd">            We determine dimension from G, since c is set to None in case of empty (constrained) zonotope.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">G</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">c</span><span class="p">(</span><span class="bp">self</span><span class="p">:</span> <span class="n">ConstrainedZonotope</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Affine transformation vector c for the constrained zonotope.</span>

<span class="sd">        Returns:</span>
<span class="sd">            numpy.ndarray: Affine transformation vector c.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_c</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">G</span><span class="p">(</span><span class="bp">self</span><span class="p">:</span> <span class="n">ConstrainedZonotope</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Affine transformation matrix G for the constrained zonotope.</span>

<span class="sd">        Returns:</span>
<span class="sd">            numpy.ndarray: Affine transformation matrix G.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_G</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">latent_dim</span><span class="p">(</span><span class="bp">self</span><span class="p">:</span> <span class="n">ConstrainedZonotope</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Latent dimension of the constrained zonotope.</span>

<span class="sd">        Returns:</span>
<span class="sd">            int: Latent dimension of the constrained zonotope.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">G</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">G</span><span class="o">.</span><span class="n">size</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="mi">0</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">Ae</span><span class="p">(</span><span class="bp">self</span><span class="p">:</span> <span class="n">ConstrainedZonotope</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Equality coefficient vectors Ae for the constrained zonotope.</span>

<span class="sd">        Returns:</span>
<span class="sd">            numpy.ndarray: Equality coefficient vectors Ae for the constrained zonotope. Ae is np.empty((0,</span>
<span class="sd">            self.latent_dim)) for a zonotope.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_Ae</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">be</span><span class="p">(</span><span class="bp">self</span><span class="p">:</span> <span class="n">ConstrainedZonotope</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Equality constants be for the constrained zonotope.</span>

<span class="sd">        Returns:</span>
<span class="sd">            numpy.ndarray: Equality constants be for the constrained zonotope. be is np.empty((0,)) for a zonotope.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_be</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">He</span><span class="p">(</span><span class="bp">self</span><span class="p">:</span> <span class="n">ConstrainedZonotope</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Equality constraints `He=[Ae, be]` for the constrained zonotope.</span>

<span class="sd">        Returns:</span>
<span class="sd">            numpy.ndarray: H-Rep in [Ae, be]. He is np.empty((0, self.latent_dim + 1)) for a zonotope.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">Ae</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">be</span><span class="p">])</span><span class="o">.</span><span class="n">T</span><span class="p">))</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">n_equalities</span><span class="p">(</span><span class="bp">self</span><span class="p">:</span> <span class="n">ConstrainedZonotope</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Number of equality constraints used when defining the constrained zonotope.</span>

<span class="sd">        Returns:</span>
<span class="sd">            int: Number of equality constraints used when defining the constrained zonotope</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Ae</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">is_bounded</span><span class="p">(</span><span class="bp">self</span><span class="p">:</span> <span class="n">ConstrainedZonotope</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Check if the constrained zonotope is bounded (which is always True)&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="kc">True</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">is_empty</span><span class="p">(</span><span class="bp">self</span><span class="p">:</span> <span class="n">ConstrainedZonotope</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Check if the constrained zonotope is empty</span>

<span class="sd">        Raises:</span>
<span class="sd">            NotImplementedError: Unable to solve the feasibility problem using CVXPY</span>

<span class="sd">        Returns:</span>
<span class="sd">            bool: When True, the polytope is empty</span>

<span class="sd">        Notes:</span>
<span class="sd">            This function may trigger a cvxpy feasibility problem if emptiness is not already known.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_empty</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">c</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="c1"># When c is None, constrained zonotope is empty by construction.</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_is_empty</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_singleton</span><span class="p">:</span>
                <span class="c1"># is_singleton ensures that redundancies are removed, and _is_empty is populated when possible.</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_is_empty</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_empty</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="c1"># Do feasibility check if ConstrainedZonotope&#39;s emptiness is still not known</span>
                <span class="kn">import</span><span class="w"> </span><span class="nn">cvxpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">cp</span>

                <span class="n">x</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">Variable</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">dim</span><span class="p">,))</span>
                <span class="n">_</span><span class="p">,</span> <span class="n">feasibility_value</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">minimize</span><span class="p">(</span>
                    <span class="n">x</span><span class="p">,</span>
                    <span class="n">objective_to_minimize</span><span class="o">=</span><span class="n">cp</span><span class="o">.</span><span class="n">Constant</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span>
                    <span class="n">cvxpy_args</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">cvxpy_args_lp</span><span class="p">,</span>
                    <span class="n">task_str</span><span class="o">=</span><span class="s2">&quot;emptiness check for the constrained zonotope&quot;</span><span class="p">,</span>
                <span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_is_empty</span> <span class="o">=</span> <span class="nb">bool</span><span class="p">(</span><span class="n">feasibility_value</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">pass</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_empty</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">is_full_dimensional</span><span class="p">(</span><span class="bp">self</span><span class="p">:</span> <span class="n">ConstrainedZonotope</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Check if the affine dimension of the constrained zonotope is the same as the constrained zonotope dimension</span>

<span class="sd">        Returns:</span>
<span class="sd">            bool: True when the affine hull containing the constrained zonotope has the dimension `self.dim`</span>

<span class="sd">        Notes:</span>
<span class="sd">            An empty polytope is full dimensional if dim=0, otherwise it is not full-dimensional. See Sec. 2.1.3 of</span>
<span class="sd">            [BV04] for discussion on affine dimension. A non-empty zonotope is full-dimensional if and only if G has</span>
<span class="sd">            full row rank. A non-empty constrained zonotope is full-dimensional if and only if [G; A] has full row rank.</span>

<span class="sd">            This function may trigger a cvxpy feasibility problem if emptiness is not already known.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_full_dimensional</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_singleton</span><span class="p">:</span>
                <span class="c1"># is_singleton ensures that redundancies are removed, and _is_full_dimensional populated when possible.</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_is_full_dimensional</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dim</span> <span class="o">==</span> <span class="mi">1</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_empty</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_is_full_dimensional</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dim</span> <span class="o">==</span> <span class="mi">0</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">stacked_G_Ae</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">G</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Ae</span><span class="p">))</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_equalities</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">G</span>
                    <span class="n">stacked_G_Ae_is_fat_or_sqr_matrix</span> <span class="o">=</span> <span class="n">stacked_G_Ae</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">stacked_G_Ae</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                    <span class="n">stacked_G_Ae_is_full_row_rank</span> <span class="o">=</span> <span class="n">stacked_G_Ae</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">matrix_rank</span><span class="p">(</span><span class="n">stacked_G_Ae</span><span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_is_full_dimensional</span> <span class="o">=</span> <span class="n">stacked_G_Ae_is_fat_or_sqr_matrix</span> <span class="ow">and</span> <span class="n">stacked_G_Ae_is_full_row_rank</span>
        <span class="k">return</span> <span class="n">cast</span><span class="p">(</span><span class="nb">bool</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_full_dimensional</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">is_singleton</span><span class="p">(</span><span class="bp">self</span><span class="p">:</span> <span class="n">ConstrainedZonotope</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Check if the constrained zonotope is a singleton</span>

<span class="sd">        This function does not invoke any optimization solver, and relies on rank computations.</span>

<span class="sd">        A non-empty constrained zonotope is a singleton if and only if latent set is empty or a singleton.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_singleton</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_equalities</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="c1"># If latent set has equalities, remove_redundancies will detect if latent set is empty or singleton</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">remove_redundancies</span><span class="p">()</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_equalities</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_is_singleton</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">latent_dim</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">c</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Equalities remain and form a non-trivial latent set</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_is_singleton</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_singleton</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">is_zonotope</span><span class="p">(</span><span class="bp">self</span><span class="p">:</span> <span class="n">ConstrainedZonotope</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Check if the constrained zonotope is a zonotope&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_singleton</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_equalities</span> <span class="o">==</span> <span class="mi">0</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">cvxpy_args_lp</span><span class="p">(</span><span class="bp">self</span><span class="p">:</span> <span class="n">ConstrainedZonotope</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;CVXPY arguments in use when solving a linear program</span>

<span class="sd">        Returns:</span>
<span class="sd">            dict: CVXPY arguments in use when solving a linear program. Defaults to dictionary in</span>
<span class="sd">            `pycvxset.common.DEFAULT_CVXPY_ARGS_LP`.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cvxpy_args_lp</span>

    <span class="nd">@cvxpy_args_lp</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">cvxpy_args_lp</span><span class="p">(</span><span class="bp">self</span><span class="p">:</span> <span class="n">ConstrainedZonotope</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Update CVXPY arguments in use when solving a linear program</span>

<span class="sd">        Args:</span>
<span class="sd">            value: Dictionary with new CVXPY arguments in use when solving a linear program.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_cvxpy_args_lp</span> <span class="o">=</span> <span class="n">value</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">cvxpy_args_socp</span><span class="p">(</span><span class="bp">self</span><span class="p">:</span> <span class="n">ConstrainedZonotope</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;CVXPY arguments in use when solving a second-order cone program</span>

<span class="sd">        Returns:</span>
<span class="sd">            dict: CVXPY arguments in use when solving a second-order cone program. Defaults to dictionary in</span>
<span class="sd">            `pycvxset.common.DEFAULT_CVXPY_ARGS_SOCP`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cvxpy_args_socp</span>

    <span class="nd">@cvxpy_args_socp</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">cvxpy_args_socp</span><span class="p">(</span><span class="bp">self</span><span class="p">:</span> <span class="n">ConstrainedZonotope</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Update CVXPY arguments in use when solving a second-order cone program</span>

<span class="sd">        Args:</span>
<span class="sd">            value: Dictionary with new CVXPY arguments in use when solving a second-order cone program.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_cvxpy_args_socp</span> <span class="o">=</span> <span class="n">value</span>

    <span class="c1">##################################</span>
    <span class="c1"># Plotting and polytope operations</span>
    <span class="c1">##################################</span>
    <span class="n">plot</span> <span class="o">=</span> <span class="n">plot_polytopic_approximation</span>
    <span class="n">polytopic_inner_approximation</span> <span class="o">=</span> <span class="n">polytopic_inner_approximation</span>
    <span class="n">polytopic_outer_approximation</span> <span class="o">=</span> <span class="n">polytopic_outer_approximation</span>

    <span class="c1">###########</span>
    <span class="c1"># Auxiliary</span>
    <span class="c1">###########</span>
<div class="viewcode-block" id="ConstrainedZonotope.containment_constraints">
<a class="viewcode-back" href="../../pycvxset.ConstrainedZonotope.html#pycvxset.ConstrainedZonotope.containment_constraints">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">containment_constraints</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="n">cvxpy</span><span class="o">.</span><span class="n">Variable</span><span class="p">,</span> <span class="n">flatten_order</span><span class="p">:</span> <span class="n">Literal</span><span class="p">[</span><span class="s2">&quot;F&quot;</span><span class="p">,</span> <span class="s2">&quot;C&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;F&quot;</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">list</span><span class="p">[</span><span class="n">cvxpy</span><span class="o">.</span><span class="n">Constraint</span><span class="p">],</span> <span class="n">Optional</span><span class="p">[</span><span class="n">cvxpy</span><span class="o">.</span><span class="n">Variable</span><span class="p">]]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get CVXPY constraints for containment of x (a cvxpy.Variable) in a constrained zonotope.</span>

<span class="sd">        Args:</span>
<span class="sd">            x (cvxpy.Variable): CVXPY variable to be optimized.</span>
<span class="sd">            flatten_order (Literal[&quot;F&quot;, &quot;C&quot;]): Order to use for flatten (choose between &quot;F&quot;, &quot;C&quot;). Defaults to &quot;F&quot;,</span>
<span class="sd">                which implements column-major flatten. In 2D, column-major flatten results in stacking rows</span>
<span class="sd">                horizontally to achieve a single horizontal row.</span>

<span class="sd">        Raises:</span>
<span class="sd">            ValueError: When constrained zonotope is empty</span>

<span class="sd">        Returns:</span>
<span class="sd">            tuple: A tuple with two items:</span>

<span class="sd">            #. constraint_list (list): CVXPY constraints for the containment of x in the constrained zonotope.</span>
<span class="sd">            #. xi (cvxpy.Variable | None): CVXPY variable representing the latent dimension variable. It is None,</span>
<span class="sd">               when the constrained zonotope is a single point.</span>

<span class="sd">        Notes:</span>
<span class="sd">            This function imports CVXPY locally to avoid overhead.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">import</span><span class="w"> </span><span class="nn">cvxpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">cp</span>

        <span class="n">x_reshaped</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">size</span><span class="p">,),</span> <span class="n">order</span><span class="o">=</span><span class="n">flatten_order</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">c</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Containment constraints can not be generated for an empty constrained zonotope!&quot;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_singleton</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[</span><span class="n">x_reshaped</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">c</span><span class="p">],</span> <span class="kc">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">xi</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">Variable</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">latent_dim</span><span class="p">,))</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_zonotope</span><span class="p">:</span>
                <span class="k">return</span> <span class="p">[</span><span class="n">x_reshaped</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">G</span> <span class="o">@</span> <span class="n">xi</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">c</span><span class="p">,</span> <span class="n">cp</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">xi</span><span class="p">,</span> <span class="n">p</span><span class="o">=</span><span class="s2">&quot;inf&quot;</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">],</span> <span class="n">xi</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="p">[</span><span class="n">x_reshaped</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">G</span> <span class="o">@</span> <span class="n">xi</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">c</span><span class="p">,</span> <span class="n">cp</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">xi</span><span class="p">,</span> <span class="n">p</span><span class="o">=</span><span class="s2">&quot;inf&quot;</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Ae</span> <span class="o">@</span> <span class="n">xi</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">be</span><span class="p">],</span> <span class="n">xi</span></div>


    <span class="n">minimize</span> <span class="o">=</span> <span class="n">minimize</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__pow__</span><span class="p">(</span><span class="bp">self</span><span class="p">:</span> <span class="n">ConstrainedZonotope</span><span class="p">,</span> <span class="n">power</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ConstrainedZonotope</span><span class="p">:</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Compute the Cartesian product with itself.</span>

<span class="sd">        Args:</span>
<span class="sd">            power (int): Number of times the polytope is multiplied with itself</span>

<span class="sd">        Returns:</span>
<span class="sd">            Polytope: The polytope :math:`\mathcal{R}` corresponding to P`^N`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">c</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># When c is None, the constrained zonotope is empty by construction, and Cartesian product is also empty.</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="n">dim</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">dim</span> <span class="o">*</span> <span class="n">power</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">concatenated_G</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">kron</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="n">power</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">G</span><span class="p">)</span>
            <span class="n">concatenated_c</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">c</span><span class="p">,</span> <span class="p">(</span><span class="n">power</span><span class="p">,))</span>
            <span class="n">concatenated_Ae</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">kron</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="n">power</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">Ae</span><span class="p">)</span>
            <span class="n">concatenated_be</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">be</span><span class="p">,</span> <span class="p">(</span><span class="n">power</span><span class="p">,))</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="n">G</span><span class="o">=</span><span class="n">concatenated_G</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="n">concatenated_c</span><span class="p">,</span> <span class="n">Ae</span><span class="o">=</span><span class="n">concatenated_Ae</span><span class="p">,</span> <span class="n">be</span><span class="o">=</span><span class="n">concatenated_be</span><span class="p">)</span>

    <span class="c1">##################</span>
    <span class="c1"># Unary operations</span>
    <span class="c1">##################</span>
<div class="viewcode-block" id="ConstrainedZonotope.copy">
<a class="viewcode-back" href="../../pycvxset.ConstrainedZonotope.html#pycvxset.ConstrainedZonotope.copy">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">copy</span><span class="p">(</span><span class="bp">self</span><span class="p">:</span> <span class="n">ConstrainedZonotope</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ConstrainedZonotope</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get a copy of the constrained zonotope&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="n">G</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">G</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">c</span><span class="p">,</span> <span class="n">Ae</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">Ae</span><span class="p">,</span> <span class="n">be</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">be</span><span class="p">)</span></div>


    <span class="n">chebyshev_centering</span> <span class="o">=</span> <span class="n">chebyshev_centering</span>
    <span class="n">interior_point</span> <span class="o">=</span> <span class="n">interior_point</span>
    <span class="n">maximum_volume_inscribing_ellipsoid</span> <span class="o">=</span> <span class="n">maximum_volume_inscribing_ellipsoid</span>
    <span class="n">minimum_volume_circumscribing_rectangle</span> <span class="o">=</span> <span class="n">convex_set_minimum_volume_circumscribing_rectangle</span>
    <span class="n">remove_redundancies</span> <span class="o">=</span> <span class="n">remove_redundancies</span>

    <span class="c1">######################</span>
    <span class="c1"># Comparison operators</span>
    <span class="c1">######################</span>
    <span class="n">contains</span> <span class="o">=</span> <span class="n">contains</span>
    <span class="fm">__contains__</span> <span class="o">=</span> <span class="n">contains</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__le__</span><span class="p">(</span><span class="bp">self</span><span class="p">:</span> <span class="n">ConstrainedZonotope</span><span class="p">,</span> <span class="n">Q</span><span class="p">:</span> <span class="s2">&quot;ConstrainedZonotope | Polytope&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Overload &lt;= operator for containment. self &lt;= Q is equivalent to Q.contains(self).&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">is_polytope</span><span class="p">(</span><span class="n">Q</span><span class="p">)</span> <span class="ow">or</span> <span class="n">is_constrained_zonotope</span><span class="p">(</span><span class="n">Q</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">Q</span><span class="o">.</span><span class="n">contains</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">NotImplemented</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__ge__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">:</span> <span class="n">ConstrainedZonotope</span><span class="p">,</span>
        <span class="n">Q</span><span class="p">:</span> <span class="s2">&quot;Sequence[float] | np.ndarray | ConstrainedZonotope | Polytope&quot;</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Overload &gt;= operator for containment. self &gt;= Q is equivalent to self.contains(Q).&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">is_polytope</span><span class="p">(</span><span class="n">Q</span><span class="p">)</span> <span class="ow">or</span> <span class="n">is_constrained_zonotope</span><span class="p">(</span><span class="n">Q</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">contains</span><span class="p">(</span><span class="n">Q</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">Q_arr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="n">Q</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span>
            <span class="k">except</span> <span class="p">(</span><span class="ne">TypeError</span><span class="p">,</span> <span class="ne">ValueError</span><span class="p">):</span>
                <span class="k">return</span> <span class="bp">NotImplemented</span>
            <span class="k">if</span> <span class="n">Q_arr</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">dim</span> <span class="ow">and</span> <span class="n">Q_arr</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="c1"># Q is a point ====&gt; ConstrainedZonotope &gt;= Point case</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">contains</span><span class="p">(</span><span class="n">Q_arr</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">NotImplemented</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">:</span> <span class="n">ConstrainedZonotope</span><span class="p">,</span> <span class="n">Q</span><span class="p">:</span> <span class="nb">object</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Overload == operator with equality check. P == Q is equivalent to Q.contains(P) and P.contains(Q)&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">is_constrained_zonotope</span><span class="p">(</span><span class="n">Q</span><span class="p">)</span> <span class="ow">or</span> <span class="n">is_polytope</span><span class="p">(</span><span class="n">Q</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span> <span class="o">&lt;=</span> <span class="n">cast</span><span class="p">(</span><span class="s2">&quot;ConstrainedZonotope | Polytope&quot;</span><span class="p">,</span> <span class="n">Q</span><span class="p">)</span> <span class="ow">and</span> <span class="bp">self</span> <span class="o">&gt;=</span> <span class="n">Q</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">NotImplemented</span>

    <span class="fm">__lt__</span> <span class="o">=</span> <span class="fm">__le__</span>
    <span class="fm">__gt__</span> <span class="o">=</span> <span class="fm">__ge__</span>

    <span class="c1">####################</span>
    <span class="c1"># Binary operations</span>
    <span class="c1">####################</span>
    <span class="n">plus</span> <span class="o">=</span> <span class="n">plus</span>
    <span class="fm">__add__</span> <span class="o">=</span> <span class="n">plus</span>
    <span class="fm">__radd__</span> <span class="o">=</span> <span class="n">plus</span>
    <span class="n">minus</span> <span class="o">=</span> <span class="n">minus</span>
    <span class="fm">__sub__</span> <span class="o">=</span> <span class="n">minus</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__rsub__</span><span class="p">(</span><span class="bp">self</span><span class="p">:</span> <span class="n">ConstrainedZonotope</span><span class="p">,</span> <span class="n">Q</span><span class="p">:</span> <span class="n">Any</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Unsupported operation: </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">Q</span><span class="p">)</span><span class="si">}</span><span class="s2"> - ConstrainedZonotope!&quot;</span><span class="p">)</span>

    <span class="n">__array_ufunc__</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># Allows for numpy matrix times Polytope</span>
    <span class="n">affine_map</span> <span class="o">=</span> <span class="n">affine_map</span>
    <span class="n">inverse_affine_map_under_invertible_matrix</span> <span class="o">=</span> <span class="n">inverse_affine_map_under_invertible_matrix</span>

    <span class="c1"># ConstrainedZonotope times Matrix</span>
    <span class="fm">__matmul__</span> <span class="o">=</span> <span class="n">inverse_affine_map_under_invertible_matrix</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__mul__</span><span class="p">(</span><span class="bp">self</span><span class="p">:</span> <span class="n">ConstrainedZonotope</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="n">Any</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Do not allow ConstrainedZonotope * anything&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">NotImplemented</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__neg__</span><span class="p">(</span><span class="bp">self</span><span class="p">:</span> <span class="n">ConstrainedZonotope</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ConstrainedZonotope</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">affine_map</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>

    <span class="c1"># Scalar/Matrix times ConstrainedZonotope (called when left operand does not support multiplication)</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__rmatmul__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">:</span> <span class="n">ConstrainedZonotope</span><span class="p">,</span> <span class="n">M</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="nb">float</span> <span class="o">|</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">Sequence</span><span class="p">[</span><span class="nb">float</span><span class="p">]]</span> <span class="o">|</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ConstrainedZonotope</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Overload @ operator for affine map (matrix times ConstrainedZonotope).&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">affine_map</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">M</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__rmul__</span><span class="p">(</span><span class="bp">self</span><span class="p">:</span> <span class="n">ConstrainedZonotope</span><span class="p">,</span> <span class="n">m</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="nb">float</span> <span class="o">|</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">|</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ConstrainedZonotope</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Overload * operator for multiplication.&quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">m</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">m</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span>
        <span class="k">except</span> <span class="p">(</span><span class="ne">TypeError</span><span class="p">,</span> <span class="ne">ValueError</span><span class="p">)</span> <span class="k">as</span> <span class="n">err</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Unsupported operation: </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">m</span><span class="p">)</span><span class="si">}</span><span class="s2"> * ConstrainedZonotope!&quot;</span><span class="p">)</span> <span class="kn">from</span><span class="w"> </span><span class="nn">err</span>
        <span class="k">return</span> <span class="n">affine_map</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">m</span><span class="p">)</span>

    <span class="n">approximate_pontryagin_difference</span> <span class="o">=</span> <span class="n">approximate_pontryagin_difference</span>
    <span class="n">cartesian_product</span> <span class="o">=</span> <span class="n">cartesian_product</span>
    <span class="n">closest_point</span> <span class="o">=</span> <span class="n">convex_set_closest_point</span>
    <span class="n">distance</span> <span class="o">=</span> <span class="n">convex_set_distance</span>
    <span class="n">extreme</span> <span class="o">=</span> <span class="n">convex_set_extreme</span>
    <span class="n">intersection</span> <span class="o">=</span> <span class="n">intersection</span>
    <span class="n">intersection_with_halfspaces</span> <span class="o">=</span> <span class="n">intersection_with_halfspaces</span>
    <span class="n">intersection_with_affine_set</span> <span class="o">=</span> <span class="n">intersection_with_affine_set</span>
    <span class="n">intersection_under_inverse_affine_map</span> <span class="o">=</span> <span class="n">intersection_under_inverse_affine_map</span>

<div class="viewcode-block" id="ConstrainedZonotope.project">
<a class="viewcode-back" href="../../pycvxset.ConstrainedZonotope.html#pycvxset.ConstrainedZonotope.project">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">project</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">:</span> <span class="n">ConstrainedZonotope</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">|</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">Sequence</span><span class="p">[</span><span class="nb">float</span><span class="p">]]</span> <span class="o">|</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">p</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="nb">str</span> <span class="o">=</span> <span class="mi">2</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]:</span>
        <span class="k">return</span> <span class="n">convex_set_project</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">p</span><span class="o">=</span><span class="n">p</span><span class="p">)</span></div>


    <span class="n">project</span><span class="o">.</span><span class="vm">__doc__</span> <span class="o">=</span> <span class="p">(</span><span class="n">convex_set_project</span><span class="o">.</span><span class="vm">__doc__</span> <span class="ow">or</span> <span class="s2">&quot;&quot;</span><span class="p">)</span> <span class="o">+</span> <span class="n">DOCSTRING_FOR_PROJECT</span>

<div class="viewcode-block" id="ConstrainedZonotope.projection">
<a class="viewcode-back" href="../../pycvxset.ConstrainedZonotope.html#pycvxset.ConstrainedZonotope.projection">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">projection</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">:</span> <span class="n">ConstrainedZonotope</span><span class="p">,</span> <span class="n">project_away_dims</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">|</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ConstrainedZonotope</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">convex_set_projection</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">project_away_dims</span><span class="o">=</span><span class="n">project_away_dims</span><span class="p">)</span></div>


    <span class="n">projection</span><span class="o">.</span><span class="vm">__doc__</span> <span class="o">=</span> <span class="p">(</span><span class="n">convex_set_projection</span><span class="o">.</span><span class="vm">__doc__</span> <span class="ow">or</span> <span class="s2">&quot;&quot;</span><span class="p">)</span> <span class="o">+</span> <span class="n">DOCSTRING_FOR_PROJECTION</span>

<div class="viewcode-block" id="ConstrainedZonotope.slice">
<a class="viewcode-back" href="../../pycvxset.ConstrainedZonotope.html#pycvxset.ConstrainedZonotope.slice">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">slice</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">:</span> <span class="n">ConstrainedZonotope</span><span class="p">,</span>
        <span class="n">dims</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">|</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
        <span class="n">constants</span><span class="p">:</span> <span class="nb">float</span> <span class="o">|</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">|</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ConstrainedZonotope</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">convex_set_slice</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dims</span><span class="p">,</span> <span class="n">constants</span><span class="p">)</span></div>


    <span class="nb">slice</span><span class="o">.</span><span class="vm">__doc__</span> <span class="o">=</span> <span class="p">(</span><span class="n">convex_set_slice</span><span class="o">.</span><span class="vm">__doc__</span> <span class="ow">or</span> <span class="s2">&quot;&quot;</span><span class="p">)</span> <span class="o">+</span> <span class="n">DOCSTRING_FOR_SLICE</span>

<div class="viewcode-block" id="ConstrainedZonotope.slice_then_projection">
<a class="viewcode-back" href="../../pycvxset.ConstrainedZonotope.html#pycvxset.ConstrainedZonotope.slice_then_projection">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">slice_then_projection</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">dims</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">|</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">constants</span><span class="p">:</span> <span class="nb">float</span> <span class="o">|</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">|</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;ConstrainedZonotope&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">convex_set_slice_then_projection</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dims</span><span class="o">=</span><span class="n">dims</span><span class="p">,</span> <span class="n">constants</span><span class="o">=</span><span class="n">constants</span><span class="p">)</span></div>


    <span class="n">slice_then_projection</span><span class="o">.</span><span class="vm">__doc__</span> <span class="o">=</span> <span class="p">(</span>
        <span class="n">convex_set_slice_then_projection</span><span class="o">.</span><span class="vm">__doc__</span> <span class="ow">or</span> <span class="s2">&quot;&quot;</span>
    <span class="p">)</span> <span class="o">+</span> <span class="n">DOCSTRING_FOR_SLICE_THEN_PROJECTION</span>

<div class="viewcode-block" id="ConstrainedZonotope.support">
<a class="viewcode-back" href="../../pycvxset.ConstrainedZonotope.html#pycvxset.ConstrainedZonotope.support">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">support</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">:</span> <span class="n">ConstrainedZonotope</span><span class="p">,</span> <span class="n">eta</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">|</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">Sequence</span><span class="p">[</span><span class="nb">float</span><span class="p">]]</span> <span class="o">|</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]:</span>
        <span class="k">return</span> <span class="n">convex_set_support</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">eta</span><span class="p">)</span></div>


    <span class="n">support</span><span class="o">.</span><span class="vm">__doc__</span> <span class="o">=</span> <span class="p">(</span><span class="n">convex_set_support</span><span class="o">.</span><span class="vm">__doc__</span> <span class="ow">or</span> <span class="s2">&quot;&quot;</span><span class="p">)</span> <span class="o">+</span> <span class="n">DOCSTRING_FOR_SUPPORT</span>

    <span class="n">_compute_support_function_multiple_eta</span> <span class="o">=</span> <span class="n">_compute_support_function_multiple_eta</span>
    <span class="n">_compute_project_multiple_points</span> <span class="o">=</span> <span class="n">_compute_project_multiple_points</span>

    <span class="c1">#####################################</span>
    <span class="c1"># Constrained zonotope representation</span>
    <span class="c1">#####################################</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">:</span> <span class="n">ConstrainedZonotope</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_empty</span><span class="p">:</span>
            <span class="n">short_str</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;(empty) in R^</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">dim</span><span class="si">:</span><span class="s2">d</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">short_str</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;in R^</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">dim</span><span class="si">:</span><span class="s2">d</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;Constrained Zonotope </span><span class="si">{</span><span class="n">short_str</span><span class="si">:</span><span class="s2">s</span><span class="si">}</span><span class="s2">&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">:</span> <span class="n">ConstrainedZonotope</span><span class="p">):</span>
        <span class="n">long_str</span> <span class="o">=</span> <span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="p">)]</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_empty</span><span class="p">:</span>
            <span class="k">pass</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_zonotope</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">G</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">long_str</span> <span class="o">+=</span> <span class="p">[</span><span class="s2">&quot;</span><span class="se">\n\t</span><span class="s2">that is a zonotope representing a single point&quot;</span><span class="p">]</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_zonotope</span><span class="p">:</span>
            <span class="n">long_str</span> <span class="o">+=</span> <span class="p">[</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n\t</span><span class="s2">that is a zonotope with latent dimension </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">latent_dim</span><span class="si">:</span><span class="s2">d</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">]</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_equalities</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">long_str</span> <span class="o">+=</span> <span class="p">[</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n\t</span><span class="s2">with latent dimension </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">latent_dim</span><span class="si">:</span><span class="s2">d</span><span class="si">}</span><span class="s2"> and 1 equality constraint&quot;</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">long_str</span> <span class="o">+=</span> <span class="p">[</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n\t</span><span class="s2">with latent dimension </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">latent_dim</span><span class="si">:</span><span class="s2">d</span><span class="si">}</span><span class="s2"> and </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">n_equalities</span><span class="si">:</span><span class="s2">d</span><span class="si">}</span><span class="s2"> equality constraints&quot;</span>
            <span class="p">]</span>
        <span class="k">return</span> <span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">long_str</span><span class="p">)</span></div>

</pre></div>

          </div>
          
        </div>
      </div>
    <div class="clearer"></div>
  </div>
    <div class="footer">
      &#169;2020-2026, Mitsubishi Electric Research Laboratories (MERL).
      
      |
      Powered by <a href="https://www.sphinx-doc.org/">Sphinx 9.1.0</a>
      &amp; <a href="https://alabaster.readthedocs.io">Alabaster 1.0.0</a>
      
    </div>

    

    
  </body>
</html>