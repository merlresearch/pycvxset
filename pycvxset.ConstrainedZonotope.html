<!DOCTYPE html>

<html lang="en" data-content_root="./">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>pycvxset.ConstrainedZonotope (API details) &#8212; pycvxset 1.1.0 documentation</title>
    <link rel="stylesheet" type="text/css" href="_static/pygments.css?v=03e43079" />
    <link rel="stylesheet" type="text/css" href="_static/basic.css?v=686e5160" />
    <link rel="stylesheet" type="text/css" href="_static/alabaster.css?v=f6a572b4" />
    <script src="_static/documentation_options.js?v=fc837d61"></script>
    <script src="_static/doctools.js?v=9bcbadda"></script>
    <script src="_static/sphinx_highlight.js?v=dc90522c"></script>
    <script async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="pycvxset.common" href="pycvxset.common.html" />
    <link rel="prev" title="pycvxset.ConstrainedZonotope" href="api_summary/pycvxset.ConstrainedZonotope.html" />
   
  <link rel="stylesheet" href="_static/custom.css" type="text/css" />
  

  
  

  </head><body>
  <div class="document">
    
      <div class="sphinxsidebar" role="navigation" aria-label="Main">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="index.html">
              <img class="logo" src="_static/pycvxset_logo.png" alt="Logo of pycvxset"/>
            </a></p>
<h1 class="logo"><a href="index.html">pycvxset</a></h1>



<p class="blurb">A Python package for manipulation and visualization of convex sets.</p>




<p>
<iframe src="https://ghbtns.com/github-btn.html?user=merlresearch&repo=pycvxset&type=star&count=true&size=large&v=2"
  allowtransparency="true" frameborder="0" scrolling="0" width="200px" height="35px"></iframe>
</p>






<search id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</search>
<script>document.getElementById('searchbox').style.display = "block"</script><!-- Copyright (C) 2020-2025 Mitsubishi Electric Research Laboratories (MERL)

SPDX-License-Identifier: AGPL-3.0-or-later

Code purpose: Custom navigation side bar for documentation website -->

</br>
<h3>Navigation</h3>
<ul>
    <li class="toctree-l1">
        <a class="reference internal" href="tutorials/tutorials.html">Tutorials</a>
    </li>
    <li class="toctree-l1" style="color: #444;font-size:120%">Set Representations</li>
    <ul>
        <li class="toctree-l2">
            <a class="reference internal" href="api_summary/pycvxset.Polytope.html">Polytope</a>
        </li>
        <li class="toctree-l2">
            <a class="reference internal" href="api_summary/pycvxset.Ellipsoid.html">Ellipsoid</a>
        </li>
        <li class="toctree-l2">
            <a class="reference internal"
                href="api_summary/pycvxset.ConstrainedZonotope.html">ConstrainedZonotope
            </a>
        </li>
    </ul>
    <li class="toctree-l1"><a class="reference internal" href="pycvxset.common.html">Other useful
            methods</a></li>
    <li class="toctree-l1"><a class="reference internal"
            href="pycvxset.common.constants.html">Constants</a></li>
    <li class="toctree-l1"><a class="reference external"
            href="https://raw.githubusercontent.com/merlresearch/pycvxset/main/MANUAL.pdf" target="_blank">Manual
            (PDF)</a></li>
    <li class="toctree-l1"><a class="reference external" href="https://www.merl.com/publications/docs/TR2025-086.pdf" target="_blank">Paper (ACC '25)
            </a></li>
    <li class="toctree-l1"><a class="reference internal" href="references.html">References</a></li>
</ul>
        </div>
      </div>
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <section id="pycvxset-constrainedzonotope-api-details">
<h1>pycvxset.ConstrainedZonotope (API details)<a class="headerlink" href="#pycvxset-constrainedzonotope-api-details" title="Link to this heading">¶</a></h1>
<table class="autosummary longtable docutils align-default">
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#module-pycvxset.ConstrainedZonotope" title="pycvxset.ConstrainedZonotope"><code class="xref py py-obj docutils literal notranslate"><span class="pre">pycvxset.ConstrainedZonotope</span></code></a>(**kwargs)</p></td>
<td><p>Constrained zonotope class</p></td>
</tr>
</tbody>
</table>
<dl class="py class" id="module-pycvxset.ConstrainedZonotope">
<dt class="sig sig-object py" id="pycvxset.ConstrainedZonotope.ConstrainedZonotope">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pycvxset.ConstrainedZonotope.</span></span><span class="sig-name descname"><span class="pre">ConstrainedZonotope</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycvxset/ConstrainedZonotope.html#ConstrainedZonotope"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pycvxset.ConstrainedZonotope.ConstrainedZonotope" title="Link to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Constrained zonotope class</p>
<p>Constrained zonotope defines a polytope in the working dimension <span class="math notranslate nohighlight">\(\mathbb{R}^n\)</span> as an affine transformation of
a polytope defined in latent space <span class="math notranslate nohighlight">\(B_\infty(A_e, b_e)\subset \mathbb{R}^{N_C}\)</span>. Here, <span class="math notranslate nohighlight">\(B_\infty(A_e,
b_e)\)</span> is defined as the intersection of a unit <span class="math notranslate nohighlight">\(\ell_\infty\)</span>-norm ball and a collection of <span class="math notranslate nohighlight">\(M_C\)</span> linear
constraints <span class="math notranslate nohighlight">\(\{\xi\in\mathbb{R}^{N_C}|A_e \xi = b_e\}.\)</span></p>
<p>Formally, a <strong>constrained zonotope</strong> is defined as follows,</p>
<div class="math notranslate nohighlight">
\[\mathcal{C} = \{G \xi + c\ |\ \xi \in B_\infty(A_e, b_e)\} \subset \mathbb{R}^n,\]</div>
<p>where</p>
<div class="math notranslate nohighlight">
\[B_\infty(A_e, b_e)= \{\xi\ |\ \| \xi \|_\infty \leq 1, A_e \xi = b_e\} \subset \mathbb{R}^{N_C},\]</div>
<p>with <span class="math notranslate nohighlight">\(G\in\mathbb{R}^{n\times N_C}\)</span>, <span class="math notranslate nohighlight">\(c\in\mathbb{R}^{n}\)</span>, <span class="math notranslate nohighlight">\(A_e\in\mathbb{R}^{M_C\times N_C}\)</span>, and
<span class="math notranslate nohighlight">\(b\in\mathbb{R}^{M_C}\)</span>.</p>
<p>A constrained zonotope provide an alternative and equivalent representation of any
convex and compact polytope.  Furthermore, a constrained zonotope admits closed-form expressions for several set
manipulations that can often be accomplished without invoking any optimization solvers. See <a class="reference internal" href="references.html#sdgr16" id="id1"><span>[SDGR16]</span></a> <a class="reference internal" href="references.html#rk22" id="id2"><span>[RK22]</span></a>
<a class="reference internal" href="references.html#vwd24" id="id3"><span>[VWD24]</span></a> for more details.</p>
<p>A <strong>zonotope</strong> is a special class of constrained zonotopes, and are defined as</p>
<div class="math notranslate nohighlight">
\[\mathcal{Z} = \{G \xi + c\ |\ \|\xi\|_\infty \leq 1\} \subset \mathbb{R}^n.\]</div>
<p>In other words, a zonotope is a constrained zonotope with no equality constraints in the latent dimension space. In
<a class="reference internal" href="#pycvxset.ConstrainedZonotope.ConstrainedZonotope" title="pycvxset.ConstrainedZonotope.ConstrainedZonotope"><code class="xref py py-class docutils literal notranslate"><span class="pre">ConstrainedZonotope</span></code></a>, we model zonotopes by having (Ae,be) be empty (n_equalities is zero).</p>
<p>Constrained zonotope object construction admits <strong>one</strong> of the following combinations (as keyword arguments):</p>
<ol class="arabic simple">
<li><p>dim for an <strong>empty</strong> constrained zonotope of dimension dim,</p></li>
<li><p>(G, c, Ae, be) for a <strong>constrained zonotope</strong>,</p></li>
<li><p>(G, c) for a <strong>zonotope</strong>,</p></li>
<li><p>(lb, ub) for a <strong>zonotope</strong> equivalent to an <strong>axis-aligned cuboid</strong> with appropriate bounds <span class="math notranslate nohighlight">\(\{x\ |\
lb\leq x \leq ub\}\)</span>, and</p></li>
<li><p>(c, h) for a <strong>zonotope</strong> equivalent to an <strong>axis-aligned cuboid</strong> centered at c with specified
scalar/vector half-sides <span class="math notranslate nohighlight">\(h\)</span>, <span class="math notranslate nohighlight">\(\{x\ |\ \forall i\in\{1,2,...,n\}, |x_i - c_i| \leq h_i\}\)</span>.</p></li>
<li><p>(c=p, G=None) for a <strong>zonotope</strong> equivalent to a <strong>single point</strong> p,</p></li>
<li><p>P for a <strong>constrained zonotope</strong> equivalent to the <a class="reference internal" href="pycvxset.Polytope.html#pycvxset.Polytope.Polytope" title="pycvxset.Polytope.Polytope"><code class="xref py py-class docutils literal notranslate"><span class="pre">pycvxset.Polytope.Polytope</span></code></a> object P,</p></li>
</ol>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>dim</strong> (<em>int</em><em>, </em><em>optional</em>) – Dimension of the empty constrained zonotope. If NOTHING is provided, dim=0 is assumed.</p></li>
<li><p><strong>c</strong> (<em>array_like</em><em>, </em><em>optional</em>) – Affine transformation translation vector. Must be 1D array, and the constrained
zonotope dimension is determined by number of elements in c. When c is provided, either (G) or (G, Ae, be)
or (h) must be provided additionally. When h is provided, c is the centroid of the resulting zonotope.</p></li>
<li><p><strong>G</strong> (<em>array_like</em>) – Affine transformation matrix. The vectors are stacked vertically with matching number of
rows as c. When G is provided, (c, Ae, be) OR (c) must also be provided. To define a constrained zonotope
with a single point, set c to the point AND G to None (do not set (Ae, be) or set them to (None, None)).</p></li>
<li><p><strong>Ae</strong> (<em>array_like</em>) – Equality coefficient vectors. The vectors are stacked vertically with matching number of
columns as G. When Ae is provided, (G, c, be) must also be provided.</p></li>
<li><p><strong>be</strong> (<em>array_like</em>) – Equality coefficient constants. The constants are expected to be in a 1D numpy array. When be
is provided, (G, c, Ae) must also be provided.</p></li>
<li><p><strong>lb</strong> (<em>array_like</em><em>, </em><em>optional</em>) – Lower bounds of the axis-aligned cuboid. Must be 1D array, and the constrained
zonotope dimension is determined by number of elements in lb. When lb is provided, ub must also be provided.</p></li>
<li><p><strong>ub</strong> (<em>array_like</em><em>, </em><em>optional</em>) – Upper bounds of the axis-aligned cuboid. Must be 1D array of length as same as lb.
When ub is provided, lb must also be provided.</p></li>
<li><p><strong>h</strong> (<em>array_like</em><em>, </em><em>optional</em>) – Half-side length of the axis-aligned cuboid. Can be a scalar or a vector of length as
same as c. When h is provided, c must also be provided.</p></li>
<li><p><strong>polytope</strong> (<a class="reference internal" href="pycvxset.Polytope.html#pycvxset.Polytope.Polytope" title="pycvxset.Polytope.Polytope"><em>Polytope</em></a><em>, </em><em>optional</em>) – Polytope to use to construct constrained zonotope.</p></li>
</ul>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>ValueError</strong> – (G, c) is not compatible.</p></li>
<li><p><strong>ValueError</strong> – (G, c, Ae, be) is not compatible.</p></li>
<li><p><strong>ValueError</strong> – (lb, ub) is not valid</p></li>
<li><p><strong>ValueError</strong> – (c, h) is not valid</p></li>
<li><p><strong>ValueError</strong> – Provided polytope is not bounded.</p></li>
<li><p><strong>UserWarning</strong> – When a row with all zeros in Ae and be.</p></li>
</ul>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="pycvxset.ConstrainedZonotope.ConstrainedZonotope.__init__">
<span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycvxset/ConstrainedZonotope.html#ConstrainedZonotope.__init__"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pycvxset.ConstrainedZonotope.ConstrainedZonotope.__init__" title="Link to this definition">¶</a></dt>
<dd><p>Constructor for ConstrainedZonotope class</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pycvxset.ConstrainedZonotope.ConstrainedZonotope.affine_map">
<span class="sig-name descname"><span class="pre">affine_map</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">M</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pycvxset.ConstrainedZonotope.ConstrainedZonotope.affine_map" title="Link to this definition">¶</a></dt>
<dd><p>Multiply a matrix or a scalar with a constrained zonotope</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>M</strong> (<em>array_like</em>) – Matrix (N times self.dim) or a scalar to be multiplied with a constrained zonotope</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Constrained zonotope which is the product of M and self. Specifically, given a constrained
zonotope <span class="math notranslate nohighlight">\(\mathcal{P}\)</span>, and a matrix <span class="math notranslate nohighlight">\(M\in\mathbb{R}^{m\times P.\text{dim}}\)</span> or scalar <span class="math notranslate nohighlight">\(M\)</span>,
then this function returns a constrained zonotope <span class="math notranslate nohighlight">\(\mathcal{R}=\{Mx|x\in\mathcal{P}\}\)</span>.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="#pycvxset.ConstrainedZonotope.ConstrainedZonotope" title="pycvxset.ConstrainedZonotope.ConstrainedZonotope">ConstrainedZonotope</a></p>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>This function implements (11) of <a class="reference internal" href="references.html#sdgr16" id="id4"><span>[SDGR16]</span></a>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pycvxset.ConstrainedZonotope.ConstrainedZonotope.approximate_pontryagin_difference">
<span class="sig-name descname"><span class="pre">approximate_pontryagin_difference</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">norm_type</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">G_S</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">c_S</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">method</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'inner-least-squares'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pycvxset.ConstrainedZonotope.ConstrainedZonotope.approximate_pontryagin_difference" title="Link to this definition">¶</a></dt>
<dd><p>Approximate Pontryagin difference between a constrained zonotope and an affine transformation of a unit-norm
ball.</p>
<p>Specifically, we approximate the Pontryagin difference <span class="math notranslate nohighlight">\(\mathcal{P}\ominus\mathcal{S}=\{x\in\mathbb{R}^n\ |\ x
+ \mathcal{S}\subseteq\mathcal{P}\}\)</span> between a constrained zonotope <span class="math notranslate nohighlight">\(\mathcal{P}\)</span> and a subtrahend
<span class="math notranslate nohighlight">\(\mathcal{S}\)</span>. The subtrahend must be specifically of the form <span class="math notranslate nohighlight">\(\mathcal{S}=\{G_S \xi + c_S |
\|\xi\|_p\leq 1\}\)</span> for norm_type <span class="math notranslate nohighlight">\(p\in\{1,2,\infty\}\)</span>.</p>
<ul class="simple">
<li><p>For p=1, the subtrahend is a convex hull of intervals specified by the columns of <span class="math notranslate nohighlight">\(G_S\)</span> with each
interval is symmetric about <span class="math notranslate nohighlight">\(c_S\)</span>.</p></li>
<li><p>For p=2, the subtrahend is an ellipsoid is characterized by affine transformation <span class="math notranslate nohighlight">\(G_S\)</span> of a unit
Euclidean norm ball which is then shifted to <span class="math notranslate nohighlight">\(c_S\)</span>. Here, <span class="math notranslate nohighlight">\(G_S\)</span> is given by
<a class="reference internal" href="pycvxset.Ellipsoid.html#pycvxset.Ellipsoid.Ellipsoid.G" title="pycvxset.Ellipsoid.Ellipsoid.G"><code class="xref py py-attr docutils literal notranslate"><span class="pre">pycvxset.Ellipsoid.Ellipsoid.G</span></code></a>. See <a class="reference internal" href="pycvxset.Ellipsoid.html#pycvxset.Ellipsoid.Ellipsoid" title="pycvxset.Ellipsoid.Ellipsoid"><code class="xref py py-meth docutils literal notranslate"><span class="pre">pycvxset.Ellipsoid.Ellipsoid()</span></code></a> to obtain <span class="math notranslate nohighlight">\(G_S\)</span> and
<span class="math notranslate nohighlight">\(c_S\)</span> for broader classes of ellipsoids.</p></li>
<li><p>For p=’inf, the subtrahend is a zonotope characterized by (<span class="math notranslate nohighlight">\(G_S\)</span>, <span class="math notranslate nohighlight">\(c_S\)</span>).</p></li>
</ul>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>norm_type</strong> (<em>int</em><em> | </em><em>str</em>) – Norm type.</p></li>
<li><p><strong>G_S</strong> (<em>array_like</em>) – Affine transformation matrix (self.dim times N) for scaling the ball</p></li>
<li><p><strong>c_S</strong> (<em>array_like</em>) – Affine transformation vector (self.dim,) for translating the ball</p></li>
<li><p><strong>method</strong> (<em>str</em><em>, </em><em>optional</em>) – Approximation method to use. Can be one of [‘inner-least-squares’]. Defaults to
‘inner-least-squares’.</p></li>
</ul>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>ValueError</strong> – Norm type is not in [1, 2, ‘inf]</p></li>
<li><p><strong>ValueError</strong> – Mismatch in dimension (no. of columns of G_S, length of c_S, and self.dim should match)</p></li>
</ul>
</dd>
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>Approximated Pontryagin difference between self and the affine transformation of the
unit-norm ball.</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><a class="reference internal" href="#pycvxset.ConstrainedZonotope.ConstrainedZonotope" title="pycvxset.ConstrainedZonotope.ConstrainedZonotope">ConstrainedZonotope</a></p>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>For method ‘inner-least-squares’, this function implements Table 1 of <a class="reference internal" href="references.html#vwd24" id="id5"><span>[VWD24]</span></a>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pycvxset.ConstrainedZonotope.ConstrainedZonotope.cartesian_product">
<span class="sig-name descname"><span class="pre">cartesian_product</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">sequence_Q</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pycvxset.ConstrainedZonotope.ConstrainedZonotope.cartesian_product" title="Link to this definition">¶</a></dt>
<dd><p>Generate the Cartesian product of a set <span class="math notranslate nohighlight">\(\mathcal{Q}\)</span> (or a list of <cite>mathcal{Q}</cite>) with
<span class="math notranslate nohighlight">\(\mathcal{P}\)</span>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>sequence_Q</strong> (<em>list</em><em> | </em><em>tuple</em><em> | </em><a class="reference internal" href="pycvxset.Polytope.html#pycvxset.Polytope.Polytope" title="pycvxset.Polytope.Polytope"><em>Polytope</em></a><em> | </em><a class="reference internal" href="#pycvxset.ConstrainedZonotope.ConstrainedZonotope" title="pycvxset.ConstrainedZonotope.ConstrainedZonotope"><em>ConstrainedZonotope</em></a>) – List of sets to take Cartesian product with</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Cartesian product of self and all sets in sequence_Q</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="#pycvxset.ConstrainedZonotope.ConstrainedZonotope" title="pycvxset.ConstrainedZonotope.ConstrainedZonotope">ConstrainedZonotope</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pycvxset.ConstrainedZonotope.ConstrainedZonotope.chebyshev_centering">
<span class="sig-name descname"><span class="pre">chebyshev_centering</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pycvxset.ConstrainedZonotope.ConstrainedZonotope.chebyshev_centering" title="Link to this definition">¶</a></dt>
<dd><p>Computes a ball with the largest radius that fits within the constrained zonotope. The ball’s center is known as
the Chebyshev center, and its radius is the Chebyshev radius.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>ValueError</strong> – When the constrained zonotope is not full-dimensional</p></li>
<li><p><strong>ValueError</strong> – When the constrained zonotope is empty</p></li>
<li><p><strong>NotImplementedError</strong> – Unable to solve the linear program using CVXPY</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><dl class="simple">
<dt>A tuple with two items</dt><dd><ol class="arabic simple">
<li><p>center (numpy.ndarray): Approximate Chebyshev radius of the constrained zonotope</p></li>
<li><p>radius (float): Approximate Chebyshev radius of the constrained zonotope</p></li>
</ol>
</dd>
</dl>
</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>tuple</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>Unlike <a class="reference internal" href="pycvxset.Polytope.html#pycvxset.Polytope.Polytope.chebyshev_centering" title="pycvxset.Polytope.Polytope.chebyshev_centering"><code class="xref py py-meth docutils literal notranslate"><span class="pre">pycvxset.Polytope.Polytope.chebyshev_centering()</span></code></a>, this function computes an approximate Chebyshev
center and radius. Specifically, it guarantees that a ball of the computed radius, centered at the computed
center is contained in the constrained zonotope. However, it does not guarantee that the computed radius is the
radius of the largest possible ball contained in the given constrained zonotope. For more details, see <a class="reference internal" href="references.html#vws24" id="id6"><span>[VWS24]</span></a>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pycvxset.ConstrainedZonotope.ConstrainedZonotope.closest_point">
<span class="sig-name descname"><span class="pre">closest_point</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">points</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">p</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">2</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pycvxset.ConstrainedZonotope.ConstrainedZonotope.closest_point" title="Link to this definition">¶</a></dt>
<dd><p>Wrapper for <a class="reference internal" href="#pycvxset.ConstrainedZonotope.ConstrainedZonotope.project" title="pycvxset.ConstrainedZonotope.ConstrainedZonotope.project"><code class="xref py py-meth docutils literal notranslate"><span class="pre">project()</span></code></a> to compute the point in the convex set closest to the given point.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>points</strong> (<em>array_like</em>) – Points to project. Matrix (N times self.dim), where each row is a point.</p></li>
<li><p><strong>p</strong> (<em>str</em><em> | </em><em>int</em>) – Norm-type. It can be 1, 2, or ‘inf’. Defaults to 2.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Projection of points to the set as a 2D numpy.ndarray. These arrays have as many rows as points.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>numpy.ndarray</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>For more detailed description, see documentation for <a class="reference internal" href="#pycvxset.ConstrainedZonotope.ConstrainedZonotope.project" title="pycvxset.ConstrainedZonotope.ConstrainedZonotope.project"><code class="xref py py-meth docutils literal notranslate"><span class="pre">project()</span></code></a> function.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pycvxset.ConstrainedZonotope.ConstrainedZonotope.containment_constraints">
<span class="sig-name descname"><span class="pre">containment_constraints</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">flatten_order</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'F'</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycvxset/ConstrainedZonotope.html#ConstrainedZonotope.containment_constraints"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pycvxset.ConstrainedZonotope.ConstrainedZonotope.containment_constraints" title="Link to this definition">¶</a></dt>
<dd><p>Get CVXPY constraints for containment of x (a cvxpy.Variable) in a constrained zonotope.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x</strong> (<em>cvxpy.Variable</em>) – CVXPY variable to be optimized</p></li>
<li><p><strong>flatten_order</strong> (<em>char</em>) – Order to use for flatten (choose between “F”, “C”). Defaults to “F”, which
implements column-major flatten. In 2D, column-major flatten results in stacking rows horizontally to
achieve a single horizontal row.</p></li>
</ul>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>ValueError</strong> – When constrained zonotope is empty</p>
</dd>
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p><p>A tuple with two items:</p>
<ol class="arabic simple">
<li><p>constraint_list (list): CVXPY constraints for the containment of x in the constrained zonotope.</p></li>
<li><p>xi (cvxpy.Variable | None): CVXPY variable representing the latent dimension variable. It is None,
when the constrained zonotope is a single point.</p></li>
</ol>
</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>tuple</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pycvxset.ConstrainedZonotope.ConstrainedZonotope.contains">
<span class="sig-name descname"><span class="pre">contains</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">Q</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">time_limit</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">60</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pycvxset.ConstrainedZonotope.ConstrainedZonotope.contains" title="Link to this definition">¶</a></dt>
<dd><p>Check containment of a set <span class="math notranslate nohighlight">\(\mathcal{Q}\)</span> (could be a polytope or a constrained zonotope), or a collection
of points <span class="math notranslate nohighlight">\(Q \in \mathbb{R}^{n_Q \times \mathcal{P}.\text{dim}}\)</span> in the given constrained zonotope.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>Q</strong> (<em>array_like</em><em> | </em><a class="reference internal" href="pycvxset.Polytope.html#pycvxset.Polytope.Polytope" title="pycvxset.Polytope.Polytope"><em>Polytope</em></a><em> | </em><a class="reference internal" href="#pycvxset.ConstrainedZonotope.ConstrainedZonotope" title="pycvxset.ConstrainedZonotope.ConstrainedZonotope"><em>ConstrainedZonotope</em></a>) – Polytope object, ConstrainedZonotope object, or a collection of
points to be tested for containment within the constrained zonotope. When providing a collection of points,
Q is a matrix (N times self.dim) with each row is a point.</p></li>
<li><p><strong>verbose</strong> (<em>bool</em><em>, </em><em>optional</em>) – Verbosity flag to provide cvxpy when solving the MIQP related to checking containment
of a constrained zonotope within another constrained zonotope. Defaults to False.</p></li>
<li><p><strong>time_limit</strong> (<em>int</em><em>, </em><em>optional</em>) – Time limit in seconds for GUROBI solver when solving the MIQP related to checking
containment of a constrained zonotope within another constrained zonotope. Set time_limit to np.inf if no
limit is desired. Defaults to 60s (see constants.py).</p></li>
</ul>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>ValueError</strong> – Dimension mismatch between Q and the constrained zonotope</p></li>
<li><p><strong>ValueError</strong> – Q is Ellipsoid</p></li>
<li><p><strong>ValueError</strong> – Unable to perform containment check between two constrained zonotopes (including time_limit issues)</p></li>
<li><p><strong>NotImplementedError</strong> – GUROBI is not installed when checking containment of two constrained zonotopes</p></li>
<li><p><strong>NotImplementedError</strong> – Failed to check containment between two constrained zonotopes, due to an unhandled status</p></li>
</ul>
</dd>
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>Boolean corresponding to <span class="math notranslate nohighlight">\(\mathcal{Q}\subseteq\mathcal{P}\)</span> or
<span class="math notranslate nohighlight">\(\mathcal{Q}\in\mathcal{P}\)</span> .</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>bool | numpy.ndarray([bool])</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<ul class="simple">
<li><p>We use <span class="math notranslate nohighlight">\(\mathcal{P}\)</span> to denote the constrained zonotope characterized by self.</p></li>
<li><p>When Q is a constrained zonotope, a bool is returned which is True if and only if <span class="math notranslate nohighlight">\(\mathcal{Q}\subseteq
\mathcal{P}\)</span>. This function uses the non-convex programming capabilities of GUROBI (via CVXPY) to check
containment between two constrained zonotopes.</p></li>
<li><p>When Q is a polytope, a bool is returned which is True if and only if <span class="math notranslate nohighlight">\(\mathcal{Q}\subseteq
\mathcal{P}\)</span>.</p>
<ul>
<li><p>When Q is in V-Rep, the containment problem simplifies to checking if all vertices of Q are
contained <span class="math notranslate nohighlight">\(\mathcal{P}\)</span>.</p></li>
<li><p>When Q is in H-Rep, this function converts Q into a constrained zonotope, and then checks for containment.</p></li>
</ul>
</li>
<li><p>When Q is a single n-dimensional point, a bool is returned which is True if and only if <span class="math notranslate nohighlight">\(Q\in
\mathcal{P}\)</span>. This function uses <a class="reference internal" href="#pycvxset.ConstrainedZonotope.ConstrainedZonotope.distance" title="pycvxset.ConstrainedZonotope.ConstrainedZonotope.distance"><code class="xref py py-meth docutils literal notranslate"><span class="pre">distance()</span></code></a> to check containment of a point in a constrained zonotope.</p></li>
<li><p>When Q is a collection of n-dimensional points (Q is a matrix with each row describing a point), an array
of is returned where each element is True if and only if <span class="math notranslate nohighlight">\(Q_i\in \mathcal{P}\)</span>.  This function uses
<a class="reference internal" href="#pycvxset.ConstrainedZonotope.ConstrainedZonotope.distance" title="pycvxset.ConstrainedZonotope.ConstrainedZonotope.distance"><code class="xref py py-meth docutils literal notranslate"><span class="pre">distance()</span></code></a> to check containment of a point in a constrained zonotope.</p></li>
</ul>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>This function requires <a class="reference external" href="https://pypi.org/project/gurobipy/">gurobipy</a> when checking if the
<a class="reference internal" href="#pycvxset.ConstrainedZonotope.ConstrainedZonotope" title="pycvxset.ConstrainedZonotope.ConstrainedZonotope"><code class="xref py py-class docutils literal notranslate"><span class="pre">ConstrainedZonotope</span></code></a> object represented by <cite>self</cite> contains a <a class="reference internal" href="#pycvxset.ConstrainedZonotope.ConstrainedZonotope" title="pycvxset.ConstrainedZonotope.ConstrainedZonotope"><code class="xref py py-class docutils literal notranslate"><span class="pre">ConstrainedZonotope</span></code></a> object <cite>Q</cite> or
<a class="reference internal" href="pycvxset.Polytope.html#pycvxset.Polytope.Polytope" title="pycvxset.Polytope.Polytope"><code class="xref py py-class docutils literal notranslate"><span class="pre">pycvxset.Polytope.Polytope</span></code></a> object <cite>Q</cite> in H-Rep.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pycvxset.ConstrainedZonotope.ConstrainedZonotope.copy">
<span class="sig-name descname"><span class="pre">copy</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycvxset/ConstrainedZonotope.html#ConstrainedZonotope.copy"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pycvxset.ConstrainedZonotope.ConstrainedZonotope.copy" title="Link to this definition">¶</a></dt>
<dd><p>Get a copy of the constrained zonotope</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pycvxset.ConstrainedZonotope.ConstrainedZonotope.distance">
<span class="sig-name descname"><span class="pre">distance</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">points</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">p</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">2</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pycvxset.ConstrainedZonotope.ConstrainedZonotope.distance" title="Link to this definition">¶</a></dt>
<dd><p>Wrapper for <a class="reference internal" href="#pycvxset.ConstrainedZonotope.ConstrainedZonotope.project" title="pycvxset.ConstrainedZonotope.ConstrainedZonotope.project"><code class="xref py py-meth docutils literal notranslate"><span class="pre">project()</span></code></a> to compute distance of a point to a convex set.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>points</strong> (<em>array_like</em>) – Points to project. Matrix (N times self.dim), where each row is a point.</p></li>
<li><p><strong>p</strong> (<em>int</em><em> | </em><em>str</em>) – Norm-type. It can be 1, 2, or ‘inf’. Defaults to 2.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Distance of points to the set as a 1D numpy.ndarray. These arrays have as many rows as points.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>numpy.ndarray</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>For more detailed description, see documentation for <a class="reference internal" href="#pycvxset.ConstrainedZonotope.ConstrainedZonotope.project" title="pycvxset.ConstrainedZonotope.ConstrainedZonotope.project"><code class="xref py py-meth docutils literal notranslate"><span class="pre">project()</span></code></a> function.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pycvxset.ConstrainedZonotope.ConstrainedZonotope.extreme">
<span class="sig-name descname"><span class="pre">extreme</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">eta</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pycvxset.ConstrainedZonotope.ConstrainedZonotope.extreme" title="Link to this definition">¶</a></dt>
<dd><p>Wrapper for <a class="reference internal" href="#pycvxset.ConstrainedZonotope.ConstrainedZonotope.support" title="pycvxset.ConstrainedZonotope.ConstrainedZonotope.support"><code class="xref py py-meth docutils literal notranslate"><span class="pre">support()</span></code></a> to compute the extreme point.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>eta</strong> (<em>array_like</em>) – Support directions. Matrix (N times self.dim), where each row is a support direction.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Support vector evaluation(s) as a 2D numpy.ndarray. The array has as many rows as eta.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>numpy.ndarray</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>For more detailed description, see documentation for <a class="reference internal" href="#pycvxset.ConstrainedZonotope.ConstrainedZonotope.support" title="pycvxset.ConstrainedZonotope.ConstrainedZonotope.support"><code class="xref py py-meth docutils literal notranslate"><span class="pre">support()</span></code></a> function.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pycvxset.ConstrainedZonotope.ConstrainedZonotope.interior_point">
<span class="sig-name descname"><span class="pre">interior_point</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pycvxset.ConstrainedZonotope.ConstrainedZonotope.interior_point" title="Link to this definition">¶</a></dt>
<dd><p>Compute an interior point of the constrained zonotope.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>A point that lies in the (relative) interior of the constrained zonotope.</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>numpy.ndarray</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>This function returns <span class="math notranslate nohighlight">\(G v + c\)</span>, where <span class="math notranslate nohighlight">\(v\)</span> is the Chebyshev center of the polytope
<span class="math notranslate nohighlight">\(B_\infty(A_e, b_e)= \{\xi\ |\ \| \xi \|_\infty \leq 1, A_e \xi = b_e\} \subset \mathbb{R}^{N_C}\)</span>. See
<a class="reference internal" href="pycvxset.Polytope.html#pycvxset.Polytope.Polytope.chebyshev_centering" title="pycvxset.Polytope.Polytope.chebyshev_centering"><code class="xref py py-meth docutils literal notranslate"><span class="pre">pycvxset.Polytope.Polytope.chebyshev_centering()</span></code></a> for more details on Chebyshev centering.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pycvxset.ConstrainedZonotope.ConstrainedZonotope.intersection">
<span class="sig-name descname"><span class="pre">intersection</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">Q</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pycvxset.ConstrainedZonotope.ConstrainedZonotope.intersection" title="Link to this definition">¶</a></dt>
<dd><p>Compute the intersection of constrained zonotope with another constrained zonotope or polytope.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>Q</strong> (<a class="reference internal" href="#pycvxset.ConstrainedZonotope.ConstrainedZonotope" title="pycvxset.ConstrainedZonotope.ConstrainedZonotope"><em>ConstrainedZonotope</em></a><em> | </em><a class="reference internal" href="pycvxset.Polytope.html#pycvxset.Polytope.Polytope" title="pycvxset.Polytope.Polytope"><em>Polytope</em></a>) – Set to intersect with</p>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>TypeError</strong> – When Q is neither a ConstrainedZonotope object or a Polytope object</p>
</dd>
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>Intersection of self with Q</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><a class="reference internal" href="#pycvxset.ConstrainedZonotope.ConstrainedZonotope" title="pycvxset.ConstrainedZonotope.ConstrainedZonotope">ConstrainedZonotope</a></p>
</dd>
</dl>
<p class="rubric">Notes</p>
<ul class="simple">
<li><p>When Q is a constrained zonotope, this function uses <a class="reference internal" href="#pycvxset.ConstrainedZonotope.ConstrainedZonotope.intersection_under_inverse_affine_map" title="pycvxset.ConstrainedZonotope.ConstrainedZonotope.intersection_under_inverse_affine_map"><code class="xref py py-meth docutils literal notranslate"><span class="pre">intersection_under_inverse_affine_map()</span></code></a> with R set
to identity matrix.</p></li>
<li><p>When Q is a polytope in H-Rep, this function uses  <a class="reference internal" href="#pycvxset.ConstrainedZonotope.ConstrainedZonotope.intersection_with_halfspaces" title="pycvxset.ConstrainedZonotope.ConstrainedZonotope.intersection_with_halfspaces"><code class="xref py py-meth docutils literal notranslate"><span class="pre">intersection_with_halfspaces()</span></code></a> and
<a class="reference internal" href="#pycvxset.ConstrainedZonotope.ConstrainedZonotope.intersection_with_affine_set" title="pycvxset.ConstrainedZonotope.ConstrainedZonotope.intersection_with_affine_set"><code class="xref py py-meth docutils literal notranslate"><span class="pre">intersection_with_affine_set()</span></code></a>.</p></li>
<li><p>When Q is a polytope in V-Rep, this function converts Q into a constrained zonotope to avoid a halfspace
enumeration.</p></li>
</ul>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pycvxset.ConstrainedZonotope.ConstrainedZonotope.intersection_under_inverse_affine_map">
<span class="sig-name descname"><span class="pre">intersection_under_inverse_affine_map</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">Y</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">R</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pycvxset.ConstrainedZonotope.ConstrainedZonotope.intersection_under_inverse_affine_map" title="Link to this definition">¶</a></dt>
<dd><p>Compute the intersection of constrained zonotope with another constrained zonotope under an inverse affine map</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>Y</strong> (<a class="reference internal" href="#pycvxset.ConstrainedZonotope.ConstrainedZonotope" title="pycvxset.ConstrainedZonotope.ConstrainedZonotope"><em>ConstrainedZonotope</em></a>) – Set to intersect with</p></li>
<li><p><strong>R</strong> (<em>array_like</em>) – Matrix (Y.dim times self.dim) for the inverse-affine map.</p></li>
</ul>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>ValueError</strong> – When Y is not a ConstrainedZonotope</p></li>
<li><p><strong>ValueError</strong> – When R is not of correct dimension</p></li>
</ul>
</dd>
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>Intersection of self with Y under an inverse affine map R. Specifically, given constrained
zonotopes <span class="math notranslate nohighlight">\(\mathcal{P}\)</span> (self) and <span class="math notranslate nohighlight">\(\mathcal{Y}\)</span>, and a matrix <span class="math notranslate nohighlight">\(R\)</span>, we compute the set
<span class="math notranslate nohighlight">\(\mathcal{P}\cap_R\mathcal{Y}=\{x \in \mathcal{P}| Rx \in \mathcal{Y}\}\)</span>. When <span class="math notranslate nohighlight">\(R\)</span> is
invertible, <span class="math notranslate nohighlight">\(\mathcal{P}\cap_R\mathcal{Y}=(R^{-1}\mathcal{P})\cap\mathcal{Y}\)</span>.</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><a class="reference internal" href="#pycvxset.ConstrainedZonotope.ConstrainedZonotope" title="pycvxset.ConstrainedZonotope.ConstrainedZonotope">ConstrainedZonotope</a></p>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>This function implements (13) of <a class="reference internal" href="references.html#sdgr16" id="id7"><span>[SDGR16]</span></a>. This function does not require R to be invertible.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pycvxset.ConstrainedZonotope.ConstrainedZonotope.intersection_with_affine_set">
<span class="sig-name descname"><span class="pre">intersection_with_affine_set</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">Ae</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">be</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pycvxset.ConstrainedZonotope.ConstrainedZonotope.intersection_with_affine_set" title="Link to this definition">¶</a></dt>
<dd><p>Compute the intersection of a constrained zonotope with an affine set.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>Ae</strong> (<em>array_like</em>) – Equality coefficient matrix (N times self.dim) that define the affine set <span class="math notranslate nohighlight">\(\{x|A_ex =
b_e\}\)</span>.</p></li>
<li><p><strong>be</strong> (<em>array_like</em>) – Equality constant vector (N,) that define the affine set <span class="math notranslate nohighlight">\(\{x| A_ex = b_e\}\)</span>.</p></li>
</ul>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>ValueError</strong> – When the number of columns in Ae is different from self.dim</p>
</dd>
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>The intersection of a constrained zonotope with the affine set.</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><a class="reference internal" href="#pycvxset.ConstrainedZonotope.ConstrainedZonotope" title="pycvxset.ConstrainedZonotope.ConstrainedZonotope">ConstrainedZonotope</a></p>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>This function implements imposes the constraints <span class="math notranslate nohighlight">\(\{A_ex = b_e\}\)</span> as constraints in the latent dimension
of the constrained zonotope — <span class="math notranslate nohighlight">\(A_e (G \xi + c) = b_e\)</span> for every feasible <span class="math notranslate nohighlight">\(\xi\)</span>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pycvxset.ConstrainedZonotope.ConstrainedZonotope.intersection_with_halfspaces">
<span class="sig-name descname"><span class="pre">intersection_with_halfspaces</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">A</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">b</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pycvxset.ConstrainedZonotope.ConstrainedZonotope.intersection_with_halfspaces" title="Link to this definition">¶</a></dt>
<dd><p>Compute the intersection of a constrained zonotope with a collection of halfspaces (polyhedron).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>A</strong> (<em>array_like</em>) – Inequality coefficient matrix (N times self.dim) that define the polyhedron <span class="math notranslate nohighlight">\(\{x|Ax \leq
b\}\)</span>.</p></li>
<li><p><strong>b</strong> (<em>array_like</em>) – Inequality constant vector (N,) that define the polyhedron <span class="math notranslate nohighlight">\(\{x| Ax \leq b\}\)</span>.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The intersection of a constrained zonotope with a collection of halfspaces.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="#pycvxset.ConstrainedZonotope.ConstrainedZonotope" title="pycvxset.ConstrainedZonotope.ConstrainedZonotope">ConstrainedZonotope</a></p>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>This function implements (10) of <a class="reference internal" href="references.html#rk22" id="id8"><span>[RK22]</span></a> for each halfspace. We skip redundant inequalities when encountered and
we return empty set when intersection yields an empty set.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pycvxset.ConstrainedZonotope.ConstrainedZonotope.inverse_affine_map_under_invertible_matrix">
<span class="sig-name descname"><span class="pre">inverse_affine_map_under_invertible_matrix</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">M</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pycvxset.ConstrainedZonotope.ConstrainedZonotope.inverse_affine_map_under_invertible_matrix" title="Link to this definition">¶</a></dt>
<dd><p>Compute the inverse affine map of a constrained zonotope for a given matrix M.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>M</strong> (<em>array_like</em>) – Square invertible matrix of dimension self.dim</p>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>ValueError</strong> – M is not convertible into a 2D float array</p></li>
<li><p><strong>ValueError</strong> – M is not square</p></li>
<li><p><strong>ValueError</strong> – M is not invertible</p></li>
</ul>
</dd>
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>Inverse affine map of self under M. Specifically, Given a constrained zonotope
<span class="math notranslate nohighlight">\(\mathcal{P}\)</span> and an invertible self.dim-dimensional matrix <span class="math notranslate nohighlight">\(M\in\mathbb{R}^{\mathcal{P}.dim\times
\mathcal{P}.\text{dim}}\)</span>, this function computes the constrained zonotope <span class="math notranslate nohighlight">\(\mathcal{R}=M^{-1}\mathcal{P}\)</span>.</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><a class="reference internal" href="#pycvxset.ConstrainedZonotope.ConstrainedZonotope" title="pycvxset.ConstrainedZonotope.ConstrainedZonotope">ConstrainedZonotope</a></p>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>This function is a wrapper for <a class="reference internal" href="#pycvxset.ConstrainedZonotope.ConstrainedZonotope.affine_map" title="pycvxset.ConstrainedZonotope.ConstrainedZonotope.affine_map"><code class="xref py py-meth docutils literal notranslate"><span class="pre">affine_map()</span></code></a>. We require M to be invertible in order to ensure that the
resulting set is representable as a constrained zonotope.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pycvxset.ConstrainedZonotope.ConstrainedZonotope.maximum_volume_inscribing_ellipsoid">
<span class="sig-name descname"><span class="pre">maximum_volume_inscribing_ellipsoid</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pycvxset.ConstrainedZonotope.ConstrainedZonotope.maximum_volume_inscribing_ellipsoid" title="Link to this definition">¶</a></dt>
<dd><p>Compute the maximum volume ellipsoid that fits within the given constrained zonotope.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>ValueError</strong> – When the constrained zonotope is not full-dimensional</p></li>
<li><p><strong>ValueError</strong> – When the constrained zonotope is empty</p></li>
<li><p><strong>NotImplementedError</strong> – Unable to solve the convex program using CVXPY</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><dl class="simple">
<dt>A tuple with three items:</dt><dd><ol class="arabic simple">
<li><p>center (numpy.ndarray): Approximate maximum volume inscribed ellipsoid’s center</p></li>
<li><p>shape_matrix (numpy.ndarray): Approximate maximum volume inscribed ellipsoid’s shape matrix</p></li>
<li><p>sqrt_shape_matrix (numpy.ndarray): Approximate maximum volume inscribed ellipsoid’s square root of shape
matrix.</p></li>
</ol>
</dd>
</dl>
</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>tuple</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>Unlike <a class="reference internal" href="pycvxset.Polytope.html#pycvxset.Polytope.Polytope.maximum_volume_inscribing_ellipsoid" title="pycvxset.Polytope.Polytope.maximum_volume_inscribing_ellipsoid"><code class="xref py py-meth docutils literal notranslate"><span class="pre">pycvxset.Polytope.Polytope.maximum_volume_inscribing_ellipsoid()</span></code></a>, this function computes an
approximate maximum volume inscribed ellipsoid. Specifically, it guarantees that the computed ellipsoid is
contained in the constrained zonotope. However, it does not guarantee that the computed ellipsoid is the largest
possible ellipsoid (in terms of volume) contained in the given constrained zonotope. For more details, see
<a class="reference internal" href="references.html#vws24" id="id9"><span>[VWS24]</span></a>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pycvxset.ConstrainedZonotope.ConstrainedZonotope.minimize">
<span class="sig-name descname"><span class="pre">minimize</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">objective_to_minimize</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cvxpy_args</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">task_str</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">''</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pycvxset.ConstrainedZonotope.ConstrainedZonotope.minimize" title="Link to this definition">¶</a></dt>
<dd><p>Solve a convex program with CVXPY objective subject to containment constraints.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x</strong> (<em>cvxpy.Variable</em>) – CVXPY variable to be optimized</p></li>
<li><p><strong>objective_to_minimize</strong> (<em>cvxpy.Expression</em>) – CVXPY expression to be minimized</p></li>
<li><p><strong>cvxpy_args</strong> (<em>dict</em>) – CVXPY arguments to be passed to the solver</p></li>
<li><p><strong>task_str</strong> (<em>str</em><em>, </em><em>optional</em>) – Task string to be used in error messages. Defaults to ‘’.</p></li>
</ul>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>NotImplementedError</strong> – Unable to solve problem using CVXPY</p>
</dd>
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p><dl class="simple">
<dt>A tuple with three items:</dt><dd><ol class="arabic simple">
<li><p>x.value (numpy.ndarray): Optimal value of x. np.nan * np.ones((self.dim,)) if the problem is not solved.</p></li>
<li><p>problem.value (float): Optimal value of the convex program. np.inf if the problem is infeasible, -np.inf
if problem is unbounded, and finite otherwise.</p></li>
<li><p>problem_status (str): Status of the problem</p></li>
</ol>
</dd>
</dl>
</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>tuple</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>This function uses <a class="reference internal" href="#pycvxset.ConstrainedZonotope.ConstrainedZonotope.containment_constraints" title="pycvxset.ConstrainedZonotope.ConstrainedZonotope.containment_constraints"><code class="xref py py-meth docutils literal notranslate"><span class="pre">containment_constraints()</span></code></a> to obtain the list of CVXPY expressions that form the
containment constraints on x.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>Please pay attention to the NotImplementedError generated by this function. It may be possible to get CVXPY to
solve the same problem by switching the solver. For example, consider the following code block.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span><span class="w"> </span><span class="nn">pycvxset</span><span class="w"> </span><span class="kn">import</span> <span class="n">Polytope</span>
<span class="n">P</span> <span class="o">=</span> <span class="n">Polytope</span><span class="p">(</span><span class="n">A</span><span class="o">=</span><span class="p">[[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">]],</span> <span class="n">b</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
<span class="n">P</span><span class="o">.</span><span class="n">cvxpy_args_lp</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;solver&#39;</span><span class="p">:</span> <span class="s1">&#39;CLARABEL&#39;</span><span class="p">}</span>    <span class="c1"># Default solver used in pycvxset</span>
<span class="k">try</span><span class="p">:</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Is polytope bounded?&#39;</span><span class="p">,</span> <span class="n">P</span><span class="o">.</span><span class="n">is_bounded</span><span class="p">)</span>
<span class="k">except</span> <span class="ne">NotImplementedError</span> <span class="k">as</span> <span class="n">err</span><span class="p">:</span>
    <span class="nb">print</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">err</span><span class="p">))</span>
<span class="n">P</span><span class="o">.</span><span class="n">cvxpy_args_lp</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;solver&#39;</span><span class="p">:</span> <span class="s1">&#39;OSQP&#39;</span><span class="p">}</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Is polytope bounded?&#39;</span><span class="p">,</span> <span class="n">P</span><span class="o">.</span><span class="n">is_bounded</span><span class="p">)</span>
</pre></div>
</div>
<p>This code block produces the following output:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>Unable to solve the task (support function evaluation of the set at eta = [-0. -1.]). CVXPY returned error:
Solver &#39;CLARABEL&#39; failed. Try another solver, or solve with verbose=True for more information.

Is polytope bounded? False
</pre></div>
</div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pycvxset.ConstrainedZonotope.ConstrainedZonotope.minimum_volume_circumscribing_rectangle">
<span class="sig-name descname"><span class="pre">minimum_volume_circumscribing_rectangle</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pycvxset.ConstrainedZonotope.ConstrainedZonotope.minimum_volume_circumscribing_rectangle" title="Link to this definition">¶</a></dt>
<dd><p>Compute the minimum volume circumscribing rectangle for a set.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>ValueError</strong> – When set is empty</p></li>
<li><p><strong>ValueError</strong> – When set is unbounded OR solver error!</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><dl class="simple">
<dt>A tuple of two elements</dt><dd><ul class="simple">
<li><p>lb (numpy.ndarray): Lower bound <span class="math notranslate nohighlight">\(l\)</span> on the set,
<span class="math notranslate nohighlight">\(\mathcal{P}\subseteq\{l\}\oplus\mathbb{R}_{\geq 0}\)</span>.</p></li>
<li><p>ub (numpy.ndarray): Upper bound <span class="math notranslate nohighlight">\(u\)</span> on the set,
<span class="math notranslate nohighlight">\(\mathcal{P}\subseteq\{u\}\oplus(-\mathbb{R}_{\geq 0})\)</span>.</p></li>
</ul>
</dd>
</dl>
</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>tuple</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>This function computes the lower/upper bound by an element-wise support computation (2n linear programs), where
n is attr:<cite>self.dim</cite>. To reuse the <a class="reference internal" href="#pycvxset.ConstrainedZonotope.ConstrainedZonotope.support" title="pycvxset.ConstrainedZonotope.ConstrainedZonotope.support"><code class="xref py py-meth docutils literal notranslate"><span class="pre">support()</span></code></a> function for the lower bound computation, we solve the
optimization for each <span class="math notranslate nohighlight">\(i\in\{1,2,...,n\}\)</span>,</p>
<div class="math notranslate nohighlight">
\[\inf_{x\in\mathcal{P}} e_i^\top x=-\sup_{x\in\mathcal{P}} -e_i^\top x=-\rho_{\mathcal{P}}(-e_i),\]</div>
<p>where <span class="math notranslate nohighlight">\(e_i\in\mathbb{R}^n\)</span> denotes the standard coordinate vector, and <span class="math notranslate nohighlight">\(\rho_{\mathcal{P}}\)</span> is the
support function of <span class="math notranslate nohighlight">\(\mathcal{P}\)</span>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pycvxset.ConstrainedZonotope.ConstrainedZonotope.minus">
<span class="sig-name descname"><span class="pre">minus</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">Q</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pycvxset.ConstrainedZonotope.ConstrainedZonotope.minus" title="Link to this definition">¶</a></dt>
<dd><p>Implement - operation: Pontryagin difference with a constrained zonotope minuend</p>
<p>When Q is an ellipsoid or a zonotope, minus returns an inner-approximation of the set corresponding to the
Pontryagin difference of a constrained zonotope and Q. When Q is a point or a singleton set, an exact set
corresponding to the translation by -Q or -Q.c is returned.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>Q</strong> (<em>array_like</em><em> | </em><a class="reference internal" href="pycvxset.Ellipsoid.html#pycvxset.Ellipsoid.Ellipsoid" title="pycvxset.Ellipsoid.Ellipsoid"><em>Ellipsoid</em></a><em> | </em><a class="reference internal" href="#pycvxset.ConstrainedZonotope.ConstrainedZonotope" title="pycvxset.ConstrainedZonotope.ConstrainedZonotope"><em>ConstrainedZonotope</em></a>) – Point/set to use as subtrahend in the Pontryagin difference.</p>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>TypeError</strong> – When Q is not one of the following — convertible into a 1D numpy array, or an ellipsoid, or a
    zonotope.</p></li>
<li><p><strong>ValueError</strong> – When Q has a dimension mismatch with self.</p></li>
<li><p><strong>UserWarning</strong> – When using with Q that is a set, warn that an inner-approximation is returned.</p></li>
</ul>
</dd>
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>Pontryagin difference of self and Q</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><a class="reference internal" href="#pycvxset.ConstrainedZonotope.ConstrainedZonotope" title="pycvxset.ConstrainedZonotope.ConstrainedZonotope">ConstrainedZonotope</a></p>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>This function uses <a class="reference internal" href="#pycvxset.ConstrainedZonotope.ConstrainedZonotope.approximate_pontryagin_difference" title="pycvxset.ConstrainedZonotope.ConstrainedZonotope.approximate_pontryagin_difference"><code class="xref py py-meth docutils literal notranslate"><span class="pre">approximate_pontryagin_difference()</span></code></a> when Q is a set and uses <a class="reference internal" href="#pycvxset.ConstrainedZonotope.ConstrainedZonotope.plus" title="pycvxset.ConstrainedZonotope.ConstrainedZonotope.plus"><code class="xref py py-meth docutils literal notranslate"><span class="pre">plus()</span></code></a> when Q is a
point.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pycvxset.ConstrainedZonotope.ConstrainedZonotope.plot">
<span class="sig-name descname"><span class="pre">plot</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">method</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'inner'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ax</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">direction_vectors</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_vertices</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_halfspaces</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">patch_args</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">vertex_args</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">center_args</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">autoscale_enable</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">decimal_precision</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">3</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pycvxset.ConstrainedZonotope.ConstrainedZonotope.plot" title="Link to this definition">¶</a></dt>
<dd><p>Plot a polytopic approximation of the set.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>method</strong> (<em>str</em><em>, </em><em>optional</em>) – Type of polytopic approximation to use. Can be [“inner” or “outer”]. Defaults to
“inner”.</p></li>
<li><p><strong>ax</strong> (<em>axis object</em><em>, </em><em>optional</em>) – Axis on which the patch is to be plotted</p></li>
<li><p><strong>direction_vectors</strong> (<em>array_like</em><em>, </em><em>optional</em>) – Directions to use when performing ray shooting. Matrix (N times
self.dim) for some N &gt;= 1. Defaults to None, in which case we use
<a class="reference internal" href="pycvxset.common.html#pycvxset.common.spread_points_on_a_unit_sphere" title="pycvxset.common.spread_points_on_a_unit_sphere"><code class="xref py py-meth docutils literal notranslate"><span class="pre">pycvxset.common.spread_points_on_a_unit_sphere()</span></code></a> to compute the direction vectors.</p></li>
<li><p><strong>n_vertices</strong> (<em>int</em><em>, </em><em>optional</em>) – Number of vertices to use when computing the polytopic inner-approximation. Ignored
if method is “outer” or when direction_vectors are provided. More than n_vertices may be used in some cases
(see notes). Defaults to None.</p></li>
<li><p><strong>n_halfspaces</strong> (<em>int</em><em>, </em><em>optional</em>) – Number of halfspaces to use when computing the polytopic outer-approximation.
Ignored if method is “outer” or when direction_vectors are provided. More than n_halfspaces may be used in
some cases (see notes). Defaults to None.</p></li>
<li><p><strong>patch_args</strong> (<em>dict</em><em>, </em><em>optional</em>) – Arguments to pass for plotting faces and edges. See
<a class="reference internal" href="pycvxset.Polytope.html#pycvxset.Polytope.Polytope.plot" title="pycvxset.Polytope.Polytope.plot"><code class="xref py py-meth docutils literal notranslate"><span class="pre">pycvxset.Polytope.Polytope.plot()</span></code></a> for more details. Defaults to None.</p></li>
<li><p><strong>vertex_args</strong> (<em>dict</em><em>, </em><em>optional</em>) – Arguments to pass for plotting vertices. See
<a class="reference internal" href="pycvxset.Polytope.html#pycvxset.Polytope.Polytope.plot" title="pycvxset.Polytope.Polytope.plot"><code class="xref py py-meth docutils literal notranslate"><span class="pre">pycvxset.Polytope.Polytope.plot()</span></code></a> for more details. Defaults to None.</p></li>
<li><p><strong>center_args</strong> (<em>dict</em><em>, </em><em>optional</em>) – For ellipsoidal set, arguments to pass to scatter plot for the center. If a label
is desired, pass it in center_args.</p></li>
<li><p><strong>autoscale_enable</strong> (<em>bool</em><em>, </em><em>optional</em>) – When set to True, matplotlib adjusts axes to view full polytope. See
<a class="reference internal" href="pycvxset.Polytope.html#pycvxset.Polytope.Polytope.plot" title="pycvxset.Polytope.Polytope.plot"><code class="xref py py-meth docutils literal notranslate"><span class="pre">pycvxset.Polytope.Polytope.plot()</span></code></a> for more details. Defaults to True.</p></li>
<li><p><strong>decimal_precision</strong> (<em>int</em><em>, </em><em>optional</em>) – When plotting a 3D polytope that is in V-Rep and not in H-Rep, we round
vertex to the specified precision to avoid numerical issues. Defaults to PLOTTING_DECIMAL_PRECISION_CDD
specified in pycvxset.common.constants.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>See <a class="reference internal" href="pycvxset.Polytope.html#pycvxset.Polytope.Polytope.plot" title="pycvxset.Polytope.Polytope.plot"><code class="xref py py-meth docutils literal notranslate"><span class="pre">pycvxset.Polytope.Polytope.plot()</span></code></a> for details.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>tuple</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>This function is a wrapper for <a class="reference internal" href="#pycvxset.ConstrainedZonotope.ConstrainedZonotope.polytopic_inner_approximation" title="pycvxset.ConstrainedZonotope.ConstrainedZonotope.polytopic_inner_approximation"><code class="xref py py-meth docutils literal notranslate"><span class="pre">polytopic_inner_approximation()</span></code></a> and <a class="reference internal" href="#pycvxset.ConstrainedZonotope.ConstrainedZonotope.polytopic_outer_approximation" title="pycvxset.ConstrainedZonotope.ConstrainedZonotope.polytopic_outer_approximation"><code class="xref py py-meth docutils literal notranslate"><span class="pre">polytopic_outer_approximation()</span></code></a>
for more details in polytope construction.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pycvxset.ConstrainedZonotope.ConstrainedZonotope.plus">
<span class="sig-name descname"><span class="pre">plus</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">Q</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pycvxset.ConstrainedZonotope.ConstrainedZonotope.plus" title="Link to this definition">¶</a></dt>
<dd><p>Add a point or a set Q to a constrained zonotope (Minkowski sum).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>Q</strong> (<em>array_like</em><em> | </em><a class="reference internal" href="pycvxset.Polytope.html#pycvxset.Polytope.Polytope" title="pycvxset.Polytope.Polytope"><em>Polytope</em></a><em> | </em><a class="reference internal" href="#pycvxset.ConstrainedZonotope.ConstrainedZonotope" title="pycvxset.ConstrainedZonotope.ConstrainedZonotope"><em>ConstrainedZonotope</em></a>) – The point or set to add</p>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>TypeError</strong> – When Q is not one of the following — convertible into a 1D numpy array or a constrained zonotope.</p></li>
<li><p><strong>ValueError</strong> – When Q has a dimension mismatch with self.</p></li>
<li><p><strong>UserWarning</strong> – When using with Q that is a set, warn that an inner-approximation is returned.</p></li>
</ul>
</dd>
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>Minkowski sum of self and Q.</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><a class="reference internal" href="#pycvxset.ConstrainedZonotope.ConstrainedZonotope" title="pycvxset.ConstrainedZonotope.ConstrainedZonotope">ConstrainedZonotope</a></p>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>Given a constrained zonotope <span class="math notranslate nohighlight">\(\mathcal{P}\)</span> and a set <span class="math notranslate nohighlight">\(Q\)</span>, this function computes the Minkowski sum
of Q and the constrained zonotope, defined as <span class="math notranslate nohighlight">\(\mathcal{R}=\{x + q|x\in\mathcal{P}, q\in\mathcal{Q}\}\)</span>. On
the other hand, when Q is a point, this function computes the constrained zonotope <span class="math notranslate nohighlight">\(\mathcal{R}=\{x +
Q|x\in\mathcal{P}\}\)</span>.</p>
<p>This function implements (12) of <a class="reference internal" href="references.html#sdgr16" id="id10"><span>[SDGR16]</span></a> when Q is a constrained zonotope. When Q is a Polytope, this function
converts it into a constrained zonotope, and then uses (12) of <a class="reference internal" href="references.html#sdgr16" id="id11"><span>[SDGR16]</span></a>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pycvxset.ConstrainedZonotope.ConstrainedZonotope.polytopic_inner_approximation">
<span class="sig-name descname"><span class="pre">polytopic_inner_approximation</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">direction_vectors</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_vertices</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pycvxset.ConstrainedZonotope.ConstrainedZonotope.polytopic_inner_approximation" title="Link to this definition">¶</a></dt>
<dd><p>Compute a polytopic inner-approximation of a given set via ray shooting.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>direction_vectors</strong> (<em>array_like</em><em>, </em><em>optional</em>) – Directions to use when performing ray shooting. Matrix (N times
self.dim) for some <span class="math notranslate nohighlight">\(N \geq 1\)</span>. Defaults to None.</p></li>
<li><p><strong>n_vertices</strong> (<em>int</em><em>, </em><em>optional</em>) – Number of vertices to be used for the inner-approximation. n_vertices is
overridden whenever direction_vectors are provided.  Defaults to None.</p></li>
<li><p><strong>verbose</strong> (<em>bool</em><em>, </em><em>optional</em>) – If true, <a class="reference internal" href="pycvxset.common.html#pycvxset.common.spread_points_on_a_unit_sphere" title="pycvxset.common.spread_points_on_a_unit_sphere"><code class="xref py py-meth docutils literal notranslate"><span class="pre">pycvxset.common.spread_points_on_a_unit_sphere()</span></code></a> is passed with
verbose. Defaults to False.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Polytopic inner-approximation in V-Rep of a given set with n_vertices no smaller than user-provided
n_vertices.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="pycvxset.Polytope.html#pycvxset.Polytope.Polytope" title="pycvxset.Polytope.Polytope">Polytope</a></p>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>We compute the polytope using <a class="reference internal" href="#pycvxset.ConstrainedZonotope.ConstrainedZonotope.extreme" title="pycvxset.ConstrainedZonotope.ConstrainedZonotope.extreme"><code class="xref py py-meth docutils literal notranslate"><span class="pre">extreme()</span></code></a> evaluated along the direction vectors computed by
<a class="reference internal" href="pycvxset.common.html#pycvxset.common.spread_points_on_a_unit_sphere" title="pycvxset.common.spread_points_on_a_unit_sphere"><code class="xref py py-meth docutils literal notranslate"><span class="pre">pycvxset.common.spread_points_on_a_unit_sphere()</span></code></a>. When direction_vectors is None and n_vertices is None,
we select <span class="math notranslate nohighlight">\(\text{n\_vertices} = 2 \text{self.dim} + 2^\text{self.dim}
\text{SPOAUS\_DIRECTIONS\_PER\_QUADRANT}\)</span> (as defined in <code class="xref py py-meth docutils literal notranslate"><span class="pre">pycvxset.common.constants()</span></code>). <a class="reference internal" href="references.html#bv04" id="id12"><span>[BV04]</span></a></p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pycvxset.ConstrainedZonotope.ConstrainedZonotope.polytopic_outer_approximation">
<span class="sig-name descname"><span class="pre">polytopic_outer_approximation</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">direction_vectors</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_halfspaces</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pycvxset.ConstrainedZonotope.ConstrainedZonotope.polytopic_outer_approximation" title="Link to this definition">¶</a></dt>
<dd><p>Compute a polytopic outer-approximation of a given set via ray shooting.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>direction_vectors</strong> (<em>array_like</em><em>, </em><em>optional</em>) – Directions to use when performing ray shooting. Matrix (N times
self.dim) for some <span class="math notranslate nohighlight">\(N \geq 1\)</span>. Defaults to None.</p></li>
<li><p><strong>n_halfspaces</strong> (<em>int</em><em>, </em><em>optional</em>) – Number of halfspaces to be used for the inner-approximation. n_vertices is
overridden whenever direction_vectors are provided.  Defaults to None.</p></li>
<li><p><strong>verbose</strong> (<em>bool</em><em>, </em><em>optional</em>) – If true, <a class="reference internal" href="pycvxset.common.html#pycvxset.common.spread_points_on_a_unit_sphere" title="pycvxset.common.spread_points_on_a_unit_sphere"><code class="xref py py-meth docutils literal notranslate"><span class="pre">pycvxset.common.spread_points_on_a_unit_sphere()</span></code></a> is passed with
verbose. Defaults to False.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Polytopic outer-approximation in H-Rep of a given set with n_halfspaces no smaller than user-provided
n_vertices.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="pycvxset.Polytope.html#pycvxset.Polytope.Polytope" title="pycvxset.Polytope.Polytope">Polytope</a></p>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>We compute the polytope using <a class="reference internal" href="#pycvxset.ConstrainedZonotope.ConstrainedZonotope.support" title="pycvxset.ConstrainedZonotope.ConstrainedZonotope.support"><code class="xref py py-meth docutils literal notranslate"><span class="pre">support()</span></code></a> evaluated along the direction vectors computed by
<a class="reference internal" href="pycvxset.common.html#pycvxset.common.spread_points_on_a_unit_sphere" title="pycvxset.common.spread_points_on_a_unit_sphere"><code class="xref py py-meth docutils literal notranslate"><span class="pre">pycvxset.common.spread_points_on_a_unit_sphere()</span></code></a>. When direction_vectors is None and n_halfspaces is None,
we select <span class="math notranslate nohighlight">\(\text{n\_halfspaces} = 2 \text{self.dim} + 2^\text{self.dim}
\text{SPOAUS\_DIRECTIONS\_PER\_QUADRANT}\)</span> (as defined in <code class="xref py py-mod docutils literal notranslate"><span class="pre">pycvxset.common.constants</span></code>).  <a class="reference internal" href="references.html#bv04" id="id13"><span>[BV04]</span></a></p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pycvxset.ConstrainedZonotope.ConstrainedZonotope.project">
<span class="sig-name descname"><span class="pre">project</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">p</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">2</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycvxset/ConstrainedZonotope.html#ConstrainedZonotope.project"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pycvxset.ConstrainedZonotope.ConstrainedZonotope.project" title="Link to this definition">¶</a></dt>
<dd><p>Project a point or a collection of points on to a set.</p>
<p>Given a set <span class="math notranslate nohighlight">\(\mathcal{P}\)</span> and a test point <span class="math notranslate nohighlight">\(y\in\mathbb{R}^{\mathcal{P}.\text{dim}}\)</span>, this function
solves a convex program,</p>
<blockquote>
<div><div class="math notranslate nohighlight">
\[\begin{split}\text{minimize}    &amp;\quad  \|x - y\|_p\\
\text{subject to}  &amp;\quad  x \in \mathcal{P}\\\end{split}\]</div>
</div></blockquote>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>points</strong> (<em>array_like</em>) – Points to project. Matrix (N times self.dim), where each row is a point.</p></li>
<li><p><strong>p</strong> (<em>str</em><em> | </em><em>int</em>) – Norm-type. It can be 1, 2, or ‘inf’. Defaults to 2, which is the Euclidean norm.</p></li>
</ul>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>ValueError</strong> – Set is empty</p></li>
<li><p><strong>ValueError</strong> – Dimension mismatch — no. of columns in points is different from self.dim.</p></li>
<li><p><strong>ValueError</strong> – Points is not convertible into a 2D array</p></li>
<li><p><strong>NotImplementedError</strong> – Unable to solve problem using CVXPY</p></li>
</ul>
</dd>
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p><dl class="simple">
<dt>A tuple with two items:</dt><dd><ol class="arabic simple">
<li><p>projected_point (numpy.ndarray): Projection point(s) as a 2D numpy.ndarray. Matrix (N times self.dim),
where each row is a projection of the point in points to the set <span class="math notranslate nohighlight">\(\mathcal{P}\)</span>.</p></li>
<li><p>distance (numpy.ndarray): Distance(s) as a 1D numpy.ndarray. Vector (N,), where each row is a projection
of the point in points to the set <span class="math notranslate nohighlight">\(\mathcal{P}\)</span>.</p></li>
</ol>
</dd>
</dl>
</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>tuple</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>Given a constrained zonotope <span class="math notranslate nohighlight">\(\mathcal{P}\)</span> and a test point
<span class="math notranslate nohighlight">\(y\in\mathbb{R}^{\mathcal{P}.\text{dim}}\)</span>, this function solves a convex program with decision variables
<span class="math notranslate nohighlight">\(x\in\mathbb{R}^{\mathcal{P}.\text{dim}}\)</span> and <span class="math notranslate nohighlight">\(\xi\in\mathbb{R}^{\mathcal{P}.\text{latent\_dim}}\)</span>,</p>
<div class="math notranslate nohighlight">
\[\begin{split}\text{minimize}    &amp;\quad  \|x - y\|_p\\
\text{subject to}  &amp;\quad  x = G_P \xi + c_P\\
                   &amp;\quad  A_P \xi = b_P\\
                   &amp;\quad  \|\xi\|_\infty \leq 1\end{split}\]</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pycvxset.ConstrainedZonotope.ConstrainedZonotope.projection">
<span class="sig-name descname"><span class="pre">projection</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">project_away_dims</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycvxset/ConstrainedZonotope.html#ConstrainedZonotope.projection"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pycvxset.ConstrainedZonotope.ConstrainedZonotope.projection" title="Link to this definition">¶</a></dt>
<dd><p>Orthogonal projection of a set <span class="math notranslate nohighlight">\(\mathcal{P}\)</span> after removing some user-specified dimensions.</p>
<div class="math notranslate nohighlight">
\[\mathcal{R} = \{r \in \mathbb{R}^{m}\ |\  \exists v \in \mathbb{R}^{n - m},\ \text{Lift}(r,v)\in \mathcal{P}\}\]</div>
<p>Here, <span class="math notranslate nohighlight">\(m = \mathcal{P}.\text{dim} - \text{length}(\text{project\_away\_dim})\)</span>, and
<span class="math notranslate nohighlight">\(\text{Lift}(r,v)\)</span> lifts (“undo”s the projection) using the appropriate components of <cite>v</cite>. This function uses
<a class="reference internal" href="#pycvxset.ConstrainedZonotope.ConstrainedZonotope.affine_map" title="pycvxset.ConstrainedZonotope.ConstrainedZonotope.affine_map"><code class="xref py py-meth docutils literal notranslate"><span class="pre">affine_map()</span></code></a> to implement the projection by designing an appropriate affine map <span class="math notranslate nohighlight">\(M \in
\{0,1\}^{m\times\mathcal{P}.\text{dim}}\)</span> with each row of <span class="math notranslate nohighlight">\(M\)</span> corresponding to some standard axis vector
<span class="math notranslate nohighlight">\(e_i\in\mathbb{R}^m\)</span>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>project_away_dims</strong> (<em>array_like</em>) – Dimensions to projected away in integer interval [0, 1, …, n - 1].</p>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>ValueError</strong> – When project_away_dims are not in the integer interval | All dimensions are projected away</p>
</dd>
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>m-dimensional set obtained via projection.</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><a class="reference internal" href="#pycvxset.ConstrainedZonotope.ConstrainedZonotope" title="pycvxset.ConstrainedZonotope.ConstrainedZonotope">ConstrainedZonotope</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pycvxset.ConstrainedZonotope.ConstrainedZonotope.remove_redundancies">
<span class="sig-name descname"><span class="pre">remove_redundancies</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pycvxset.ConstrainedZonotope.ConstrainedZonotope.remove_redundancies" title="Link to this definition">¶</a></dt>
<dd><p>Remove any redundancies in the equality system using pycddlib and other geometric properties</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pycvxset.ConstrainedZonotope.ConstrainedZonotope.slice">
<span class="sig-name descname"><span class="pre">slice</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dims</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">constants</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycvxset/ConstrainedZonotope.html#ConstrainedZonotope.slice"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pycvxset.ConstrainedZonotope.ConstrainedZonotope.slice" title="Link to this definition">¶</a></dt>
<dd><p>Slice a set restricting certain dimensions to constants.</p>
<p>This function uses <a class="reference internal" href="#pycvxset.ConstrainedZonotope.ConstrainedZonotope.intersection_with_affine_set" title="pycvxset.ConstrainedZonotope.ConstrainedZonotope.intersection_with_affine_set"><code class="xref py py-meth docutils literal notranslate"><span class="pre">intersection_with_affine_set()</span></code></a> to implement the slicing by designing an appropriate affine
set from dims and constants.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>dims</strong> (<em>array_like</em>) – List of dims to restrict to a constant in the integer interval [0, 1, …, n - 1].</p></li>
<li><p><strong>constants</strong> (<em>array_like</em>) – List of constants</p></li>
</ul>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>ValueError</strong> – dims has entries beyond n</p></li>
<li><p><strong>ValueError</strong> – dims and constants are not 1D arrays of same size</p></li>
</ul>
</dd>
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>Constrained zonotope that has been sliced at the specified dimensions.</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><a class="reference internal" href="#pycvxset.ConstrainedZonotope.ConstrainedZonotope" title="pycvxset.ConstrainedZonotope.ConstrainedZonotope">ConstrainedZonotope</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pycvxset.ConstrainedZonotope.ConstrainedZonotope.slice_then_projection">
<span class="sig-name descname"><span class="pre">slice_then_projection</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dims</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">constants</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycvxset/ConstrainedZonotope.html#ConstrainedZonotope.slice_then_projection"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pycvxset.ConstrainedZonotope.ConstrainedZonotope.slice_then_projection" title="Link to this definition">¶</a></dt>
<dd><p>Wrapper for <a class="reference internal" href="#pycvxset.ConstrainedZonotope.ConstrainedZonotope.slice" title="pycvxset.ConstrainedZonotope.ConstrainedZonotope.slice"><code class="xref py py-meth docutils literal notranslate"><span class="pre">slice()</span></code></a> and <a class="reference internal" href="#pycvxset.ConstrainedZonotope.ConstrainedZonotope.projection" title="pycvxset.ConstrainedZonotope.ConstrainedZonotope.projection"><code class="xref py py-meth docutils literal notranslate"><span class="pre">projection()</span></code></a>.</p>
<p>The function first restricts a set at certain dimensions to constants, and then projects away those dimensions.
Useful for visual inspection of higher dimensional sets.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>dims</strong> (<em>array_like</em>) – List of dims to restrict to a constant in the integer interval [0, 1, …, dim - 1], and then
project away.</p></li>
<li><p><strong>constants</strong> (<em>array_like</em>) – List of constants</p></li>
</ul>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>ValueError</strong> – dims has entries beyond n</p></li>
<li><p><strong>ValueError</strong> – dims and constants are not 1D arrays of same size</p></li>
<li><p><strong>ValueError</strong> – When dims are not in the integer interval | All dimensions are projected away</p></li>
</ul>
</dd>
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>m-dimensional set obtained via projection after slicing.</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><a class="reference internal" href="#pycvxset.ConstrainedZonotope.ConstrainedZonotope" title="pycvxset.ConstrainedZonotope.ConstrainedZonotope">ConstrainedZonotope</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pycvxset.ConstrainedZonotope.ConstrainedZonotope.support">
<span class="sig-name descname"><span class="pre">support</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">eta</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycvxset/ConstrainedZonotope.html#ConstrainedZonotope.support"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pycvxset.ConstrainedZonotope.ConstrainedZonotope.support" title="Link to this definition">¶</a></dt>
<dd><p>Evaluates the support function and support vector of a set.</p>
<p>The support function of a set <span class="math notranslate nohighlight">\(\mathcal{P}\)</span> is defined as <span class="math notranslate nohighlight">\(\rho_{\mathcal{P}}(\eta) =
\max_{x\in\mathcal{P}} \eta^\top x\)</span>. The support vector of a set <span class="math notranslate nohighlight">\(\mathcal{P}\)</span> is defined as
<span class="math notranslate nohighlight">\(\nu_{\mathcal{P}}(\eta) = \arg\max_{x\in\mathcal{P}} \eta^\top x\)</span>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>eta</strong> (<em>array_like</em>) – Support directions. Matrix (N times self.dim), where each row is a support direction.</p>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>ValueError</strong> – Set is empty</p></li>
<li><p><strong>ValueError</strong> – Mismatch in eta dimension</p></li>
<li><p><strong>ValueError</strong> – eta is not convertible into a 2D array</p></li>
<li><p><strong>NotImplementedError</strong> – Unable to solve problem using CVXPY</p></li>
</ul>
</dd>
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p><dl class="simple">
<dt>A tuple with two items:</dt><dd><ol class="arabic simple">
<li><p>support_function_evaluations (numpy.ndarray): Support function evaluation(s) as a 2D numpy.ndarray.
Vector (N,) with as many rows as eta.</p></li>
<li><p>support_vectors (numpy.ndarray): Support vectors as a 2D numpy.ndarray. Matrix N x self.dim with as many
rows as eta.</p></li>
</ol>
</dd>
</dl>
</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>tuple</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>Given a constrained zonotope <span class="math notranslate nohighlight">\(\mathcal{P}\)</span> and a support direction
<span class="math notranslate nohighlight">\(\eta\in\mathbb{R}^{\mathcal{P}.\text{dim}}\)</span>, this function solves a convex program with decision
variables <span class="math notranslate nohighlight">\(x\in\mathbb{R}^{\mathcal{P}.\text{dim}}\)</span> and
<span class="math notranslate nohighlight">\(\xi\in\mathbb{R}^{\mathcal{P}.\text{latent\_dim}}\)</span>,</p>
<div class="math notranslate nohighlight">
\[\begin{split}\text{maximize}     &amp;\quad \eta^\top x\\
\text{subject to}   &amp;\quad x = G_P \xi + c_P\\
                    &amp;\quad A_P \xi = b_P\\
                    &amp;\quad \|\xi\|_\infty \leq 1\end{split}\]</div>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="pycvxset.ConstrainedZonotope.ConstrainedZonotope.Ae">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">Ae</span></span><a class="headerlink" href="#pycvxset.ConstrainedZonotope.ConstrainedZonotope.Ae" title="Link to this definition">¶</a></dt>
<dd><p>Equality coefficient vectors Ae for the constrained zonotope.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>Equality coefficient vectors Ae for the constrained zonotope. Ae is np.empty((0,
self.latent_dim)) for a zonotope.</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>numpy.ndarray</p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="pycvxset.ConstrainedZonotope.ConstrainedZonotope.G">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">G</span></span><a class="headerlink" href="#pycvxset.ConstrainedZonotope.ConstrainedZonotope.G" title="Link to this definition">¶</a></dt>
<dd><p>Affine transformation matrix G for the constrained zonotope.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>Affine transformation matrix G.</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>numpy.ndarray</p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="pycvxset.ConstrainedZonotope.ConstrainedZonotope.He">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">He</span></span><a class="headerlink" href="#pycvxset.ConstrainedZonotope.ConstrainedZonotope.He" title="Link to this definition">¶</a></dt>
<dd><p>Equality constraints <cite>He=[Ae, be]</cite> for the constrained zonotope.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>H-Rep in [Ae, be]. He is np.empty((0, self.latent_dim + 1)) for a zonotope.</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>numpy.ndarray</p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="pycvxset.ConstrainedZonotope.ConstrainedZonotope.be">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">be</span></span><a class="headerlink" href="#pycvxset.ConstrainedZonotope.ConstrainedZonotope.be" title="Link to this definition">¶</a></dt>
<dd><p>Equality constants be for the constrained zonotope.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>Equality constants be for the constrained zonotope. be is np.empty((0,)) for a zonotope.</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>numpy.ndarray</p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="pycvxset.ConstrainedZonotope.ConstrainedZonotope.c">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">c</span></span><a class="headerlink" href="#pycvxset.ConstrainedZonotope.ConstrainedZonotope.c" title="Link to this definition">¶</a></dt>
<dd><p>Affine transformation vector c for the constrained zonotope.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>Affine transformation vector c.</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>numpy.ndarray</p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="pycvxset.ConstrainedZonotope.ConstrainedZonotope.cvxpy_args_lp">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">cvxpy_args_lp</span></span><a class="headerlink" href="#pycvxset.ConstrainedZonotope.ConstrainedZonotope.cvxpy_args_lp" title="Link to this definition">¶</a></dt>
<dd><p>CVXPY arguments in use when solving a linear program</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>CVXPY arguments in use when solving a linear program. Defaults to dictionary in
<cite>pycvxset.common.DEFAULT_CVXPY_ARGS_LP</cite>.</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>dict</p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="pycvxset.ConstrainedZonotope.ConstrainedZonotope.cvxpy_args_socp">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">cvxpy_args_socp</span></span><a class="headerlink" href="#pycvxset.ConstrainedZonotope.ConstrainedZonotope.cvxpy_args_socp" title="Link to this definition">¶</a></dt>
<dd><p>CVXPY arguments in use when solving a second-order cone program</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>CVXPY arguments in use when solving a second-order cone program. Defaults to dictionary in
<cite>pycvxset.common.DEFAULT_CVXPY_ARGS_SOCP</cite>.</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>dict</p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="pycvxset.ConstrainedZonotope.ConstrainedZonotope.dim">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">dim</span></span><a class="headerlink" href="#pycvxset.ConstrainedZonotope.ConstrainedZonotope.dim" title="Link to this definition">¶</a></dt>
<dd><p>Dimension of the constrained zonotope.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>Dimension of the constrained zonotope.</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>int</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>We determine dimension from G, since c is set to None in case of empty (constrained) zonotope.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="pycvxset.ConstrainedZonotope.ConstrainedZonotope.is_bounded">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">is_bounded</span></span><a class="headerlink" href="#pycvxset.ConstrainedZonotope.ConstrainedZonotope.is_bounded" title="Link to this definition">¶</a></dt>
<dd><p>Check if the constrained zonotope is bounded (which is always True)</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="pycvxset.ConstrainedZonotope.ConstrainedZonotope.is_empty">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">is_empty</span></span><a class="headerlink" href="#pycvxset.ConstrainedZonotope.ConstrainedZonotope.is_empty" title="Link to this definition">¶</a></dt>
<dd><p>Check if the constrained zonotope is empty</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>NotImplementedError</strong> – Unable to solve the feasibility problem using CVXPY</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>When True, the polytope is empty</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>bool</p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="pycvxset.ConstrainedZonotope.ConstrainedZonotope.is_full_dimensional">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">is_full_dimensional</span></span><a class="headerlink" href="#pycvxset.ConstrainedZonotope.ConstrainedZonotope.is_full_dimensional" title="Link to this definition">¶</a></dt>
<dd><p>Check if the affine dimension of the constrained zonotope is the same as the constrained zonotope dimension</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>True when the affine hull containing the constrained zonotope has the dimension <cite>self.dim</cite></p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>bool</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>An empty polytope is full dimensional if dim=0, otherwise it is not full-dimensional. See Sec. 2.1.3 of
[BV04] for discussion on affine dimension.</p>
<p>A non-empty zonotope is full-dimensional if and only if G has full row rank.</p>
<p>A non-empty constrained zonotope is full-dimensional if and only if [G; A] has full row rank.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="pycvxset.ConstrainedZonotope.ConstrainedZonotope.is_singleton">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">is_singleton</span></span><a class="headerlink" href="#pycvxset.ConstrainedZonotope.ConstrainedZonotope.is_singleton" title="Link to this definition">¶</a></dt>
<dd><p>Check if the constrained zonotope is a singleton</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="pycvxset.ConstrainedZonotope.ConstrainedZonotope.is_zonotope">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">is_zonotope</span></span><a class="headerlink" href="#pycvxset.ConstrainedZonotope.ConstrainedZonotope.is_zonotope" title="Link to this definition">¶</a></dt>
<dd><p>Check if the constrained zonotope is a zonotope</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="pycvxset.ConstrainedZonotope.ConstrainedZonotope.latent_dim">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">latent_dim</span></span><a class="headerlink" href="#pycvxset.ConstrainedZonotope.ConstrainedZonotope.latent_dim" title="Link to this definition">¶</a></dt>
<dd><p>Latent dimension of the constrained zonotope.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>Latent dimension of the constrained zonotope.</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>int</p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="pycvxset.ConstrainedZonotope.ConstrainedZonotope.n_equalities">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">n_equalities</span></span><a class="headerlink" href="#pycvxset.ConstrainedZonotope.ConstrainedZonotope.n_equalities" title="Link to this definition">¶</a></dt>
<dd><p>Number of equality constraints used when defining the constrained zonotope.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>Number of equality constraints used when defining the constrained zonotope</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>int</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</section>


          </div>
          
        </div>
      </div>
    <div class="clearer"></div>
  </div>
    <div class="footer">
      &#169;2020-2025, Mitsubishi Electric Research Laboratories (MERL).
      
      |
      Powered by <a href="https://www.sphinx-doc.org/">Sphinx 8.1.3</a>
      &amp; <a href="https://alabaster.readthedocs.io">Alabaster 1.0.0</a>
      
      |
      <a href="_sources/pycvxset.ConstrainedZonotope.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>